static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(&data);}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, L"%s", args);va_end(args);printWLine(dest);}}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;main_vasink(data, data);}
static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));{wchar_t dest[50]=L"";wcsncat(dest, data, wcslen(data));printWLine(data);free(data);}}
static char * main_source(char * password){strcpy(password, "Password1234!");return password;}static void main(){char * password;char password_buf[100]="";password=password_buf;password=main_source(password);{HANDLE pHandle;char * username="User";char * domain="Domain";if (LogonUserA( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}
void _main_sink(short data){{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}static void main(){short data;data=0;data=100-1;_main_sink(data);}
static void main_sink(){unsigned int data=_main_data;{unsigned int result=data+1;printUnsignedLine(result);}}static void main(){unsigned int data;data=0;data=5;_main_data=data;main_sink();}
static void main_sink(wchar_t * data){{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"15");func_ptr(data);}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"15");func_ptr(data);}void b_main_sink(wchar_t * data){{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;data=new char[100];func_ptr(data);}void main_sink(char * data){delete [] data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;if(global_returns_t_or_f()){strcat(data, "*.*");}else{strcat(data, "*.*");}{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnvp(_P_WAIT, COMMAND_INT, args);}}
void b_main_sink(int data_array[]);static void main(){int data;int data_array[5];data=-1;data=ASSERT_VALUE+1;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];assert(data > ASSERT_VALUE);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){int data;data=-1;data=7;{int data_copy=data;int data=data_copy;printIntLine(100/data);}}
static void main(){int * data;data=(int *)malloc(100);{int * data_copy=data;int * data=data_copy;if (data!=NULL){data[0]=5;printIntLine(data[0]);free(data);}}}
static void main(){FILE * data;void (*func_ptr) (FILE *)=b_main_sink;data=freopen("BadSource_freopen.txt","w+",stdin);fclose(data);func_ptr(data);}void b_main_sink(FILE * data){}
static void main(){int * data;int data_uninit_array[10];data=data_uninit_array;{int i;for(i=0;i<(10/2);i++){data[i]=i;}}{int i;for(i=0;i<10;i++){data[i]=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[FILENAME_MAX]="";data=data_buf;{char * data=*data_ptr1;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");}{char * data=*data_ptr2;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}}
static void main(){char * password;password="";password=(char *)malloc(100*sizeof(char));if(!VirtualLock(password, 100*sizeof(char))){printLine("Memory could not be locked");exit(1);}strcpy(password, "Password1234!");{HANDLE pHandle;char * username="User";char * domain="Domain";if (LogonUserA( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}
static void main(){long long * data;long long data_badbuf[50];long long data_goodbuf[100];data=data_goodbuf;{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printLongLongLine(data[0]);}}}
static void main(){long long * data;data=NULL;main_source(data);delete [] data;}void main_source(long long * &data){data=new long long[100];}
static void main(){int count;count=-1;if(global_returns_t_or_f()){fscanf (stdin, "%d", &count);}else{fscanf (stdin, "%d", &count);}if(global_returns_t_or_f()){{size_t i=0;if (count > 0 && count <=20){for (i=0;i < (size_t)count;i++){printLine("Hello");}}}}else{{size_t i=0;if (count > 0 && count <=20){for (i=0;i < (size_t)count;i++){printLine("Hello");}}}}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}}{int data=*data_ptr2;{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");func_ptr(data);}void b_main_sink(wchar_t * data){EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main_sink(){unsigned char data=_main_data;{unsigned char result=data+1;printHexUnsignedCharLine(result);}}static void main(){unsigned char data;data=' ';data=5;_main_data=data;main_sink();}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=5;}{int data=*data_ptr2;{int result=data * data;printIntLine(result);}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");printf(data);}
static void main(){wchar_t * data;struct_type my_struct;data=NULL;data=new wchar_t;delete data;my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){wchar_t * data=my_struct.a;}
void main_sink_b(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_sink_b(data);}void main_sink_c(wchar_t * data);void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_d(wchar_t * data);void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_e(wchar_t * data);void main_sink_d(wchar_t * data){main_sink_e(data);}void main_sink_e(wchar_t * data){{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));printWLine(data);delete [] data;}}
static void main(){unsigned int data;data=0;data=5;b_main_sink(data);}void b_main_sink(unsigned int data){c_main_sink(data);}void c_main_sink(unsigned int data){{unsigned int result=data+1;printUnsignedLine(result);}}
static void main(){char * data;char * data_array[5];char data_buf[100]="";data=data_buf;data=PASSWORD;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];if (strstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(FILE * data);static void main(){FILE * data;data=NULL;data=freopen("BadSource_freopen.txt","w+",stdin);b_main_sink(data);}void c_main_sink(FILE * data);void b_main_sink(FILE * data){c_main_sink(data);}void c_main_sink(FILE * data){if (data!=NULL){fclose(data);}}
static void main(){wchar_t * data;wchar_t * &data_ref=data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}{wchar_t * data=data_ref;{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]=L'\0';printWLine(data);}}}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, L"%s", args);va_end(args);}}static void main_sink(){wchar_t * data=_main_data;main_vasink(data, data);}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}_main_data=data;main_sink();}
static void main_sink(){char * data=_main_data;if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}_main_data=data;main_sink();}
static void main(){char * data;data=NULL;{char data_goodbuf[100];data=data_goodbuf;strcpy(data, "A String");printLine(data);}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}}{int data=*data_ptr2;{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}}
static void main(){char * data;data=NULL;{char data_goodbuf[100];data=data_goodbuf;strcpy(data, "A String");printLine(data);}}
static void main_sink(){int * data=main_data;free(data);}static void main(){int * data;data=NULL;data=(int *)calloc(100, sizeof(int));main_data=data;main_sink();}
static void main(){int data;data=-1;if(global_returns_t_or_f()){data=20;}else{data=20;}{size_t a,i;int *b;b=(int*)new char[a];for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);delete [] b;}}
FILE * b_main_source(FILE * data);static void main(){FILE * data;data=NULL;data=b_main_source(data);if (data!=NULL){fclose(data);}}FILE * b_main_source(FILE * data){data=freopen("BadSource_freopen.txt","w+",stdin);return data;}
static int main_source(int data){data=20;return data;}static void main(){int data;data=-1;data=main_source(data);{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}
static void main(){wchar_t * data;_union_type my_union;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;my_union.a=data;{wchar_t * data=my_union.b;{wchar_t src[100];wcscpy(data, src);printWLine(data);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_t_or_f()){data=L"P";}else{data=L"P";}if(global_returns_t_or_f()){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}else{if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}}
void b_main_sink();static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));_main_data=data;b_main_sink();}void b_main_sink(){twoints * data=_main_data;{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memcpy(data, src, 100*sizeof(twoints));printStructLine(&data[0]);free(data);}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_buf[100];data=data_buf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char dest[50]="";strcat(dest, data);printLine(data);}}
static void main(){unsigned char data;data=' ';if(global_returns_t_or_f()){data=5;}else{data=5;}if(global_returns_t_or_f()){{unsigned char result=data * 2;printHexUnsignedCharLine(result);}}else{{unsigned char result=data * 2;printHexUnsignedCharLine(result);}}}
void main_sink_b(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_sink_b(data);}void main_sink_c(wchar_t * data);void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_d(wchar_t * data);void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_e(wchar_t * data);void main_sink_d(wchar_t * data){main_sink_e(data);}void main_sink_e(wchar_t * data){{wchar_t src[100];wcsncpy(data, src, 100);printWLine(data);delete [] data;}}
static void main(){int * data;data=NULL;data=new int[100];{int * data_copy=data;int * data=data_copy;{memcpy(data, src, 100*sizeof(int));printIntLine(data[0]);delete [] data;}}}
static void main(){short data;data=0;data=100-1;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
void b_main_sink(void * void_data_ptr);static void main(){twoints * data;data=NULL;{twoints tmp;tmp.a=0;tmp.b=0;data=&tmp;}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){twoints * * data_ptr=(twoints * *)void_data_ptr;twoints * data=(*data_ptr);printStructLine(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);wprintf(data);}wchar_t * b_main_source(wchar_t * data){wcscpy(data, L"fixedstringtest");return data;}
static void main(){HANDLE data;data=INVALID_HANDLE_VALUE;data=CreateFile("BadSource_w32CreateFile.txt", (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if(global_returns_t_or_f()){if (data!=INVALID_HANDLE_VALUE){CloseHandle(data);}}else{if (data!=INVALID_HANDLE_VALUE){CloseHandle(data);}}}
static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));data[0]=L'\0';{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}{wchar_t * data_copy=data;wchar_t * data=data_copy;{size_t i;for (i=0;i < wcslen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100];data=data_buf;func_ptr(data);}void b_main_sink(wchar_t * data){{wchar_t src[100];wcscat(data, src);printWLine(data);}}
static void main(){double * data;data=(double *)malloc(10*sizeof(double));if(global_returns_t_or_f()){}else{}if(global_returns_t_or_f()){{int i;for(i=0;i<10;i++){data[i]=(double)i;}}{int i;for(i=0;i<10;i++){printDoubleLine(data[i]);}}}else{{int i;for(i=0;i<10;i++){data[i]=(double)i;}}{int i;for(i=0;i<10;i++){printDoubleLine(data[i]);}}}}
static void main(){char data;data=' ';data=CHAR_MIN;{char result=0;if (data > CHAR_MIN){result=data-1;printHexCharLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static int main_source(int data){data=20;return data;}static void main(){int data;data=-1;data=main_source(data);{size_t i;int *b;b=(int*)malloc(data * sizeof(int));for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);free(b);}}
static void main_sink(twointsclass * data){free(data);}static void main(){twointsclass * data;void (*func_ptr) (twointsclass *)=main_sink;data=NULL;data=(twointsclass *)malloc(100*sizeof(twointsclass));func_ptr(data);}
static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));if(global_returns_t_or_f()){data=data_goodbuf;}else{data=data_goodbuf;}{wchar_t dest[100];wmemset(dest, L'C', 100-1);memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
void b_main_sink(int data);static void main(){int data;data=-1;data=CHAR_MAX-5;b_main_sink(data);}void b_main_sink(int data){{char c=(char)data;printHexCharLine(c);}}
static void main(){unsigned int data;data=0;data=b_main_source(data);{unsigned int result=data * data;printUnsignedLine(result);}}unsigned int b_main_source(unsigned int data){data=5;return data;}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];data=NULL;data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t data_src[10+1]=SRC_STRING;memcpy(data, data_src, wcslen(data_src)*sizeof(wchar_t));printWLine(data);free(data);}}
static void main(){int count;int *count_ptr1=&count;int *count_ptr2=&count;count=-1;{int count=*count_ptr1;count=20;}{int count=*count_ptr2;{size_t i=0;for (i=0;i < (size_t)count;i++){printLine("Hello");}}}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=CHAR_MAX-5;}{int data=*data_ptr2;{short s=(short)data;printf("%hd\n", s);}}}
void b_main_sink();static void main(){wchar_t * password;wchar_t password_buf[100]=L"";password=password_buf;{size_t password_len=0;fgetws(password, 100, stdin);password_len=wcslen(password);if (password_len > 0){password[password_len-1]=L'\0';}}_main_data=password;b_main_sink();}void b_main_sink(){wchar_t * password=_main_data;{HANDLE pHandle;wchar_t * username=L"User";wchar_t * domain=L"Domain";if (LogonUserW( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");{wchar_t * data_copy=data;wchar_t * data=data_copy;_wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}}
void main_source(twointsclass * &data);static void main(){twointsclass * data;data=NULL;main_source(data);{twointsclass src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printIntLine(data[0].a);delete [] data;}}}void main_source(twointsclass * &data){data=new twointsclass[100];}
static void main(){int data;data=-1;data=b_main_source(data);{int result=data+1;printIntLine(result);}}int b_main_source(int data){data=5;return data;}
static void main_sink(char * data){printf(data);}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");func_ptr(data);}
void main_sink_b(wchar_t * data);static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}main_sink_b(data);}void main_sink_c(wchar_t * data);void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_d(wchar_t * data);void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_e(wchar_t * data);void main_sink_d(wchar_t * data){main_sink_e(data);}void main_sink_e(wchar_t * data){{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}
static void main_sink(wchar_t * data){{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, L"%s", data);printWLine(dest);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}main_sink(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;func_ptr(data);}void b_main_sink(wchar_t * data){{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]=L'\0';printWLine(data);}}
static void main_sink(int * data){free(data);}static void main(){int * data;data=NULL;data=(int *)malloc(100*sizeof(int));main_sink(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_t_or_f()){{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}}else{{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}}if(global_returns_t_or_f()){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}else{if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}}
void b_main_sink(char * data);static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;b_main_sink(data);}void b_main_sink(char * data){{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}printLine(data);}}
static void main(){long long * data;data=NULL;data=new long long[100];delete [] data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(&data);}static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, "%s", args);va_end(args);printLine(dest);}}void b_main_sink(char * * data_ptr){char * data=*data_ptr;main_vasink(data, data);}
static void main_sink(twointsclass * data){free(data);}static void main(){twointsclass * data;void (*func_ptr) (twointsclass *)=main_sink;data=NULL;data=(twointsclass *)calloc(100, sizeof(twointsclass));func_ptr(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){wprintf(L"%s\n", data);}
static void main(){char * data;data=NULL;if(global_returns_t_or_f()){data=(char *)malloc(100*sizeof(char));}else{data=(char *)malloc(100*sizeof(char));}{char dest[100];memset(dest, 'C', 100-1);memcpy(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);free(data);}}
static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));main_data=data;main_sink();}void main_sink(){char * data=main_data;free(data);}
static void main_sink(){int data=_main_data;{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than the length of the source string or too large");}}}static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}_main_data=data;main_sink();}
static void main(){FILE * data;data=NULL;data=fopen("BadSource_fopen.txt", "w+");if (data!=NULL){fclose(data);}}
static void main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}main_sink(data);}
static void main(){{char data;char * pointer=(char *)malloc(sizeof(char));data=5;{char data=*pointer;printHexCharLine(data);}free(pointer);}}
static void main(){int * data;data=NULL;data=new int[100];main_sink_b(data);}void main_sink_b(int * data){main_sink_c(data);}void main_sink_c(int * data){delete [] data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(&data);}static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, data, args);va_end(args);printLine(dest);}}void b_main_sink(char * * data_ptr){char * data=*data_ptr;main_vasink(data, data);}
void main_sink_b(char * data);static void main(){char * data;data=new char[100];main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_d(char * data);void main_sink_c(char * data){main_sink_d(data);}void main_sink_e(char * data);void main_sink_d(char * data){main_sink_e(data);}void main_sink_e(char * data){{char dest[50]="";strncpy(dest, data, strlen(data));printLine(data);delete [] data;}}
static void main(){long long data;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){long long * data_ptr=(long long *)void_data_ptr;long long data=(*data_ptr);data=5L;printLongLongLine(data);}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;data=L"P";my_union.a=data;{wchar_t * data=my_union.b;if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}}
static int main_source(int data){data=20;return data;}static void main(){int data;data=-1;data=main_source(data);{char * char_string;if (data > 0){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than 0");}}}
static void main_sink(){char * data=_main_data;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_main_data=data;main_sink();}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[250]=L"PATH=";data=data_buf;wcscat(data, NEW_PATH);b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){PUTENV(data);}
static void main(){int data;_union_type my_union;data=10;my_union.a=data;{int data=my_union.b;{char data_buf[10]="AAAAAAAAA";{printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data, L'A', 100-1);data[100-1]=L'\0';_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;printWLine(data);}
static void main(){long long * data;long long * data_array[5];data=NULL;{long long data_goodbuf[100];data=data_goodbuf;data[0]=5L;printLongLongLine(data[0]);}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(long long * data_array[]){long long * data=data_array[2];}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(&data);}static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, data, args);va_end(args);printLine(dest);}}void b_main_sink(char * * data_ptr){char * data=*data_ptr;main_vasink(data, data);}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;my_union.a=data;{wchar_t * data=my_union.b;{wchar_t dest[100];wcsncpy(dest, data, wcslen(dest));dest[100-1]=L'\0';printWLine(dest);}}}
static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';if(global_returns_t_or_f()){data=data_buf;}else{data=data_buf;}{char dest[100];strcpy(dest, data);printLine(dest);}}
static void main(){short data;data=0;if(global_returns_t_or_f()){data=100-1;}else{data=100-1;}{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
static void main(){int * data;data=NULL;data=b_main_source(data);}int * b_main_source(int * data){{int data_goodbuf[100];data=data_goodbuf;data[0]=5;printIntLine(data[0]);}return data;}
static void main(){char * data;_union_type my_union;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;my_union.a=data;{char * data=my_union.b;{char src[100];memmove(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[250]=L"PATH=";data=data_buf;wcscat(data, NEW_PATH);my_union.a=data;{wchar_t * data=my_union.b;PUTENV(data);}}
static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}func_ptr(data);}void b_main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(HANDLE * data);static void main(){HANDLE data;data=INVALID_HANDLE_VALUE;data=CreateFile("BadSource_w32CreateFile.txt", (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);b_main_sink(&data);}void b_main_sink(HANDLE * data_ptr){HANDLE data=*data_ptr;if (data!=INVALID_HANDLE_VALUE){CloseHandle(data);}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=NULL;{char * data=*data_ptr1;data=(char *)malloc(100*sizeof(char));}{char * data=*data_ptr2;{char src[100];memcpy(data, src, 100*sizeof(char));printLine(data);free(data);}}}
static void main(){{if (putwchar((wchar_t)L'A')==WEOF){printLine("putwchar failed!");exit(1);}}}
static void main_sink(char * data){{char src[100];memcpy(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;func_ptr(data);}
void _main_sink(wchar_t * data){{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");_main_sink(data);}
int b_main_source(int data);static void main(){int data;data=-1;data=b_main_source(data);{short s=(short)data;printf("%hd\n", s);}}int b_main_source(int data){data=CHAR_MAX-5;return data;}
static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;if(global_returns_t_or_f()){}else{}{char dest[50]="";size_t i, data_len;data_len=strlen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printLine(data);}}
static void main_sink(list<int> data){{list<int>::iterator i;cout << "The list contains: ";for( i=data.begin();i!=data.end();i++){cout << " " << *i;}cout << endl;}}static void main(){list<int> data;data.push_back(100);data.push_back(0);main_sink(data);}
static int * main_source(int * data){data=new int[100];data[0]=5;printIntLine(data[0]);return data;}static void main(){int * data;data=NULL;data=main_source(data);delete[] data;}
static void main(){int * data;data=NULL;{int data_goodbuf[100];data=data_goodbuf;data[0]=5;printIntLine(data[0]);}_main_data=data;b_main_sink();}void b_main_sink(){int * data=_main_data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;if(global_returns_t_or_f()){{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}}else{{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}}if(global_returns_t_or_f()){fprintf(stdout, "%s\n", data);}else{fprintf(stdout, "%s\n", data);}}
void b_main_sink(HANDLE data_array[]);static void main(){HANDLE data;HANDLE data_array[5];data=INVALID_HANDLE_VALUE;data=CreateFile("BadSource_w32CreateFile.txt", (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);data_array[2]=data;b_main_sink(data_array);}void b_main_sink(HANDLE data_array[]){HANDLE data=data_array[2];if (data!=INVALID_HANDLE_VALUE){CloseHandle(data);}}
static void main(){twoints * data;twoints * &data_ref=data;data=new twoints[10];{int i;for(i=0;i<(10/2);i++){data[i].a=i;data[i].b=i;}}{twoints * data=data_ref;{int i;for(i=0;i<10;i++){data[i].a=i;data[i].b=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}delete [] data;}}
static void main(){short data;data=0;data=100-1;{short data_copy=data;short data=data_copy;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"C:\\Windows\\System32\\winsrv.dll");{HMODULE hModule;hModule=LoadLibraryW(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "C:\\Windows\\System32\\winsrv.dll");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{HMODULE hModule;hModule=LoadLibraryA(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;data=(char *)malloc(100*sizeof(char));func_ptr(data);}void main_sink(char * data){free(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;{char * data_copy=data;char * data=data_copy;if (strstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}}
static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';if(global_returns_t_or_f()){data=data_buf;}else{data=data_buf;}{char dest[100];memcpy(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
static void main(){unsigned int data;unsigned int data_array[5];data=0;data=UINT_MAX;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(unsigned int data_array[]){unsigned int data=data_array[2];{unsigned int result=-1;if (data <=(unsigned int)sqrt((unsigned int)UINT_MAX)){result=data * data;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main_sink(int data){}static void main(){int data;void (*func_ptr) (int)=main_sink;data=OPEN("BadSource_open.txt", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);CLOSE(data);func_ptr(data);}
void b_main_sink(int data_array[]);static void main(){int data;int data_array[5];data=-1;data=7;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];printIntLine(100/data);}
void _main_sink(char * data){{char dest[100];memset(dest, 'C', 100-1);memmove(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);}}static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;_main_sink(data);}
static void main(){int data;struct_type my_struct;data=-1;data=20;my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){int data=my_struct.a;{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}
static void main(){int data;data=10;b_main_sink(data);}void b_main_sink(int data){{char data_buf[10]="AAAAAAAAA";{printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(data);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, data, args);va_end(args);}}void b_main_sink(wchar_t * data){main_vasink(data, data);}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
void main_sink(void * void_data_ptr);static void main(){char * data;data=NULL;data=new char[100];main_sink(&data);}void main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{char src[100];_snprintf(data, 100, "%s", src);printLine(data);delete [] data;}}
static void main(){int data;_union_type my_union;data=-1;fscanf (stdin, "%d", &data);my_union.a=data;{int data=my_union.b;{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;printf("%s\n", data);}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf("%s", args);va_end(args);}}static void main(){char * data;void (*func_ptr) (char *, ...)=main_vasink;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}func_ptr(data);}
static void main_sink(){unsigned int data=_main_data;{unsigned int result=-1;if (data <=(unsigned int)sqrt((unsigned int)UINT_MAX)){result=data * data;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}static void main(){unsigned int data;data=0;data=(unsigned int)RAND32();_main_data=data;main_sink();}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{int result=-1;if (data < INT_MAX){result=data+1;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");my_union.a=data;{char * data=my_union.b;fprintf(stdout, data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "15");b_main_sink(data);}void b_main_sink(char * data){{int i, n, v;if (sscanf(data, "%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main(){twoints * data;data=NULL;data=new twoints;data->a=1;data->b=2;delete data;{twoints * data_copy=data;twoints * data=data_copy;}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnvp(_P_WAIT, COMMAND_INT, args);}}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;func_ptr(data);}void b_main_sink(char * data){{char dest[50]="";strncat(dest, data, strlen(data));printLine(data);}}
static void main(){char * data;data=NULL;{char data_goodbuf[100];data=data_goodbuf;strcpy(data, "A String");printLine(data);}{char * data_copy=data;char * data=data_copy;}}
static void main_sink(char * data){printf("%s\n", data);}static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}main_sink(data);}
static void main(){FILE * data;data=fopen("GoodSource_fopen.txt", "w+");fclose(data);}
static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");my_struct.a=data;b_main_sink(my_struct);}static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, data, args);va_end(args);printLine(dest);}}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;main_vasink(data, data);}
static void main(){twoints * data;struct_type my_struct;data=NULL;data=(twoints *)calloc(100, sizeof(twoints));my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){twoints * data=my_struct.a;free(data);}
static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}{char src[100];memcpy(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}
static void main(){int * data;int * *data_ptr1=&data;int * *data_ptr2=&data;data=NULL;{int * data=*data_ptr1;data=new int[100];}{int * data=*data_ptr2;delete [] data;}}
static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;strcat(data, "*.*");my_union.a=data;{char * data=my_union.b;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}}
float b_main_source(float data);static void main(){float data;data=0.0F;data=b_main_source(data);printDoubleLine((double)(100.0/data));}float b_main_source(float data){data=7.0F;return data;}
void main_source(char * &data);static void main(){char * data;data=NULL;main_source(data);{char dest[100];memset(dest, 'C', 100-1);memcpy(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);delete [] data;}}void main_source(char * &data){data=new char[100];}
static void main(){int * data;data=NULL;data=b_main_source(data);}int * b_main_source(int * data){data=(int *)malloc(100*sizeof(int));{size_t i;for(i=0;i < 100;i++){data[i]=5;}}free(data);return data;}
static void main(){int * data;int * *data_ptr1=&data;int * *data_ptr2=&data;data=NULL;{int * data=*data_ptr1;{int data_goodbuf[100];data=data_goodbuf;data[0]=5;printIntLine(data[0]);}}{int * data=*data_ptr2;}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, data, args);va_end(args);printLine(dest);}}static void main_sink(){char * data=_main_data;main_vasink(data, data);}static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");_main_data=data;main_sink();}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");b_main_sink(data);}void b_main_sink(char * data){{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]='\0';printLine(data);}}
void b_main_sink(void * void_data_ptr);static void main(){short data;data=0;data=100-1;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){short * data_ptr=(short *)void_data_ptr;short data=(*data_ptr);{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
static void main_sink(int data){{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}static void main(){int data;fscanf (stdin, "%d", &data);main_sink(data);}
static void main_source(wchar_t * &data){data=new wchar_t[100];}static void main(){wchar_t * data;data=NULL;main_source(data);delete [] data;}
static void main(){char data;_union_type my_union;data=' ';data=5;my_union.a=data;{char data=my_union.b;{char result=data-1;printHexCharLine(result);}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){_spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){int data;int data_array[5];data=-1;data=20;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}
static void main(){twoints * data;data=NULL;{twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine(&data[0]);}}
void main_sink_b(char * data);static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){{char src[100];strcpy(data, src);printLine(data);}}
void main_sink(struct_type my_struct);static void main(){char * data;struct_type my_struct;data=NULL;data=new char[100];my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){char * data=my_struct.a;{char src[100];_snprintf(data, 100, "%s", src);printLine(data);delete [] data;}}
static void main_sink(char * data){{char dest[100]="";SNPRINTF(dest, 100-1, data);printLine(dest);}}static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");main_sink(data);}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;b_main_sink(data);}void b_main_sink(char * data){{char src[100];strncpy(data, src, 100);data[100-1]='\0';printLine(data);}}
void main_sink(int * data){{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printIntLine(data[0]);delete [] data;}}}static void main(){int * data;data=NULL;data=new int[100];main_sink(data);}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;data=PASSWORD;}{wchar_t * data=*data_ptr2;if (wcsncmp(PASSWORD, data, wcslen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(wchar_t * data){if (wcsncmp(PASSWORD, data, wcslen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static void main_sink(){int * data=_main_data;free(data);}static void main(){int * data;data=NULL;data=(int *)malloc(100*sizeof(int));data[0]=5;printIntLine(data[0]);_main_data=data;main_sink();}
static void main(){{HANDLE hFile;char * filename="C:\\temp\\file.txt";hFile=CreateFileA( filename, GENERIC_READ, FILE_SHARE_READ, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile==INVALID_HANDLE_VALUE){printLine("File could not be created");}else{printLine("File created successfully");CloseHandle(hFile);}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t src[100];wcscpy(data, src);printWLine(data);free(data);}}
static void main_sink(unsigned char data){{unsigned char result=-1;if (data < UCHAR_MAX){result=data+1;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}static void main(){unsigned char data;void (*func_ptr) (unsigned char)=main_sink;data=' ';data=UCHAR_MAX;func_ptr(data);}
static void main(){struct _twoints * data;data=NULL;{struct _twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);}_main_data=data;b_main_sink();}void b_main_sink(){struct _twoints * data=_main_data;}
static short main_source(short data){data=100-1;return data;}static void main(){short data;data=0;data=main_source(data);{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static void main(){char * data;data=NULL;{char data_goodbuf[100];data=data_goodbuf;strcpy(data, "a string");printLine(data);}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t data_src[10+1]=SRC_STRING;size_t i, src_len;src_len=wcslen(data_src);for (i=0;i < src_len;i++){data[i]=data_src[i];}printWLine(data);free(data);}}}
static void main(){int data;data=-1;data=b_main_source(data);{int result=data+1;printIntLine(result);}}int b_main_source(int data){data=5;return data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static char * main_source(char * data){{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}return data;}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main_sink(wchar_t * data){{size_t i;wchar_t dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}func_ptr(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;if (wcsncmp(PASSWORD, data, wcslen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static void main_sink(int data){{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}static void main(){int data;data=-1;data=20;main_sink(data);}
static void main(){int count;count=-1;count=20;b_main_sink(&count);}void b_main_sink(int * count_ptr){int count=*count_ptr;{size_t i=0;for (i=0;i < (size_t)count;i++){printLine("Hello");}}}
static void main(){long long * data;data=NULL;data=new long long[100];data[0]=5L;printLongLongLine(data[0]);{long long * data_copy=data;long long * data=data_copy;delete[] data;}}
static void main(){int data;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);{char data_buf[10]="AAAAAAAAA";{printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
void main_source(char * &data);static void main(){char * data;data=NULL;main_source(data);{char src[100];_snprintf(data, 100, "%s", src);printLine(data);delete [] data;}}void main_source(char * &data){data=new char[100];}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char src[100];_snprintf(data, 100, "%s", src);printLine(data);}}
static unsigned char main_source(unsigned char data){data=(unsigned char)rand();return data;}static void main(){unsigned char data;data=' ';data=main_source(data);{unsigned char result=-1;if (data <=(UCHAR_MAX/2)){result=data * 2;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){char data;data=' ';fscanf (stdin, "%c", &data);b_main_sink(data);}void b_main_sink(char data){c_main_sink(data);}void c_main_sink(char data){d_main_sink(data);}void d_main_sink(char data){{char result=-1;if (data <=(CHAR_MAX/2)){result=data * 2;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
void main_sink(void * void_data_ptr);static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];main_sink(&data);}void main_sink(void * void_data_ptr){twointsclass * * data_ptr=(twointsclass * *)void_data_ptr;twointsclass * data=(*data_ptr);{twointsclass src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printIntLine(data[0].a);delete [] data;}}}
void _main_sink(wchar_t * data){{size_t i, dest_sz;wchar_t dest[100];wmemset(dest, L'C', 100-1);dest_sz=wcslen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);free(data);}}static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));_main_sink(data);}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{wchar_t src[100];wcscpy(data, src);printWLine(data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);if (strstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");my_union.a=data;{wchar_t * data=my_union.b;{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}}
static void main(){wchar_t * data;data=NULL;if(global_returns_t_or_f()){data=(wchar_t *)malloc(100*sizeof(wchar_t));}else{data=(wchar_t *)malloc(100*sizeof(wchar_t));}if(global_returns_t_or_f()){free(data);}else{free(data);}}
static void main(){unsigned int data;data=0;data=5;b_main_sink(data);}void b_main_sink(unsigned int data){{unsigned int result=data * 2;printUnsignedLine(result);}}
static char * main_source(char * data){strcpy(data, "fixedstringtest");return data;}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);printf(data);}
static void main(){unsigned int data;data=0;data=b_main_source(data);{unsigned int result=data+1;printUnsignedLine(result);}}unsigned int b_main_source(unsigned int data){data=5;return data;}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));printWLine(data);}}
static void main(){int data;_struct_type my_struct;data=OPEN("BadSource_open.txt", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);CLOSE(data);my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;if (wcsncmp(PASSWORD, data, wcslen(data))==0) printLine("Access granted");else printLine("Access denied!");}
void _main_sink(wchar_t * data){{wchar_t src[100];_snwprintf(data, 100, L"%s", src);printWLine(data);}}static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;_main_sink(data);}
static void main_sink(wchar_t * data){if (wcsncmp(PASSWORD, data, wcslen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;main_sink(data);}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;data=NULL;{wchar_t * data=*data_ptr1;data=(wchar_t *)malloc(100*sizeof(wchar_t));free(data);}{wchar_t * data=*data_ptr2;}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(float data_array[]);static void main(){float data;float data_array[5];data=0.0F;data=7.0F;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(float data_array[]){float data=data_array[2];printDoubleLine((double)(100.0/data));}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=NULL;{char * data=*data_ptr1;{char data_goodbuf[100];data=data_goodbuf;strcpy(data, "A String");printLine(data);}}{char * data=*data_ptr2;}}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}my_union.a=data;{wchar_t * data=my_union.b;wprintf(L"%s\n", data);}}
static void main_sink(){char * data=_main_data;fprintf(stdout, data);}static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");_main_data=data;main_sink();}
static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");_wsystem(data);}
void b_main_sink(void * void_data_ptr);static void main(){char * data;data=NULL;data=(char *)malloc((10+1)*sizeof(char));b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{char data_src[10+1]=SRC_STRING;strncpy(data, data_src, strlen(data_src));printLine(data);free(data);}}
void b_main_sink(short data);static void main(){short data;data=-1;data=CHAR_MAX-5;b_main_sink(data);}void c_main_sink(short data);void b_main_sink(short data){c_main_sink(data);}void d_main_sink(short data);void c_main_sink(short data){d_main_sink(data);}void e_main_sink(short data);void d_main_sink(short data){e_main_sink(data);}void e_main_sink(short data){{char c=(char)data;printHexCharLine(c);}}
static void main_sink(){wchar_t * data=main_data;{wchar_t dest[50]=L"";_snwprintf(dest, wcslen(data), L"%s", data);printWLine(data);delete [] data;}}static void main(){wchar_t * data;data=new wchar_t[100];main_data=data;main_sink();}
static void main(){twoints * data;twoints * &data_ref=data;data=NULL;data=new twoints[100];{twoints * data=data_ref;delete [] data;}}
static void main(){int data;int &data_ref=data;data=-1;data=20;{int data=data_ref;{size_t a,i;int *b;b=(int*)new char[a];for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);delete [] b;}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink();static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{char src[100];strcat(data, src);printLine(data);}}
static void main(){long long * data;struct_type my_struct;data=NULL;data=new long long;my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){long long * data=my_struct.a;delete data;}
static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];wmemset(data, L'A', 100-1);data[100-1]=L'\0';main_sink(&data);}void main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;printWLine(data);}
static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, "%s", args);va_end(args);printLine(dest);}}static void main_sink(char * data){main_vasink(data, data);}static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}main_sink(data);}
static int main_source(int data){data=20;return data;}static void main(){int data;data=-1;data=main_source(data);{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}
static void main(){int data;data=-1;data=main_source(data);{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}int main_source(int data){data=RAND32();return data;}
void b_main_sink(long long * data);static void main(){long long * data;data=NULL;{long long tmp=5L;data=&tmp;}b_main_sink(data);}void b_main_sink(long long * data){printLongLongLine(*data);}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;strcat(data, "*.*");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){int data;data=-1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static void main(){int data;_union_type my_union;data=OPEN("GoodSource_open.txt", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);my_union.a=data;{int data=my_union.b;CLOSE(data);}}
static void main_sink(FILE * data){}static void main(){FILE * data;data=fopen("BadSource_fopen.txt", "w+");fclose(data);main_sink(data);}
static void main_sink(){wchar_t * data=_main_data;_wsystem(data);}static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");_main_data=data;main_sink();}
void b_main_sink(short data);static void main(){short data;data=-1;data=CHAR_MAX-5;b_main_sink(data);}void b_main_sink(short data){{char c=(char)data;printHexCharLine(c);}}
static void main(){int data;data=-1;data=b_main_source(data);{int result=data+1;printIntLine(result);}}int b_main_source(int data){data=5;return data;}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);main_vasink(data, data);}char * b_main_source(char * data){strcpy(data, "fixedstringtest");return data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, L"%s", data);printWLine(dest);}}
void b_main_sink();static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{size_t i, dest_sz;char dest[100];memset(dest, 'C', 100-1);dest_sz=strlen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);}}
static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=-1;data=INT_MAX;func_ptr(data);}void b_main_sink(int data){{int result=-1;if (data < INT_MAX){result=data+1;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];wmemset(data, L'A', 100-1);data[100-1]=L'\0';delete [] data;main_sink_b(data);}void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){}
static void main(){char * data;data=(char *)calloc(100, sizeof(char));{char * data_copy=data;char * data=data_copy;if (data!=NULL){strcpy(data, "Initialize");printLine(data);free(data);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, L"%s", data);printWLine(dest);}}
static void main(){int * data;data=NULL;data=new int;delete data;}
static void main(){int data;data=-1;data=5;b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{int result=data-1;printIntLine(result);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}{wchar_t * data_copy=data;wchar_t * data=data_copy;fwprintf(stdout, L"%s\n", data);}}
static void main(){wchar_t * data;data=NULL;{wchar_t data_goodbuf[100];data=data_goodbuf;wcscpy(data, L"A String");printWLine(data);}main_data=data;main_sink();}void main_sink(){wchar_t * data=main_data;}
static void main(){char * data;char * &data_ref=data;data=NULL;data=new char[100];{char * data=data_ref;delete [] data;}}
static void main(){{HANDLE hMutex=NULL;hMutex=CreateMutexW(NULL, FALSE, NULL);if (hMutex==NULL){exit(1);}if (GetLastError()==ERROR_ALREADY_EXISTS){exit(1);}CloseHandle(hMutex);}}
static void main_sink(int data){{int result=data * 2;printIntLine(result);}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=5;func_ptr(data);}
static void main(){unsigned char data;data=' ';data=(unsigned char)rand();b_main_sink(data);}void b_main_sink(unsigned char data){c_main_sink(data);}void c_main_sink(unsigned char data){{unsigned char result=-1;if (data <=(UCHAR_MAX/2)){result=data * 2;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static char * main_source(char * data){data=new char;delete data;return data;}static void main(){char * data;data=NULL;data=main_source(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "15");{int i, n, v;if (sscanf(data, "%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));printWLine(data);}}
static void main(){long long * data;data=NULL;data=new long long[100];main_sink_b(data);}void main_sink_b(long long * data){main_sink_c(data);}void main_sink_c(long long * data){main_sink_d(data);}void main_sink_d(long long * data){delete [] data;}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");b_main_sink(data);}void b_main_sink(char * data){{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
void b_main_sink(int * data);static void main(){int data;data=-1;data=CHAR_MAX-5;b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{char c=(char)data;printHexCharLine(c);}}
void b_main_sink(char * data);static void main(){char * data;data=NULL;data=(char *)malloc((10+1)*sizeof(char));b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{char data_src[10+1]=SRC_STRING;strncpy(data, data_src, strlen(data_src));printLine(data);free(data);}}
void main_sink_b(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_sink_b(data);}void main_sink_c(wchar_t * data);void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){{wchar_t src[100];wcsncpy(data, src, 100);printWLine(data);delete [] data;}}
static void main(){short data;short *data_ptr1=&data;short *data_ptr2=&data;data=0;{short data=*data_ptr1;data=100-1;}{short data=*data_ptr2;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;func_ptr(data);}void b_main_sink(wchar_t * data){{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}printWLine(data);}}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");main_vasink(data, data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t dest[50]=L"";wcsncpy(dest, data, wcslen(data));printWLine(data);}}
static twointsclass * main_source(twointsclass * data){data=new twointsclass;return data;}static void main(){twointsclass * data;data=NULL;data=main_source(data);delete data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;fprintf(stdout, "%s\n", data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(data);}void b_main_sink(wchar_t * data){wprintf(L"%s\n", data);}
static twoints * main_source(twoints * data){data=new twoints;return data;}static void main(){twoints * data;data=NULL;data=main_source(data);delete data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{wchar_t dest[50]=L"";memmove(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");_main_data=data;b_main_sink();}static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, data, args);va_end(args);printLine(dest);}}void b_main_sink(){char * data=_main_data;main_vasink(data, data);}
static void main(){long long * data;data=NULL;data=new long long[100];delete [] data;}
static void main(){int * data;data=NULL;data=new int;main_sink_b(data);}void main_sink_b(int * data){main_sink_c(data);}void main_sink_c(int * data){delete data;}
static wchar_t * main_source(wchar_t * data){wcscat(data, L"*.*");return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]="";data=data_buf;{char * data=*data_ptr1;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}}{char * data=*data_ptr2;if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}}
static void main(){double data;data=5.0;printDoubleLine(data);}
static void main(){twoints * data;data=NULL;if(global_returns_t_or_f()){data=new twoints[100];}else{data=new twoints[100];}if(global_returns_t_or_f()){delete [] data;}else{delete [] data;}}
static void main_sink(){char * data=_main_data;{char dest[50]="";size_t i, data_len;data_len=strlen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printLine(data);}}static void main(){char * data;char data_buf[100];data=data_buf;_main_data=data;main_sink();}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(_struct_type my_struct);static void main(){float data;_struct_type my_struct;data=0.0F;data=7.0F;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){float data=my_struct.a;printDoubleLine((double)(100.0/data));}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]="";data=data_buf;{char * data=*data_ptr1;strcpy(data, "fixedstringtest");}{char * data=*data_ptr2;main_vasink(data, data);}}
static void main_sink(){char * data=_main_data;{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]='\0';printLine(data);}}static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;_main_data=data;main_sink();}
static void main(){int data;data=-1;if(global_returns_t_or_f()){data=CHAR_MAX-5;}else{data=CHAR_MAX-5;}{char c=(char)data;printHexCharLine(c);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");func_ptr(data);}void b_main_sink(wchar_t * data){{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){int data;_union_type my_union;data=-1;data=5;my_union.a=data;{int data=my_union.b;{int result=data-1;printIntLine(result);}}}
static void main(){unsigned char data;data=' ';data=5;_main_data=data;b_main_sink();}void b_main_sink(){unsigned char data=_main_data;{unsigned char result=data * 2;printHexUnsignedCharLine(result);}}
static void main_source(wchar_t * &data){data=new wchar_t;}static void main(){wchar_t * data;data=NULL;main_source(data);delete data;}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;data=b_main_source(data);_wsystem(data);}wchar_t * b_main_source(wchar_t * data){wcscat(data, L"*.*");return data;}
static void main(){wchar_t * data;wchar_t * &data_ref=data;data=NULL;data=new wchar_t;delete data;{wchar_t * data=data_ref;}}
void b_main_sink(int * data);static void main(){int * data;data=(int *)malloc(100);b_main_sink(data);}void c_main_sink(int * data);void b_main_sink(int * data){c_main_sink(data);}void d_main_sink(int * data);void c_main_sink(int * data){d_main_sink(data);}void d_main_sink(int * data){if (data!=NULL){data[0]=5;printIntLine(data[0]);free(data);}}
static void main(){int data;int data_array[5];data=7;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main_sink(unsigned int data){{unsigned int result=0;if (data > 0){result=data-1;printUnsignedLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}static void main(){unsigned int data;void (*func_ptr) (unsigned int)=main_sink;data=0;data=(unsigned int)RAND32();func_ptr(data);}
void main_sink_b(twointsclass * data);static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];main_sink_b(data);}void main_sink_c(twointsclass * data);void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_d(twointsclass * data);void main_sink_c(twointsclass * data){main_sink_d(data);}void main_sink_d(twointsclass * data){{twointsclass src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memmove(data, src, 100*sizeof(twointsclass));printIntLine(data[0].a);delete [] data;}}
static void main(){twoints * data;{twoints * data_buf=(twoints *)malloc(100*sizeof(twoints));{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}printStructLine(&data[0]);free(data);}
static void main(){long long * data;long long * &data_ref=data;data=NULL;data=new long long;{long long * data=data_ref;delete data;}}
static void main(){long long * data;data=NULL;data=new long long;main_sink_b(data);}void main_sink_b(long long * data){main_sink_c(data);}void main_sink_c(long long * data){printLongLongLine(*data);}
static void main(){twointsclass * data;data=(twointsclass *)ALLOCA(10*sizeof(twointsclass));if(global_returns_t_or_f()){}else{}if(global_returns_t_or_f()){for(int i=0;i<10;i++){data[i].a=i;data[i].b=i;}for(int i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}else{for(int i=0;i<10;i++){data[i].a=i;data[i].b=i;}for(int i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));main_sink(&data);}void main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;free(data);}
static void main(){wchar_t * data;union_type my_union;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}my_union.a=data;{wchar_t * data=my_union.b;{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]=L'\0';printWLine(data);}}}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{wchar_t src[100];wcsncpy(data, src, 100);printWLine(data);}}
static void main(){float data;float *data_ptr1=&data;float *data_ptr2=&data;data=0.0F;{float data=*data_ptr1;data=7.0F;}{float data=*data_ptr2;printDoubleLine((double)(100.0/data));}}
static void main(){int data;data=-1;data=100-1;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;fscanf (stdin, "%d", &data);}{int data=*data_ptr2;{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char data_buf[100];data=data_buf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{char dest[50]="";memcpy(dest, data, strlen(data)*sizeof(char));printLine(data);}}
void b_main_sink(int data);static void main(){int data;data=-1;data=20;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void d_main_sink(int data);void c_main_sink(int data){d_main_sink(data);}void e_main_sink(int data);void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{size_t i;int *b;b=(int*)malloc(data * sizeof(int));for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);free(b);}}
static void main(){int data;data=-1;data=OPEN("BadSource_open.txt", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if(global_returns_t_or_f()){if (data!=-1){CLOSE(data);}}else{if (data!=-1){CLOSE(data);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main_sink(long long * data){free(data);}static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));main_sink(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));func_ptr(data);}void b_main_sink(wchar_t * data){{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));printWLine(data);free(data);}}
void _main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_main_sink(data);}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){int data;_union_type my_union;data=-1;data=5;my_union.a=data;{int data=my_union.b;{int result=data+1;printIntLine(result);}}}
static void main(){char * data;char * data_array[5];char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{char dest[100]="";SNPRINTF(dest, 100-1, data);printLine(dest);}}
static void main_sink(){bad_struct data=_main_data;* */prev=data.list.prev;next=data.list.next;prev->next=next;next->prev=prev;}static void main(){bad_struct data;linked_list head={&head, &head};data.list.next=head.next;data.list.prev=&head;head.next=&data.list;head.next->prev=&data.list;_main_data=data;main_sink();}
static void main_sink(float data){printDoubleLine((double)(100.0/data));}static void main(){float data;void (*func_ptr) (float)=main_sink;data=0.0F;data=7.0F;func_ptr(data);}
static void main(){twointsclass * data;twointsclass * data_array[5];data=NULL;data=new twointsclass;data_array[2]=data;main_sink(data_array);}void main_sink(twointsclass * data_array[]){twointsclass * data=data_array[2];delete data;}
static void main(){unsigned int data;void (*func_ptr) (unsigned int)=b_main_sink;data=0;data=5;func_ptr(data);}void b_main_sink(unsigned int data){{unsigned int result=data * data;printUnsignedLine(result);}}
static void main(){wchar_t * data;wchar_t * data_array[5];data=NULL;{wchar_t mystring[]=L"mystring";data=wcsdup(mystring);printWLine(data);}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];free(data);}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]="";data=data_buf;strcat(data, "*.*");func_ptr(data);}void b_main_sink(char * data){_spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){long long * data;data=NULL;data=main_source(data);free(data);}long long * main_source(long long * data){data=(long long *)malloc(100*sizeof(long long));return data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}wprintf(L"%s\n", data);}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;system(data);}
static void main(){wchar_t * data;_union_type my_union;data=(wchar_t *)realloc(data, 100);my_union.a=data;{wchar_t * data=my_union.b;if (data!=NULL){wcscpy(data, L"Initialize");printWLine(data);free(data);}}}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}static void main_sink(char * data){main_vasink(data, data);}static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");main_sink(data);}
void b_main_sink(short data);static void main(){short data;void (*func_ptr) (short)=b_main_sink;data=0;data=100-1;func_ptr(data);}void b_main_sink(short data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];{wchar_t src[100];wcsncat(data, src, 100);printWLine(data);delete [] data;}}
static void main_sink(){char * data=_main_data;{char src[100];strcat(data, src);printLine(data);}}static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;_main_data=data;main_sink();}
static void main_sink(){twoints * data=main_data;delete data;}static void main(){twoints * data;data=NULL;data=new twoints;main_data=data;main_sink();}
static void main(){unsigned char data;data=' ';data=UCHAR_MAX;{unsigned char result=-1;if (data < UCHAR_MAX){result=data+1;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));main_sink_b(data);}void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){main_sink_d(data);}void main_sink_d(char * data){main_sink_e(data);}void main_sink_e(char * data){free(data);}
static void main(){int * data;data=NULL;data=new int[100];main_sink(data);}void main_sink(int * data){delete [] data;}
static void main(){int data;data=-1;data=5;{int data_copy=data;int data=data_copy;{int result=data+1;printIntLine(result);}}}
static void main_sink(char * data){if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;main_sink(data);}
static void main_sink(twoints * data){delete [] data;}static void main(){twoints * data;void (*func_ptr) (twoints *)=main_sink;data=NULL;data=new twoints[100];func_ptr(data);}
static void main(){int data;data=-1;data=20;{size_t a,i;int *b;b=(int*)new char[a];for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);delete [] b;}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=NULL;{char * data=*data_ptr1;data=new char[100];}{char * data=*data_ptr2;{size_t i, dest_sz;char dest[100];memset(dest, 'C', 100-1);dest_sz=strlen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);delete [] data;}}}
static void main(){int * data;data=(int *)malloc(10*sizeof(int));if(global_returns_t_or_f()){{int i;for(i=0;i<10;i++){data[i]=i;}}}else{{int i;for(i=0;i<10;i++){data[i]=i;}}}if(global_returns_t_or_f()){{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}}else{{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}}}
static void main(){char * data;data=NULL;data=(char *)calloc(100, sizeof(char));strcpy(data, "A String");printLine(data);b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){free(data);}
void main_sink_b(int * data);static void main(){int * data;{int * data_buf=new int[100];{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}main_sink_b(data);}void main_sink_c(int * data);void main_sink_b(int * data){main_sink_c(data);}void main_sink_c(int * data){printIntLine(data[0]);delete [] data;}
static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));{twoints * data_copy=data;twoints * data=data_copy;{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memcpy(data, src, 100*sizeof(twoints));printStructLine(&data[0]);free(data);}}}
static void main_sink(){wchar_t * data=_main_data;_wsystem(data);}static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");_main_data=data;main_sink();}
static void main(){int * data;data=NULL;data=new int[100];main_sink(&data);}void main_sink(void * void_data_ptr){int * * data_ptr=(int * *)void_data_ptr;int * data=(*data_ptr);delete [] data;}
void _main_sink(long long * data){printLongLongLine(data[0]);free(data);}static void main(){long long * data;{long long * data_buf=(long long *)malloc(100*sizeof(long long));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5L;}}data=data_buf;}_main_sink(data);}
static void main_sink(int * data){delete [] data;}static void main(){int * data;data=NULL;data=new int[100];main_sink(data);}
static void main(){int data;_union_type my_union;data=-1;data=100-1;my_union.a=data;{int data=my_union.b;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}}
static void main_sink(int data){{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}static void main(){int data;data=-1;data=RAND32();main_sink(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);if (wcsstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}wchar_t * b_main_source(wchar_t * data){data=PASSWORD;return data;}
static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;data=PASSWORD;my_union.a=data;{char * data=my_union.b;if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}}
static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;{char dest[100];memmove(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
static void main(){twoints * data;data=NULL;main_source(data);delete data;}void main_source(twoints * &data){data=new twoints;data->a=0;data->b=0;printStructLine(data);}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char data_buf[100]="";data=data_buf;strcat(data, "*.*");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]="";data=data_buf;strcat(data, "*.*");func_ptr(data);}void b_main_sink(char * data){_spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
void _main_sink(char * data){{FILE *pipe;pipe=POPEN(data, "wb");if (pipe!=NULL) PCLOSE(pipe);}}static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");_main_sink(data);}
static void main(){int data;data=-1;data=RAND32();{int data_copy=data;int data=data_copy;{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than the length of the source string or too large");}}}}
static void main(){FILE * data;_union_type my_union;data=NULL;data=fopen("BadSource_fopen.txt", "w+");my_union.a=data;{FILE * data=my_union.b;if (data!=NULL){fclose(data);}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(&data);}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);main_vasink(data, data);}
static void main_source(char * &data){}static void main(){char * data;data=new char[100];main_source(data);{char dest[50]="";strcat(dest, data);printLine(data);delete [] data;}}
static char * main_source(char * data){data=(char *)malloc((10+1)*sizeof(char));return data;}static void main(){char * data;data=NULL;data=main_source(data);{char data_src[10+1]=SRC_STRING;size_t i, src_len;src_len=strlen(data_src);for (i=0;i < src_len;i++){data[i]=data_src[i];}printLine(data);free(data);}}
static void main(){int data;if(global_returns_t_or_f()){data=7;}else{data=7;}if(global_returns_t_or_f()){{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}else{{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}}
static void main_sink(wchar_t * data){if (data!=NULL){wcscpy(data, L"Initialize");printWLine(data);free(data);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=(wchar_t *)malloc(100);func_ptr(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;func_ptr(data);}void b_main_sink(wchar_t * data){{wchar_t dest[50]=L"";_snwprintf(dest, wcslen(data), L"%s", data);printWLine(data);}}
static void main(){int data;data=-1;data=INT_MIN;_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static void main(){twointsclass * data;union_type my_union;data=NULL;data=new twointsclass[100];delete [] data;my_union.a=data;{twointsclass * data=my_union.b;}}
static void main(){char * data;char * data_array[5];char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];printf(data);}
static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}my_union.a=data;{char * data=my_union.b;{char dest[100]="";SNPRINTF(dest, 100-1, "%s", data);printLine(dest);}}}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[100];data=data_buf;b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char dest[50]="";strncpy(dest, data, strlen(data));printLine(data);}}
static void main(){int data;data=-1;data=10000;main_sink_b(data);}void main_sink_b(int data){main_sink_c(data);}void main_sink_c(int data){main_sink_d(data);}void main_sink_d(int data){{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main_sink(char * data){free(data);}static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;data=(char *)calloc(100, sizeof(char));strcpy(data, "A String");printLine(data);func_ptr(data);}
static void main(){int data;_union_type my_union;data=7;my_union.a=data;{int data=my_union.b;{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}}
static void main(){int data;data=7;{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main_sink(){int data=_main_data;{size_t i;int *b;b=(int*)malloc(data * sizeof(int));for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);free(b);}}static void main(){int data;data=-1;data=20;_main_data=data;main_sink();}
static struct _twoints * main_source(struct _twoints * data){data=NULL;data=(struct _twoints *)realloc(data, 100*sizeof(struct _twoints));data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);return data;}static void main(){struct _twoints * data;data=NULL;data=main_source(data);free(data);}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=100-1;}{int data=*data_ptr2;{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}}
static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;{wchar_t dest[50]=L"";memcpy(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);}}
void _main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}static void main(){int data;data=-1;data=100-1;_main_sink(data);}
static void main(){void * data;data=NULL;data=WIDE_STRING;_main_data=data;b_main_sink();}void b_main_sink(){void * data=_main_data;{size_t data_len=wcslen((wchar_t *)data);void * data_dest=(void *)calloc(data_len+1, sizeof(wchar_t));memcpy(data_dest, data, (data_len+1)*sizeof(wchar_t));printWLine((wchar_t *)data_dest);free(data_dest);}}
static void main(){double * data;data=(double *)ALLOCA(10*sizeof(double));if(global_returns_t_or_f()){}else{}if(global_returns_t_or_f()){{int i;for(i=0;i<10;i++){data[i]=(double)i;}}{int i;for(i=0;i<10;i++){printDoubleLine(data[i]);}}}else{{int i;for(i=0;i<10;i++){data[i]=(double)i;}}{int i;for(i=0;i<10;i++){printDoubleLine(data[i]);}}}}
static void main(){int * data;data=NULL;data=new int[100];main_sink(&data);}void main_sink(int * * data_ptr){int * data=*data_ptr;delete [] data;}
void main_sink_b(wchar_t * data);static void main(){wchar_t * data;data=new wchar_t[100];main_sink_b(data);}void main_sink_c(wchar_t * data);void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){{wchar_t dest[50]=L"";_snwprintf(dest, wcslen(data), L"%s", data);printWLine(data);delete [] data;}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';{char * data=*data_ptr1;data=data_buf;}{char * data=*data_ptr2;{char dest[100];strcpy(dest, data);printLine(dest);}}}
static void main(){wchar_t * data;struct_type my_struct;data=NULL;data=new wchar_t[100];wmemset(data, L'A', 100-1);data[100-1]=L'\0';delete [] data;my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){wchar_t * data=my_struct.a;}
void main_sink(wchar_t * * data);static void main(){wchar_t * data;data=new wchar_t[100];main_sink(&data);}void main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{wchar_t dest[50]=L"";wcsncpy(dest, data, wcslen(data));printWLine(data);delete [] data;}}
void _main_sink(wchar_t * data){{wchar_t dest[50]=L"";wcsncpy(dest, data, wcslen(data));printWLine(data);free(data);}}static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));_main_sink(data);}
static void main(){int data;data=-1;data=100-1;{int data_copy=data;int data=data_copy;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}}
static void main(){unsigned int data;_union_type my_union;data=0;data=0;my_union.a=data;{unsigned int data=my_union.b;{unsigned int result=0;if (data > 0){result=data-1;printUnsignedLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}}
static void main_sink(){wchar_t * data=_main_data;if (wcsncmp(PASSWORD, data, wcslen(data))==0) printLine("Access granted");else printLine("Access denied!");}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;_main_data=data;main_sink();}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");{char * data_copy=data;char * data=data_copy;main_vasink(data, data);}}
static void main(){int data;data=-1;if(global_returns_t_or_f()){data=CHAR_MAX-5;}else{data=CHAR_MAX-5;}{short s=(short)data;printf("%hd\n", s);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){twoints * data;data=new twoints[10];main_sink(&data);}void main_sink(twoints * * data_ptr){twoints * data=*data_ptr;{int i;for(i=0;i<10;i++){data[i].a=i;data[i].b=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}delete [] data;}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{int result=-1;if (data < INT_MAX){result=data+1;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main_sink(twoints * data){free(data);}static void main(){twoints * data;void (*func_ptr) (twoints *)=main_sink;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));data[0].a=0;data[0].b=0;printStructLine(&data[0]);func_ptr(data);}
static void main_sink(FILE * data){if (data!=NULL){fclose(data);}}static void main(){FILE * data;data=NULL;data=freopen("BadSource_freopen.txt","w+",stdin);main_sink(data);}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(L"%s", args);va_end(args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);main_vasink(data, data);}wchar_t * b_main_source(wchar_t * data){{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}return data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");func_ptr(data);}void b_main_sink(wchar_t * data){{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;if (strncmp(PASSWORD, data, strlen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){wchar_t * data;data=NULL;main_source(data);delete [] data;}void main_source(wchar_t * &data){data=new wchar_t[100];}
void main_sink(void * void_data_ptr);static void main(){int data;data=-1;data=20;main_sink(&data);}void main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);{size_t a,i;int *b;b=(int*)new char[a];for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);delete [] b;}}
void main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}func_ptr(data);}void main_sink(char * data){{char src[100];strcpy(data, src);printLine(data);}}
static void main_sink(){wchar_t * data=main_data;{wchar_t dest[100];wmemset(dest, L'C', 100-1);memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);delete [] data;}}static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_data=data;main_sink();}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{wchar_t src[100];wcscpy(data, src);printWLine(data);}}
static void main(){long long * data;_union_type my_union;data=NULL;data=(long long *)calloc(100, sizeof(long long));data[0]=5L;printLongLongLine(data[0]);my_union.a=data;{long long * data=my_union.b;free(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main_sink(twoints * data){delete [] data;}static void main(){twoints * data;void (*func_ptr) (twoints *)=main_sink;data=NULL;data=new twoints[100];func_ptr(data);}
static void main(){int data;data=-1;data=ASSERT_VALUE+1;{int data_copy=data;int data=data_copy;assert(data > ASSERT_VALUE);}}
static void main(){int data;data=-1;data=20;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){{char * char_string;if (data > 0){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than 0");}}}
static void main(){twoints * data;union_type my_union;data=NULL;data=NULL;data=(twoints *)realloc(data, 100*sizeof(twoints));my_union.a=data;{twoints * data=my_union.b;free(data);}}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;free(data);}
static void main(){twoints * data;struct_type my_struct;data=NULL;data=new twoints[100];{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}delete [] data;my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){twoints * data=my_struct.a;}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;func_ptr(data);}void b_main_sink(char * data){{char src[100];strcat(data, src);printLine(data);}}
static void main(){short data;data=0;data=100-1;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main(){int data;data=-1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}main_sink(data);}void main_sink(int data){{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main_sink(twoints * data){printStructLine(data);}static void main(){twoints * data;data=NULL;data=new twoints;data->a=1;data->b=2;main_sink(data);}
static void main(){char data;char *data_ptr1=&data;char *data_ptr2=&data;data=' ';{char data=*data_ptr1;data='a';}{char data=*data_ptr2;{char char_array[4];char_array[0]='x';char_array[1]=data;char_array[2]='z';char_array[3]='\0';printLine(char_array);}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;fprintf(stdout, "%s\n", data);}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;_wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main_sink(char data){{char result=-1;if (data <=(char)sqrt((char)CHAR_MAX)){result=data * data;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}static void main(){char data;data=' ';data=CHAR_MAX;main_sink(data);}
static void main(){int data;data=-1;data=20;{char * char_string;if (data > 0){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than 0");}}}
static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}void b_main_sink(int data){{int result=-1;if (data <=(int)sqrt((int)INT_MAX)){result=data * data;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main_sink(long long * data){}static void main(){long long * data;data=NULL;long long data_good;data=&data_good;printLongLongLine(*data);main_sink(data);}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100];data=data_buf;{char * data=*data_ptr1;}{char * data=*data_ptr2;{size_t src_len;char src[100];src_len=strlen(src);strncat(data, src, src_len);printLine(data);}}}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];data=(wchar_t *)malloc(100*sizeof(wchar_t));data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t dest[50]=L"";wcsncat(dest, data, wcslen(data));printWLine(data);free(data);}}
static void main(){wchar_t * data;_union_type my_union;data=(wchar_t *)malloc(100*sizeof(wchar_t));my_union.a=data;{wchar_t * data=my_union.b;{wchar_t dest[50]=L"";wcscpy(dest, data);printWLine(data);free(data);}}}
static void main_sink(int data){{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;data->a=0;data->b=0;printIntLine(data->a);printIntLine(data->b);{twointsclass * data_copy=data;twointsclass * data=data_copy;delete data;}}
static void main(){twoints * data;data=NULL;data=main_source(data);free(data);}twoints * main_source(twoints * data){data=(twoints *)malloc(100*sizeof(twoints));return data;}
void b_main_sink(int * data);static void main(){int data;data=-1;data=100-1;b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, "%s", args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}main_vasink(data, data);}
static void main(){wchar_t * data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;{wchar_t src[100];wcsncpy(data, src, 100);data[100-1]=L'\0';printWLine(data);}}
static void main_sink(){char * data=_main_data;if (strstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;_main_data=data;main_sink();}
static void main(){int data;data=-1;data=b_main_source(data);{int result=data+1;printIntLine(result);}}int b_main_source(int data){data=5;return data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[250]=L"PATH=";data=data_buf;wcscat(data, NEW_PATH);b_main_sink(data);}void b_main_sink(wchar_t * data){PUTENV(data);}
static void main_sink(int * data){free(data);}static void main(){int * data;void (*func_ptr) (int *)=main_sink;data=NULL;data=NULL;data=(int *)realloc(data, 100*sizeof(int));func_ptr(data);}
void b_main_sink(int * data);static void main(){int * data;{int * data_buf=(int *)malloc(100*sizeof(int));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}b_main_sink(data);}void c_main_sink(int * data);void b_main_sink(int * data){c_main_sink(data);}void d_main_sink(int * data);void c_main_sink(int * data){d_main_sink(data);}void e_main_sink(int * data);void d_main_sink(int * data){e_main_sink(data);}void e_main_sink(int * data){printIntLine(data[0]);free(data);}
static void main(){char * password;char * *password_ptr1=&password;char * *password_ptr2=&password;password="";{char * password=*password_ptr1;password=(char *)malloc(100*sizeof(char));if(!VirtualLock(password, 100*sizeof(char))){printLine("Memory could not be locked");exit(1);}strcpy(password, "Password1234!");}{char * password=*password_ptr2;{HANDLE pHandle;char * username="User";char * domain="Domain";if (LogonUserA( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}}
static void main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnvp(_P_WAIT, COMMAND_INT, args);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;strcat(data, "*.*");func_ptr(data);}
static void main_sink(short data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}static void main(){short data;void (*func_ptr) (short)=main_sink;data=0;data=100-1;func_ptr(data);}
void main_sink();static void main(){wchar_t * data;{wchar_t * data_buf=new wchar_t[100];data=data_buf;}_main_data=data;main_sink();}void main_sink(){wchar_t * data=_main_data;printWLine(data);delete [] data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, data);printWLine(dest);}}
static void main(){twoints * data;struct_type my_struct;data=NULL;data=new twoints[100];my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){twoints * data=my_struct.a;delete [] data;}
static void main(){int * data;data=NULL;data=new int[100];main_sink_b(data);}void main_sink_b(int * data){main_sink_c(data);}void main_sink_c(int * data){main_sink_d(data);}void main_sink_d(int * data){delete [] data;}
static void main(){{int i=rand();if(i==5){printLine("i was 5");}}}
static void main(){double * data;data=new double[10];{int i;for(i=0;i<10;i++){data[i]=(double)i;}}{int i;for(i=0;i<10;i++){printDoubleLine(data[i]);}}delete [] data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf("%s", args);va_end(args);}}void b_main_sink(char * data){main_vasink(data, data);}
static void main_source(twointsclass * &data){for(int i=0;i<10;i++){data[i].a=i;data[i].b=i;}}static void main(){twointsclass * data;twointsclass data_uninit_array[10];data=data_uninit_array;main_source(data);for(int i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}
void b_main_sink(char * * data);static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char src[100];strcat(data, src);printLine(data);}}
static void main_sink(){int count=_main_data;{size_t i=0;FILE *file=NULL;const char *filename="output_bad.txt";file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}static void main(){int count;count=-1;count=20;_main_data=count;main_sink();}
void main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}func_ptr(data);}void main_sink(wchar_t * data){{wchar_t src[100];wcsncpy(data, src, 100);data[100-1]=L'\0';printWLine(data);}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=5;}{int data=*data_ptr2;{int result=data+1;printIntLine(result);}}}
static void main(){unsigned char data;data=' ';data=5;_main_data=data;b_main_sink();}void b_main_sink(){unsigned char data=_main_data;{unsigned char result=data-1;printHexUnsignedCharLine(result);}}
static void main_sink(char * data){printf("%s\n", data);}static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}main_sink(data);}
static void main(){long long * data;data=NULL;{long long data_goodbuf[100];data=data_goodbuf;data[0]=5L;printLongLongLine(data[0]);}{long long * data_copy=data;long long * data=data_copy;}}
static void main(){int * data;data=NULL;int data_good;data=&data_good;printIntLine(*data);main_sink(&data);}void main_sink(void * void_data_ptr){int * * data_ptr=(int * *)void_data_ptr;int * data=(*data_ptr);}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;data=NULL;{wchar_t * data=*data_ptr1;data=new wchar_t[100];}{wchar_t * data=*data_ptr2;{wchar_t src[100];wcscpy(data, src);printWLine(data);delete [] data;}}}
static void main(){int data;data=-1;data=5;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{int result=data * 2;printIntLine(result);}}
static void main(){char * data;_union_type my_union;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;my_union.a=data;{char * data=my_union.b;{char src[100];memmove(data, src, 100*sizeof(char));printLine(data);}}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];wcscpy(data, L"A String");printWLine(data);main_sink_b(data);}void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_d(wchar_t * data){delete[] data;}
static void main(){twoints * data;void (*func_ptr) (twoints *)=main_sink;data=NULL;data=new twoints;func_ptr(data);}void main_sink(twoints * data){delete data;}
static void main_sink(wchar_t * data){if (wcsstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;main_sink(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){twointsclass * data;data=NULL;{twointsclass data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printIntLine(data[0].a);printIntLine(data[0].b);}{twointsclass * data_copy=data;twointsclass * data=data_copy;}}
void b_main_sink(char * * data);static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char dest[50]="";memcpy(dest, data, strlen(data)*sizeof(char));printLine(data);}}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;func_ptr(data);}void b_main_sink(char * data){{char dest[100];strncpy(dest, data, strlen(dest));dest[100-1]='\0';printLine(dest);}}
static void main(){char * data;data=(char *)calloc(100, sizeof(char));if(global_returns_t_or_f()){if (data!=NULL){strcpy(data, "Initialize");printLine(data);free(data);}}else{if (data!=NULL){strcpy(data, "Initialize");printLine(data);free(data);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, L"%s", args);va_end(args);printWLine(dest);}}void d_main_sink(wchar_t * data){main_vasink(data, data);}
static void main_sink(){wchar_t * data=_main_data;{wchar_t dest[100];wmemset(dest, L'C', 100-1);memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;_main_data=data;main_sink();}
void b_main_sink(char * * data);static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char src[100];strcat(data, src);printLine(data);free(data);}}
static void main_sink(wchar_t * data){{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");func_ptr(data);}
static void main(){{if (RpcImpersonateClient(0)!=RPC_S_OK){exit(1);}}}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];main_sink(&data);}void main_sink(void * void_data_ptr){twointsclass * * data_ptr=(twointsclass * *)void_data_ptr;twointsclass * data=(*data_ptr);delete [] data;}
static void main(){int data;data=-1;data=100-1;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
static char * main_source(char * data){{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}return data;}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);printf("%s\n", data);}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[FILENAME_MAX]="";data=data_buf;{char * data=*data_ptr1;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");}{char * data=*data_ptr2;{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
static void main(){twoints * data;data=NULL;data=new twoints[100];data[0].a=0;data[0].b=0;printStructLine(&data[0]);delete[] data;}
static void main(){wchar_t * data;data=NULL;if(global_returns_t_or_f()){{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}}else{{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}}{wchar_t dest[100];memmove(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){unsigned int data;data=0;fscanf (stdin, "%u", &data);{unsigned int result=-1;if (data <=(unsigned int)sqrt((unsigned int)UINT_MAX)){result=data * data;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){int * data;data=NULL;data=new int[100];{size_t i;for(i=0;i < 100;i++){data[i]=5;}}delete [] data;}
static void main_sink(int * data){if (data!=NULL){data[0]=5;printIntLine(data[0]);free(data);}}static void main(){int * data;data=(int *)calloc(100, sizeof(int));main_sink(data);}
static void main_sink(){long long * data=main_data;delete data;}static void main(){long long * data;data=NULL;data=new long long;main_data=data;main_sink();}
static wchar_t * main_source(wchar_t * data){wcscpy(data, L"fixedstringtest");return data;}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(data, args);va_end(args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);main_vasink(data, data);}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, GOOD_OS_COMMAND);b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;system(data);}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}wchar_t * b_main_source(wchar_t * data){wcscat(data, L"*.*");return data;}
static void main(){long long * data;data=NULL;main_source(data);free(data);}void main_source(long long * &data){data=NULL;data=(long long *)realloc(data, 100*sizeof(long long));}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;data->a=0;data->b=0;printIntLine(data->a);printIntLine(data->b);main_sink_b(data);}void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_c(twointsclass * data){main_sink_d(data);}void main_sink_d(twointsclass * data){delete data;}
static void main_sink(int data){{int result=data+1;printIntLine(result);}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=5;func_ptr(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main_sink(){char * data=_main_data;if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}_main_data=data;main_sink();}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}
static void main(){unsigned int data;data=0;fscanf (stdin, "%u", &data);b_main_sink(data);}void b_main_sink(unsigned int data){c_main_sink(data);}void c_main_sink(unsigned int data){d_main_sink(data);}void d_main_sink(unsigned int data){{unsigned int result=-1;if (data <=(UINT_MAX/2)){result=data * 2;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){int data;data=-1;data=b_main_source(data);{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}int b_main_source(int data){data=INT_MIN;return data;}
static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}my_union.a=data;{char * data=my_union.b;{char dest[100]="";SNPRINTF(dest, 100-1, "%s", data);printLine(dest);}}}
static void main(){long long * data;long long * data_array[5];data=NULL;data=new long long[100];data_array[2]=data;main_sink(data_array);}void main_sink(long long * data_array[]){long long * data=data_array[2];delete [] data;}
void b_main_sink(char * data);static void main(){char * data;{char * data_buf=(char *)malloc(100*sizeof(char));data=data_buf;}b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){printLine(data);free(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnvp(_P_WAIT, COMMAND_INT, args);}}
static void main(){char * data;data=NULL;data=NULL;data=(char *)realloc(data, 100*sizeof(char));{char * data_copy=data;char * data=data_copy;free(data);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t data_src[10+1]=SRC_STRING;memmove(data, data_src, wcslen(data_src)*sizeof(wchar_t));printWLine(data);free(data);}}
static void main(){int count;count=-1;fscanf (stdin, "%d", &count);b_main_sink(count);}void b_main_sink(int count){c_main_sink(count);}void c_main_sink(int count){d_main_sink(count);}void d_main_sink(int count){e_main_sink(count);}void e_main_sink(int count){{size_t i=0;if (count > 0 && count <=20){for (i=0;i < (size_t)count;i++){printLine("Hello");}}}}
void b_main_sink(char * * data);static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char src[100];memmove(data, src, 100*sizeof(char));printLine(data);free(data);}}
char * main_source(char * data);static void main(){char * data;data=new char[100];data=main_source(data);{char dest[50]="";_snprintf(dest, strlen(data), "%s", data);printLine(data);delete [] data;}}char * main_source(char * data){return data;}
static void main_sink(){char * data=_main_data;{size_t i, dest_sz;char dest[100];memset(dest, 'C', 100-1);dest_sz=strlen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);free(data);}}static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));_main_data=data;main_sink();}
static void main_sink(int data){{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=20;func_ptr(data);}
static void main(){int * data;int * data_array[5];data=NULL;data=new int[100];data_array[2]=data;main_sink(data_array);}void main_sink(int * data_array[]){int * data=data_array[2];delete [] data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");_main_data=data;b_main_sink();}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(data, args);va_end(args);}}void b_main_sink(){wchar_t * data=_main_data;main_vasink(data, data);}
static void main(){char * data;union_type my_union;data=NULL;data=new char[100];my_union.a=data;{char * data=my_union.b;{char src[100];memcpy(data, src, 100*sizeof(char));printLine(data);delete [] data;}}}
static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];fwprintf(stdout, data);}
static twoints * main_source(twoints * data){data=(twoints *)malloc(100*sizeof(twoints));return data;}static void main(){twoints * data;data=NULL;data=main_source(data);free(data);}
void b_main_sink(int data);static void main(){int data;data=-1;data=100-1;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void d_main_sink(int data);void c_main_sink(int data){d_main_sink(data);}void e_main_sink(int data);void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));data=data_buf;}b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){printWLine(data);free(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){fwprintf(stdout, L"%s\n", data);}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];system(data);}
static void main(){int * data;data=NULL;main_source(data);delete data;}void main_source(int * &data){data=new int;}
static void main(){int data;data=-1;data=20;{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}
static void main(){if(global_returns_t_or_f()){{char * filename;char * template="fnXXXXXX";int fd;filename=mktemp(template);printLine(filename);fd=OPEN(filename, O_CREAT|O_EXCL, S_IREAD|S_IWRITE);if (fd!=-1){printLine("Temporary file was opened...now closing file");CLOSE(fd);}}}else{{char * filename;char * template="fnXXXXXX";int fd;filename=mktemp(template);printLine(filename);fd=OPEN(filename, O_CREAT|O_EXCL, S_IREAD|S_IWRITE);if (fd!=-1){printLine("Temporary file was opened...now closing file");CLOSE(fd);}}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");{wchar_t * data_copy=data;wchar_t * data=data_copy;EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}}
static void main(){char * data;char * data_array[5];data=NULL;data=(char *)malloc(100*sizeof(char));data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];free(data);}
static void main(){int data;data=-1;if(global_returns_t_or_f()){data=100-1;}else{data=100-1;}{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
static void main(){int data;_union_type my_union;data=-1;fscanf (stdin, "%d", &data);my_union.a=data;{int data=my_union.b;{int result=-1;if (data <=(int)sqrt((int)INT_MAX)){result=data * data;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
static int main_source(int data){data=20;return data;}static void main(){int data;data=-1;data=main_source(data);{size_t a,i;int *b;b=(int*)new char[a];for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);delete [] b;}}
static void main_sink(int data){{char * char_string;if (data > 0){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than 0");}}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=20;func_ptr(data);}
static void main(){int * data;void (*func_ptr) (int *)=main_sink;data=NULL;data=new int[100];func_ptr(data);}void main_sink(int * data){delete [] data;}
static void main(){int data;data=-1;data=100-1;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
void main_sink(int * data);static void main(){int data;data=-1;data=20;main_sink(&data);}void main_sink(int * data_ptr){int data=*data_ptr;{size_t a,i;int *b;b=(int*)new char[a];for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);delete [] b;}}
static void main_source(twoints * &data){data=new twoints;}static void main(){twoints * data;data=NULL;main_source(data);delete data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){fprintf(stdout, "%s\n", data);}
static void main(){twointsclass * data;data=NULL;data=(twointsclass *)calloc(100, sizeof(twointsclass));{twointsclass * data_copy=data;twointsclass * data=data_copy;free(data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(L"%s", args);va_end(args);}}static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}}{wchar_t * data=*data_ptr2;main_vasink(data, data);}}
void _main_sink(char * data){{char dest[100];memmove(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;_main_sink(data);}
char * b_main_source(char * data);static void main(){char * data;data=(char *)malloc(100*sizeof(char));data[0]='\0';data=b_main_source(data);{size_t i;for (i=0;i < strlen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}char * b_main_source(char * data){{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}return data;}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);_wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
void b_main_sink(FILE * * data);static void main(){FILE * data;data=NULL;data=fopen("file.txt", "w+");b_main_sink(&data);}void b_main_sink(FILE * * data_ptr){FILE * data=*data_ptr;if (data!=NULL){fclose(data);}}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){wchar_t * data;data=new wchar_t[100];{wchar_t dest[50]=L"";wcscpy(dest, data);printWLine(data);delete [] data;}}
static void main(){twoints * data;data=NULL;data=new twoints;main_data=data;main_sink();}void main_sink(){twoints * data=main_data;delete data;}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");my_union.a=data;{wchar_t * data=my_union.b;{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}}
static wchar_t * main_source(wchar_t * data){wcscat(data, L"*.*");return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);_wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){if(global_returns_t_or_f()){{char filename[100]="";int fd=-1;fgets(filename, 100, stdin);fd=OPEN(filename, O_CREAT | O_RDWR, S_IREAD|S_IWRITE);if (fd==-1) exit(1);if (WRITE(fd, "Good Sink...", 25)==-1) exit(1);if (fd!=-1) CLOSE(fd);}}else{{char filename[100]="";int fd=-1;fgets(filename, 100, stdin);fd=OPEN(filename, O_CREAT | O_RDWR, S_IREAD|S_IWRITE);if (fd==-1) exit(1);if (WRITE(fd, "Good Sink...", 25)==-1) exit(1);if (fd!=-1) CLOSE(fd);}}}
void b_main_sink(int * data);static void main(){int data;data=-1;data=100-1;b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
static void main_sink(){wchar_t * data=_main_data;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnvp(_P_WAIT, COMMAND_INT, args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_data=data;main_sink();}
static void main(){int * data;data=NULL;data=main_source(data);delete data;}int * main_source(int * data){data=new int;return data;}
static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));main_sink_b(data);}void main_sink_b(twoints * data){main_sink_c(data);}void main_sink_c(twoints * data){main_sink_d(data);}void main_sink_d(twoints * data){free(data);}
static void main(){{errno_t err_code=-1;double d=(double)sqrt((double)-1);if (_get_errno(&err_code)){printLine("_get_errno failed");exit(1);}if (err_code==EDOM){printLine("sqrt() failed");exit(1);}printDoubleLine(d);}}
char * main_source(char * data);static void main(){char * data;data=main_source(data);printLine(data);delete [] data;}char * main_source(char * data){{char * data_buf=new char[100];data=data_buf;}return data;}
void main_sink_b(char * data);static void main(){char * data;data=new char[100];main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){{char dest[50]="";memmove(dest, data, strlen(data)*sizeof(char));printLine(data);delete [] data;}}
static void main(){wchar_t * data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';if(global_returns_t_or_f()){data=data_buf;}else{data=data_buf;}{wchar_t dest[100];memcpy(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");{char * data_copy=data;char * data=data_copy;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}}
static void main(){char * data;_union_type my_union;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}my_union.a=data;{char * data=my_union.b;{char src[100];strcpy(data, src);printLine(data);}}}
static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];fwprintf(stdout, data);}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{wchar_t dest[50]=L"";_snwprintf(dest, wcslen(data), L"%s", data);printWLine(data);}}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){FILE * data;_struct_type my_struct;data=freopen("BadSource_freopen.txt","w+",stdin);fclose(data);my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){FILE * data=my_struct.a;}
static void main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}
static long long * main_source(long long * data){data=new long long[100];return data;}static void main(){long long * data;data=NULL;data=main_source(data);delete [] data;}
void _main_sink(char * data){EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_main_sink(data);}
static void main(){char * data;void (*func_ptr) (char *, ...)=b_main_vasink;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");func_ptr(data);}void b_main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}
static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}void b_main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static wchar_t * main_source(wchar_t * data){wcscat(data, L"*.*");return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
void b_main_sink(twoints * * data);static void main(){twoints * data;{twoints * data_buf=(twoints *)malloc(100*sizeof(twoints));{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}b_main_sink(&data);}void b_main_sink(twoints * * data_ptr){twoints * data=*data_ptr;printStructLine(&data[0]);free(data);}
void b_main_sink(twoints * data);static void main(){twoints * data;twoints * data_badbuf=(twoints *)ALLOCA(50*sizeof(twoints));twoints * data_goodbuf=(twoints *)ALLOCA(100*sizeof(twoints));data=data_goodbuf;b_main_sink(data);}void c_main_sink(twoints * data);void b_main_sink(twoints * data){c_main_sink(data);}void d_main_sink(twoints * data);void c_main_sink(twoints * data){d_main_sink(data);}void e_main_sink(twoints * data);void d_main_sink(twoints * data){e_main_sink(data);}void e_main_sink(twoints * data){{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memcpy(data, src, 100*sizeof(twoints));printStructLine(&data[0]);}}
static void main_sink(){char * data=_main_data;{size_t i;for (i=0;i < strlen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}static void main(){char * data;data=(char *)malloc(100*sizeof(char));data[0]='\0';{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}_main_data=data;main_sink();}
static void main(){long long * data;data=NULL;data=new long long;main_sink(&data);}void main_sink(long long * * data_ptr){long long * data=*data_ptr;delete data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(data);}void b_main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[250]=L"PATH=";data=data_buf;wcscat(data, NEW_PATH);func_ptr(data);}void b_main_sink(wchar_t * data){PUTENV(data);}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];data=(wchar_t *)malloc(100*sizeof(wchar_t));data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t dest[50]=L"";wcscat(dest, data);printWLine(data);free(data);}}
static void main_sink(){wchar_t * data=_main_data;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnvp(_P_WAIT, COMMAND_INT, args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_data=data;main_sink();}
static void main(){char * data;_union_type my_union;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");my_union.a=data;{char * data=my_union.b;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}}
static void main(){wchar_t * data;wchar_t * &data_ref=data;data=new wchar_t[100];{wchar_t * data=data_ref;{wchar_t dest[50]=L"";wcscpy(dest, data);printWLine(data);delete [] data;}}}
static void main(){int data;data=-1;data=5;{int result=data-1;printIntLine(result);}}
static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}{wchar_t dest[100];memmove(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main_sink(long long * data){free(data);}static void main(){long long * data;void (*func_ptr) (long long *)=main_sink;data=NULL;data=(long long *)malloc(100*sizeof(long long));func_ptr(data);}
static void main(){unsigned char data;data=' ';data=5;_main_data=data;b_main_sink();}void b_main_sink(){unsigned char data=_main_data;{unsigned char result=data * 2;printHexUnsignedCharLine(result);}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=20;}{int data=*data_ptr2;{size_t a,i;int *b;b=(int*)new char[a];for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);delete [] b;}}}
void b_main_sink(short data);static void main(){short data;void (*func_ptr) (short)=b_main_sink;data=0;data=100-1;func_ptr(data);}void b_main_sink(short data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;data=NULL;data=(char *)malloc(100*sizeof(char));func_ptr(data);}void b_main_sink(char * data){{char src[100];memmove(data, src, 100*sizeof(char));printLine(data);free(data);}}
static void main_sink(HANDLE data){if (data!=INVALID_HANDLE_VALUE){CloseHandle(data);}}static void main(){HANDLE data;void (*func_ptr) (HANDLE)=main_sink;data=INVALID_HANDLE_VALUE;data=CreateFile("BadSource_w32CreateFile.txt", (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);func_ptr(data);}
void b_main_sink(char * data);static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;b_main_sink(data);}void b_main_sink(char * data){{char dest[50]="";strncpy(dest, data, strlen(data));printLine(data);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");func_ptr(data);}void b_main_sink(wchar_t * data){EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){unsigned char data;data=' ';data=(unsigned char)rand();b_main_sink(data);}void b_main_sink(unsigned char data){c_main_sink(data);}void c_main_sink(unsigned char data){d_main_sink(data);}void d_main_sink(unsigned char data){e_main_sink(data);}void e_main_sink(unsigned char data){{unsigned char result=-1;if (data < UCHAR_MAX){result=data+1;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){twoints * data;if(global_returns_t_or_f()){{twoints * data_buf=new twoints[100];{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}}else{{twoints * data_buf=new twoints[100];{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}}printStructLine(&data[0]);delete [] data;}
static void main(){twointsclass * data;data=NULL;data=NULL;data=(twointsclass *)realloc(data, 100*sizeof(twointsclass));{twointsclass * data_copy=data;twointsclass * data=data_copy;free(data);}}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}
static void main(){int data;data=7;{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){double data;data=5.0;printDoubleLine(data);}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{char dest[100];memmove(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
static void main(){int * data;data=NULL;{int data_goodbuf[100];data=data_goodbuf;data[0]=5;printIntLine(data[0]);}{int * data_copy=data;int * data=data_copy;}}
void b_main_sink(void * void_data_ptr);static void main(){char * data;data=(char *)malloc(100*sizeof(char));data[0]='\0';{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{size_t i;for (i=0;i < strlen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}
static void main_sink(wchar_t * data){{wchar_t dest[100];memcpy(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;func_ptr(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnvp(_P_WAIT, COMMAND_INT, args);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100];data=data_buf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{char dest[50]="";memcpy(dest, data, strlen(data)*sizeof(char));printLine(data);}}
static void main_sink(){twointsclass * data=main_data;printIntLine(data[0].a);}static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}main_data=data;main_sink();}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(data, args);va_end(args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");main_vasink(data, data);}
static void main(){twoints * data;data=NULL;twoints data_good;data=&data_good;data->a=0;data->b=0;printStructLine(data);main_sink(&data);}void main_sink(void * void_data_ptr){twoints * * data_ptr=(twoints * *)void_data_ptr;twoints * data=(*data_ptr);}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;if (wcsncmp(PASSWORD, data, wcslen(data))==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;my_union.a=data;{wchar_t * data=my_union.b;{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));printWLine(data);}}}
static void main_sink(){twoints * data=_main_data;if (data!=NULL){data[0].a=1;data[0].b=1;printStructLine(&data[0]);free(data);}}static void main(){twoints * data;data=(twoints *)realloc(data, 100);_main_data=data;main_sink();}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}
void b_main_sink(void * void_data_ptr);static void main(){int data;data=-1;data=CHAR_MAX-5;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);{short s=(short)data;printf("%hd\n", s);}}
static void main_sink(unsigned char data){{unsigned char result=-1;if (data <=(unsigned char)sqrt((unsigned char)UCHAR_MAX)){result=data * data;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}static void main(){unsigned char data;void (*func_ptr) (unsigned char)=main_sink;data=' ';data=UCHAR_MAX;func_ptr(data);}
static void main_sink(list<int> data){{list<int>::iterator i;cout << "The list contains: ";for( i=data.begin();i!=data.end();i++){if (!*i){data.clear();}cout << " " << *i;}cout << endl;}}static void main(){list<int> data;data.push_back(100);data.push_back(200);main_sink(data);}
static void main(){long long * data;long long * *data_ptr1=&data;long long * *data_ptr2=&data;data=NULL;{long long * data=*data_ptr1;data=new long long[100];}{long long * data=*data_ptr2;delete [] data;}}
static void main(){void * data;_union_type my_union;twoints data_goodbuf;int data_badbuf=100;data_goodbuf.a=0;data_goodbuf.b=0;data=&data_goodbuf;my_union.a=data;{void * data=my_union.b;printStructLine((twoints *)data);}}
static void main(){if(global_returns_t_or_f()){{char data[150], dest[100];memset(data, 'A', 149);data[149]='\0';strncpy(dest, data, 100);printLine(dest);}}else{{char data[150], dest[100];memset(data, 'A', 149);data[149]='\0';strncpy(dest, data, 100);printLine(dest);}}}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t dest[100];wcscpy(dest, data);printWLine(dest);}}
void b_main_sink(_struct_type my_struct);static void main(){double * data;_struct_type my_struct;data=NULL;data=(double *)malloc(sizeof(*data));my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){double * data=my_struct.a;printDoubleLine(*data);free(data);}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=NULL;data=new wchar_t;func_ptr(data);}void main_sink(wchar_t * data){delete data;}
void b_main_sink(char * data);static void main(){char * data;char data_buf[250]="PATH=";data=data_buf;strcat(data, NEW_PATH);b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){PUTENV(data);}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, data, args);va_end(args);}}static void main_sink(){wchar_t * data=_main_data;main_vasink(data, data);}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");_main_data=data;main_sink();}
static void main(){int data;data=-1;data=OPEN("BadSource_open.txt", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);{int data_copy=data;int data=data_copy;if (data!=-1){CLOSE(data);}}}
static void main(){unsigned char data;data=' ';data=(unsigned char)rand();b_main_sink(&data);}void b_main_sink(void * void_data_ptr){unsigned char * data_ptr=(unsigned char *)void_data_ptr;unsigned char data=(*data_ptr);{unsigned char result=-1;if (data <=(unsigned char)sqrt((unsigned char)UCHAR_MAX)){result=data * data;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main_sink(){wchar_t * data=_main_data;{wchar_t src[100];wcscat(data, src);printWLine(data);}}static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;_main_data=data;main_sink();}
static void main_sink(char * data){{size_t i;for (i=0;i < strlen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}static void main(){char * data;data=(char *)malloc(100*sizeof(char));data[0]='\0';{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}main_sink(data);}
int b_main_source(int data);static void main(){int data;data=-1;data=b_main_source(data);{size_t i;int *b;b=(int*)malloc(data * sizeof(int));for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);free(b);}}int b_main_source(int data){data=20;return data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];data[0].a=0;data[0].b=0;printIntLine(data[0].a);printIntLine(data[0].b);{twointsclass * data_copy=data;twointsclass * data=data_copy;delete[] data;}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){wprintf(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}
static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;printf("%s\n", data);}
static void main(){char * data;data=NULL;{char data_goodbuf[100];data=data_goodbuf;strcpy(data, "A String");printLine(data);}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){}
static void main(){unsigned char data;data=' ';data=UCHAR_MAX;_main_data=data;b_main_sink();}void b_main_sink(){unsigned char data=_main_data;{unsigned char result=-1;if (data < UCHAR_MAX){result=data+1;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{wchar_t dest[50]=L"";wcsncpy(dest, data, wcslen(data));printWLine(data);}}
static void main(){int data;data=-1;data=5;{int data_copy=data;int data=data_copy;{int result=data-1;printIntLine(result);}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){e_main_sink(data);}static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, "%s", args);va_end(args);printLine(dest);}}void e_main_sink(char * data){main_vasink(data, data);}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void b_main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
static void main(){long long * data;data=NULL;{long long data_goodbuf[100];data=data_goodbuf;data[0]=5L;printLongLongLine(data[0]);}}
static void main(){twoints * data;union_type my_union;data=NULL;data=new twoints;data->a=1;data->b=2;my_union.a=data;{twoints * data=my_union.b;printStructLine(data);}}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char data_buf[100]="";data=data_buf;strcat(data, "*.*");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnvp(_P_WAIT, COMMAND_INT, args);}}
static void main(){double * data;double * &data_ref=data;data=new double[10];{int i;for(i=0;i<(10/2);i++){data[i]=(double)i;}}{double * data=data_ref;{int i;for(i=0;i<10;i++){data[i]=(double)i;}}{int i;for(i=0;i<10;i++){printDoubleLine(data[i]);}}delete [] data;}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_t_or_f()){data=PASSWORD;}else{data=PASSWORD;}if(global_returns_t_or_f()){if (wcsncmp(PASSWORD, data, wcslen(data))==0) printLine("Access granted");else printLine("Access denied!");}else{if (wcsncmp(PASSWORD, data, wcslen(data))==0) printLine("Access granted");else printLine("Access denied!");}}
void _main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}static void main(){int data;data=-1;data=100-1;_main_sink(data);}
static void main(){int data;data=-1;data=5;{int result=data+1;printIntLine(result);}}
static void main_sink(char * data){fprintf(stdout, "%s\n", data);}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}func_ptr(data);}
void b_main_sink(void * void_data_ptr);static void main(){int data;data=-1;data=100-1;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main(){long long * data;data=NULL;data=new long long;main_sink_b(data);}void main_sink_b(long long * data){main_sink_c(data);}void main_sink_c(long long * data){main_sink_d(data);}void main_sink_d(long long * data){main_sink_e(data);}void main_sink_e(long long * data){delete data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;b_main_sink(data);}void b_main_sink(wchar_t * data){{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]=L'\0';printWLine(data);}}
static void main(){char data;data=' ';data=5;b_main_sink(&data);}void b_main_sink(char * data_ptr){char data=*data_ptr;{char result=data+1;printHexCharLine(result);}}
static void main(){if(global_returns_t_or_f()){{long l;l=0x10203040;* */l |=LONG_MIN;printIntLine(l);}}else{{long l;l=0x10203040;* */l |=LONG_MIN;printIntLine(l);}}}
static void main_sink(char * data){{char dest[100]="";SNPRINTF(dest, 100-1, "%s", data);printLine(dest);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}func_ptr(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){char data;char *data_ptr1=&data;char *data_ptr2=&data;data=' ';{char data=*data_ptr1;data=5;}{char data=*data_ptr2;{char result=data+1;printHexCharLine(result);}}}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=NULL;data=new wchar_t;func_ptr(data);}void main_sink(wchar_t * data){delete data;}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];{twointsclass src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memcpy(data, src, 100*sizeof(twointsclass));printIntLine(data[0].a);delete [] data;}}
static void main_sink(){unsigned int data=_main_data;{unsigned int result=data * 2;printUnsignedLine(result);}}static void main(){unsigned int data;data=0;data=5;_main_data=data;main_sink();}
static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=7;func_ptr(data);}void b_main_sink(int data){{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){_wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
void main_sink_b(wchar_t * data);static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}main_sink_b(data);}void main_sink_c(wchar_t * data);void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_d(wchar_t * data);void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_e(wchar_t * data);void main_sink_d(wchar_t * data){main_sink_e(data);}void main_sink_e(wchar_t * data){{wchar_t dest[100];memmove(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=100-1;func_ptr(data);}
static void main(){twointsclass * data;data=NULL;if(global_returns_t_or_f()){data=new twointsclass;}else{data=new twointsclass;}if(global_returns_t_or_f()){delete data;}else{delete data;}}
static void main_sink(char * data){free(data);}static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));main_sink(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;if(global_returns_t_or_f()){strcat(data, "*.*");}else{strcat(data, "*.*");}{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnvp(_P_WAIT, COMMAND_INT, args);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"15");b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];wmemset(data, L'A', 100-1);data[100-1]=L'\0';delete [] data;{wchar_t * data_copy=data;wchar_t * data=data_copy;}}
void b_main_sink(short data);static void main(){short data;data=0;data=100-1;b_main_sink(data);}void c_main_sink(short data);void b_main_sink(short data){c_main_sink(data);}void c_main_sink(short data){{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
static void main_sink(int data){printIntLine(100 % data);}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=7;func_ptr(data);}
static int main_source(int data){data=20;return data;}static void main(){int data;data=-1;data=main_source(data);{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{char dest[100]="";SNPRINTF(dest, 100-1, "%s", data);printLine(dest);}}
void b_main_sink();static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
static wchar_t * main_source(wchar_t * data){{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);wprintf(L"%s\n", data);}
void _main_sink(char * data){{char src[100];memmove(data, src, 100*sizeof(char));printLine(data);free(data);}}static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));_main_sink(data);}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}wchar_t * b_main_source(wchar_t * data){wcscat(data, L"*.*");return data;}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[250]="PATH=";data=data_buf;strcat(data, NEW_PATH);b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;PUTENV(data);}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(L"%s", args);va_end(args);}}static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}}{wchar_t * data=*data_ptr2;main_vasink(data, data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{int i, n, v;if (swscanf(data, L"%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;data=b_main_source(data);{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}wchar_t * b_main_source(wchar_t * data){wcscat(data, L"*.*");return data;}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]=L'\0';printWLine(data);}}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;data=b_main_source(data);{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}wchar_t * b_main_source(wchar_t * data){wcscat(data, L"file.txt");return data;}
static void main(){int data;data=-1;data=20;{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}
static void main(){int * data;data=NULL;data=new int;main_sink_b(data);}void main_sink_b(int * data){main_sink_c(data);}void main_sink_c(int * data){main_sink_d(data);}void main_sink_d(int * data){main_sink_e(data);}void main_sink_e(int * data){delete data;}
static void main(){long long * data;data=NULL;data=new long long[100];delete [] data;main_sink_b(data);}void main_sink_b(long long * data){main_sink_c(data);}void main_sink_c(long long * data){}
FILE * b_main_source(FILE * data);static void main(){FILE * data;data=NULL;data=b_main_source(data);if (data!=NULL){fclose(data);}}FILE * b_main_source(FILE * data){data=fopen("file.txt", "w+");return data;}
static void main(){int * data;data=NULL;data=new int;delete data;}
static void main(){long long * data;long long * data_array[5];data=NULL;data=(long long *)malloc(100*sizeof(long long));{size_t i;for(i=0;i < 100;i++){data[i]=5L;}}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(long long * data_array[]){long long * data=data_array[2];printLongLongLine(data[0]);}
void b_main_sink(void * void_data_ptr);static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));b_main_sink(&data);}void b_main_sink(void * void_data_ptr){twoints * * data_ptr=(twoints * *)void_data_ptr;twoints * data=(*data_ptr);{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memcpy(data, src, 100*sizeof(twoints));printStructLine(&data[0]);free(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, L"%s", data);printWLine(dest);}}
static void main(){char * data;data=NULL;data=(char *)calloc(100, sizeof(char));free(data);}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;data->a=1;data->b=2;main_sink_b(data);}void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_c(twointsclass * data){main_sink_d(data);}void main_sink_d(twointsclass * data){printIntLine(data->a);}
static void main_sink(){char * data=main_data;{char src[100];_snprintf(data, 100, "%s", src);printLine(data);delete [] data;}}static void main(){char * data;data=NULL;data=new char[100];main_data=data;main_sink();}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)calloc(100, sizeof(wchar_t));wcscpy(data, L"A String");printWLine(data);b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);free(data);}
static void main(){wchar_t * data;data=new wchar_t[100];{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t dest[50]=L"";wcscpy(dest, data);printWLine(data);delete [] data;}}}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;_wsystem(data);}
static void main(){int data;int &data_ref=data;data=-1;data=20;{int data=data_ref;{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}}
static void main_sink(){char * data=_main_data;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnvp(_P_WAIT, COMMAND_INT, args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_main_data=data;main_sink();}
static char main_source(char data){data=CHAR_MIN;return data;}static void main(){char data;data=' ';data=main_source(data);{char result=0;if (data > CHAR_MIN){result=data-1;printHexCharLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static void main(){struct _twoints * data;data=NULL;data=b_main_source(data);}struct _twoints * b_main_source(struct _twoints * data){{struct _twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);}return data;}
static void main(){twoints * data;data=NULL;data=new twoints[100];{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}main_sink(data);}void main_sink(twoints * data){printStructLine(&data[0]);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;fwprintf(stdout, data);}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;data=(wchar_t *)malloc(100*sizeof(wchar_t));data[0]=L'\0';{wchar_t * data=*data_ptr1;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}}{wchar_t * data=*data_ptr2;{size_t i;for (i=0;i < wcslen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");my_union.a=data;{wchar_t * data=my_union.b;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}}
static void main(){long long * data;data=NULL;data=new long long;main_sink_b(data);}void main_sink_b(long long * data){main_sink_c(data);}void main_sink_c(long long * data){delete data;}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"15");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main(){{charvoid * cv_struct=(charvoid *)malloc(sizeof(charvoid));cv_struct->y=SRC_STR;printWLine((wchar_t *)cv_struct->y);memcpy(cv_struct->x, SRC_STR, sizeof(cv_struct->x));printWLine((wchar_t *)cv_struct->x);printWLine((wchar_t *)cv_struct->y);free(cv_struct);}}
void b_main_sink(int data);static void main(){int data;data=-1;data=100-1;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void d_main_sink(int data);void c_main_sink(int data){d_main_sink(data);}void e_main_sink(int data);void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
void main_sink();static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}_main_data=data;main_sink();}void main_sink(){char * data=_main_data;{char dest[100];memcpy(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
static void main(){char * data;char * data_array[5];data=NULL;data=(char *)malloc(100*sizeof(char));data_array[2]=data;main_sink(data_array);}void main_sink(char * data_array[]){char * data=data_array[2];free(data);}
static void main(){int data;data=-1;data=5;b_main_sink(data);}void b_main_sink(int data){{int result=data+1;printIntLine(result);}}
static void main_sink(){int data=_main_data;{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0 && data < 10){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}static void main(){int data;fscanf (stdin, "%d", &data);_main_data=data;main_sink();}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char data_buf[100]="";data=data_buf;strcpy(data, GOOD_OS_COMMAND);data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{FILE *pipe;pipe=POPEN(data, "wb");if (pipe!=NULL) PCLOSE(pipe);}}
static void main(){if(global_returns_t_or_f()){{wchar_t data_buf[100]=L"";wchar_t * data=data_buf;if (fwscanf(stdin, L"%99s\0", data)==EOF){printLine("fwscanf failed!");}}}else{{wchar_t data_buf[100]=L"";wchar_t * data=data_buf;if (fwscanf(stdin, L"%99s\0", data)==EOF){printLine("fwscanf failed!");}}}}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=NULL;{wchar_t data_goodbuf[100];data=data_goodbuf;wcscpy(data, L"A String");printWLine(data);}func_ptr(data);}void main_sink(wchar_t * data){}
static void main(){int * data;data=NULL;if(global_returns_t_or_f()){data=(int *)malloc(100*sizeof(int));{size_t i;for(i=0;i < 100;i++){data[i]=5;}}free(data);}else{data=(int *)malloc(100*sizeof(int));{size_t i;for(i=0;i < 100;i++){data[i]=5;}}free(data);}if(global_returns_t_or_f()){}else{}}
static void main(){twoints * data;union_type my_union;{twoints * data_buf=new twoints[100];{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}my_union.a=data;{twoints * data=my_union.b;printStructLine(&data[0]);delete [] data;}}
static void main(){wchar_t * data;_union_type my_union;data=NULL;data=NULL;data=(wchar_t *)realloc(data, 100*sizeof(wchar_t));wcscpy(data, L"A String");printWLine(data);my_union.a=data;{wchar_t * data=my_union.b;free(data);}}
static void main(){twoints * data;struct_type my_struct;data=NULL;data=new twoints;my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){twoints * data=my_struct.a;delete data;}
static void main(){twoints * data;data=NULL;data=new twoints;data->a=1;data->b=2;delete data;main_sink_b(data);}void main_sink_b(twoints * data){main_sink_c(data);}void main_sink_c(twoints * data){}
void main_source(int &data);static void main(){int data;data=-1;main_source(data);{size_t a,i;int *b;b=(int*)new char[a];for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);delete [] b;}}void main_source(int &data){data=20;}
static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;{char src[100];strcpy(data, src);printLine(data);}}
void b_main_sink(void * void_data_ptr);static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));b_main_sink(&data);}void b_main_sink(void * void_data_ptr){long long * * data_ptr=(long long * *)void_data_ptr;long long * data=(*data_ptr);{memmove(data, src, 100*sizeof(long long));printLongLongLine(data[0]);free(data);}}
static char * main_source(char * data){{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}return data;}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf("%s", args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);main_vasink(data, data);}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");{char * data_copy=data;char * data=data_copy;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}}
static void main(){{char * key="TEST\\TestKey";HKEY hKey;if (RegCreateKeyExA( HKEY_CURRENT_USER, key, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, NULL)!=ERROR_SUCCESS){printLine("Registry key could not be created");}else{printLine("Registry key created successfully");}}}
static void main(){int count;count=-1;count=20;b_main_sink(&count);}void b_main_sink(void * void_count_ptr){int * count_ptr=(int *)void_count_ptr;int count=(*count_ptr);{size_t i=0;for (i=0;i < (size_t)count;i++){printLine("Hello");}}}
static void main(){twoints * data;twoints * data_array[5];data=NULL;data=new twoints;data_array[2]=data;main_sink(data_array);}void main_sink(twoints * data_array[]){twoints * data=data_array[2];delete data;}
static void main(){wchar_t * data;data=NULL;if(global_returns_t_or_f()){data=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data, L'A', 100-1);data[100-1]=L'\0';}else{data=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data, L'A', 100-1);data[100-1]=L'\0';}if(global_returns_t_or_f()){printWLine(data);}else{printWLine(data);}}
void main_sink_b(int * data);static void main(){int * data;{int * data_buf=new int[100];{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}main_sink_b(data);}void main_sink_c(int * data);void main_sink_b(int * data){main_sink_c(data);}void main_sink_d(int * data);void main_sink_c(int * data){main_sink_d(data);}void main_sink_d(int * data){printIntLine(data[0]);delete [] data;}
static void main(){{if (puts("string")==EOF){printLine("puts failed!");}}}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");b_main_sink(data);}void b_main_sink(char * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}my_struct.a=data;b_main_sink(my_struct);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(L"%s", args);va_end(args);}}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;main_vasink(data, data);}
static void main(){char * data;char * &data_ref=data;data=NULL;data=new char[100];{char * data=data_ref;{char src[100];strcpy(data, src);printLine(data);delete [] data;}}}
void main_source(long long * &data);static void main(){long long * data;main_source(data);printLongLongLine(data[0]);delete [] data;}void main_source(long long * &data){{long long * data_buf=new long long[100];{size_t i;for (i=0;i < 100;i++){data_buf[i]=5L;}}data=data_buf;}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");func_ptr(data);}void b_main_sink(wchar_t * data){_wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, "%s", args);va_end(args);printLine(dest);}}static void main(){char * data;void (*func_ptr) (char *, ...)=main_vasink;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}
static void main(){int * data;data=NULL;data=(int *)malloc(100*sizeof(int));{memmove(data, src, 100*sizeof(int));printIntLine(data[0]);free(data);}}
static char * main_source(char * data){{char * data_buf=new char[100];data=data_buf;}return data;}static void main(){char * data;data=main_source(data);printLine(data);delete [] data;}
static void main_sink(unsigned char data){{unsigned char result=data-1;printHexUnsignedCharLine(result);}}static void main(){unsigned char data;data=' ';data=5;main_sink(data);}
static void main(){int * data;data=NULL;data=NULL;data=(int *)realloc(data, 100*sizeof(int));data[0]=5;printIntLine(data[0]);b_main_sink(data);}void b_main_sink(int * data){c_main_sink(data);}void c_main_sink(int * data){free(data);}
static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]="";data=data_buf;data=PASSWORD;func_ptr(data);}void b_main_sink(char * data){if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){short data;data=0;data=100-1;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
static void main_sink(){int data=_main_data;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}static void main(){int data;data=-1;data=100-1;_main_data=data;main_sink();}
static void main_sink(int data){{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than the length of the source string or too large");}}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=RAND32();func_ptr(data);}
void b_main_sink(short data_array[]);static void main(){short data;short data_array[5];data=0;data=100-1;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(short data_array[]){short data=data_array[2];{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
static void main(){wchar_t * data;data=NULL;{wchar_t data_goodbuf[100];data=data_goodbuf;wcscpy(data, L"A String");printWLine(data);}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){}
static void main(){char * data;struct_type my_struct;data=NULL;data=new char;my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){char * data=my_struct.a;delete data;}
char * b_main_source(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}char * b_main_source(char * data){strcat(data, "*.*");return data;}
static void main(){long long * data;long long data_badbuf[50];long long data_goodbuf[100];data=data_goodbuf;{long long * data_copy=data;long long * data=data_copy;{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printLongLongLine(data[0]);}}}}
static void main_sink(short data){{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}static void main(){short data;void (*func_ptr) (short)=main_sink;data=0;data=100-1;func_ptr(data);}
static void main_sink(int data){{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=100-1;func_ptr(data);}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{char src[100];strncpy(data, src, 100);data[100-1]='\0';printLine(data);}}
static void main(){int * data;data=NULL;data=(int *)malloc(100*sizeof(int));data[0]=5;printIntLine(data[0]);b_main_sink(data);}void b_main_sink(int * data){c_main_sink(data);}void c_main_sink(int * data){free(data);}
static void main_sink(){int data=_main_data;printIntLine(100 % data);}static void main(){int data;data=-1;data=7;_main_data=data;main_sink();}
static void main(){unsigned char data;data=' ';data=5;b_main_sink(data);}void b_main_sink(unsigned char data){c_main_sink(data);}void c_main_sink(unsigned char data){{unsigned char result=data * data;printHexUnsignedCharLine(result);}}
void b_main_sink(twoints * data);static void main(){twoints * data;twoints data_badbuf[50];twoints data_goodbuf[100];data=data_goodbuf;b_main_sink(data);}void c_main_sink(twoints * data);void b_main_sink(twoints * data){c_main_sink(data);}void d_main_sink(twoints * data);void c_main_sink(twoints * data){d_main_sink(data);}void d_main_sink(twoints * data){{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memmove(data, src, 100*sizeof(twoints));printStructLine(&data[0]);}}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main_sink(){char * data=_main_data;}static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));free(data);_main_data=data;main_sink();}
void _main_sink(short data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}static void main(){short data;data=0;data=100-1;_main_sink(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}{wchar_t * data_copy=data;wchar_t * data=data_copy;fwprintf(stdout, L"%s\n", data);}}
static void main(){int data;data=-1;if(global_returns_t_or_f()){data=20;}else{data=20;}{size_t i;int *b;b=(int*)malloc(data * sizeof(int));for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);free(b);}}
static void main(){twoints * data;union_type my_union;data=NULL;data=new twoints;my_union.a=data;{twoints * data=my_union.b;delete data;}}
static void main(){char * data;data=NULL;data=NULL;data=(char *)realloc(data, 100*sizeof(char));strcpy(data, "A String");printLine(data);free(data);}
void main_sink(twointsclass * * data);static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];main_sink(&data);}void main_sink(twointsclass * * data_ptr){twointsclass * data=*data_ptr;{twointsclass src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memmove(data, src, 100*sizeof(twointsclass));printIntLine(data[0].a);delete [] data;}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
static void main(){{char data;data=5;char * pointer=new char;{char data=*pointer;printHexCharLine(data);}delete pointer;}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main_vasinkb(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}static void main_vasinkg(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, L"%s", args);va_end(args);printWLine(dest);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}main_vasinkg(data, data);}
static void main(){int count;count=-1;count=20;b_main_sink(count);}void b_main_sink(int count){c_main_sink(count);}void c_main_sink(int count){{size_t i=0;FILE *file=NULL;const char *filename="output_bad.txt";file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}
void main_sink_b(wchar_t * data);static void main(){wchar_t * data;data=new wchar_t[100];main_sink_b(data);}void main_sink_c(wchar_t * data);void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_d(wchar_t * data);void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_e(wchar_t * data);void main_sink_d(wchar_t * data){main_sink_e(data);}void main_sink_e(wchar_t * data){{wchar_t dest[50]=L"";memmove(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);delete [] data;}}
static void main(){long long * data;data=NULL;if(global_returns_t_or_f()){data=(long long *)malloc(100*sizeof(long long));}else{data=(long long *)malloc(100*sizeof(long long));}if(global_returns_t_or_f()){free(data);}else{free(data);}}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(L"%s", args);va_end(args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}{wchar_t * data_copy=data;wchar_t * data=data_copy;main_vasink(data, data);}}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}static void main(){char * data;void (*func_ptr) (char *, ...)=main_vasink;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");func_ptr(data);}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");main_vasink(data, data);}
static void main(){int data;data=7;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main(){float data;data=0.0F;data=7.0F;{float data_copy=data;float data=data_copy;printDoubleLine((double)(100.0/data));}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}char * b_main_source(char * data){{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}return data;}
static void main(){int data;data=7;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
void _main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_main_sink(data);}
static void main(){unsigned char data;void (*func_ptr) (unsigned char)=b_main_sink;data=' ';data=5;func_ptr(data);}void b_main_sink(unsigned char data){{unsigned char result=data+1;printHexUnsignedCharLine(result);}}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");{wchar_t * data_copy=data;wchar_t * data=data_copy;{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){twoints * data;twoints * &data_ref=data;data=NULL;data=new twoints;delete data;{twoints * data=data_ref;}}
static void main(){int * data;data=NULL;data=new int;main_sink_b(data);}void main_sink_b(int * data){main_sink_c(data);}void main_sink_c(int * data){main_sink_d(data);}void main_sink_d(int * data){delete data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;data="P";if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;func_ptr(data);}void b_main_sink(wchar_t * data){{wchar_t src[100];wcscpy(data, src);printWLine(data);}}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{wchar_t dest[50]=L"";size_t i, data_len;data_len=wcslen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printWLine(data);}}
static void main(){char * data;_union_type my_union;data=NULL;data=(char *)calloc(100, sizeof(char));strcpy(data, "A String");printLine(data);my_union.a=data;{char * data=my_union.b;free(data);}}
static void main_sink(){wchar_t * data=_main_data;{wchar_t data_src[10+1]=SRC_STRING;wcscpy(data, data_src);printWLine(data);free(data);}}static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));_main_data=data;main_sink();}
static void main(){int data;data=-1;data=20;main_sink_b(data);}void main_sink_b(int data){main_sink_c(data);}void main_sink_c(int data){main_sink_d(data);}void main_sink_d(int data){{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}
static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, data, args);va_end(args);printLine(dest);}}static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);main_vasink(data, data);}char * b_main_source(char * data){strcpy(data, "fixedstringtest");return data;}
static void main(){wchar_t * data;wchar_t data_buf[250]=L"PATH=";data=data_buf;wcscat(data, NEW_PATH);PUTENV(data);}
static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];{wchar_t src[100];_snwprintf(data, 100, L"%s", src);printWLine(data);delete [] data;}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){int data;data=-1;data=main_source(data);{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}int main_source(int data){data=10000;return data;}
static void main_sink(int data){{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0 && data < 10){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}static void main(){int data;void (*func_ptr) (int)=main_sink;fscanf (stdin, "%d", &data);func_ptr(data);}
static void main(){int data;int data_array[5];data=-1;data=20;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{char * char_string;if (data > 0){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than 0");}}}
static void main(){wchar_t * data;wchar_t * data_array[5];data=NULL;{wchar_t data_goodbuf[100];data=data_goodbuf;wcscpy(data, L"A String");printWLine(data);}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];}
static void main_sink(wchar_t * data){wprintf(L"%s\n", data);}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}main_sink(data);}
void b_main_sink(int * data);static void main(){int * data;{int * data_buf=(int *)malloc(100*sizeof(int));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}b_main_sink(data);}void c_main_sink(int * data);void b_main_sink(int * data){c_main_sink(data);}void c_main_sink(int * data){printIntLine(data[0]);free(data);}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"C:\\Windows\\System32\\winsrv.dll");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{HMODULE hModule;hModule=LoadLibraryW(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
void b_main_sink();static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{wchar_t dest[50]=L"";wcscat(dest, data);printWLine(data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;fprintf(stdout, "%s\n", data);}
static void main_vasinkg(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, "%s", args);va_end(args);}}static void main_vasinkb(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;if(global_returns_f()){strcpy(data, "fixedstringtest");}else{strcpy(data, "fixedstringtest");}if(global_returns_t()){main_vasinkb(data, data);}else{main_vasinkb(data, data);}}
static void main(){wchar_t * data;wchar_t * &data_ref=data;{wchar_t * data_buf=new wchar_t[100];data=data_buf;}{wchar_t * data=data_ref;printWLine(data);delete [] data;}}
static void main(){twointsclass * data;twointsclass * *data_ptr1=&data;twointsclass * *data_ptr2=&data;data=NULL;{twointsclass * data=*data_ptr1;data=new twointsclass[100];{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}delete [] data;}{twointsclass * data=*data_ptr2;}}
static void main_sink(){wchar_t * data=_main_data;{wchar_t dest[100];memmove(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}static void main(){wchar_t * data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;_main_data=data;main_sink();}
static wchar_t * main_source(wchar_t * data){{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}return data;}static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));data[0]=L'\0';data=main_source(data);{size_t i;for (i=0;i < wcslen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}
static void main(){char * data;data=new char[100];if(global_returns_t_or_f()){}else{}{char dest[50]="";strncat(dest, data, strlen(data));printLine(data);delete [] data;}}
static wchar_t * main_source(wchar_t * data){data=new wchar_t;return data;}static void main(){wchar_t * data;data=NULL;data=main_source(data);delete data;}
void b_main_sink(int data);static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=-1;data=ASSERT_VALUE+1;func_ptr(data);}void b_main_sink(int data){assert(data > ASSERT_VALUE);}
static void main_sink(twoints * data){free(data);}static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));main_sink(data);}
static void main(){unsigned int data;_union_type my_union;data=0;data=5;my_union.a=data;{unsigned int data=my_union.b;{unsigned int result=data-1;printUnsignedLine(result);}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{wchar_t dest[100];wcscpy(dest, data);printWLine(dest);}}
static void main(){int data;data=-1;data=20;_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}
static void main(){char * data;data=NULL;main_source(data);free(data);}void main_source(char * &data){data=(char *)malloc(100*sizeof(char));}
void b_main_sink(long long * * data);static void main(){long long * data;{long long * data_buf=(long long *)malloc(100*sizeof(long long));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5L;}}data=data_buf;}b_main_sink(&data);}void b_main_sink(long long * * data_ptr){long long * data=*data_ptr;printLongLongLine(data[0]);free(data);}
static void main(){char * data;data=NULL;if(global_returns_t_or_f()){{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}}else{{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}}{char src[100];memmove(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}
static void main(){int data;data=-1;if(global_returns_t_or_f()){data=CHAR_MAX-5;}else{data=CHAR_MAX-5;}{char c=(char)data;printHexCharLine(c);}}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");my_struct.a=data;b_main_sink(my_struct);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(data, args);va_end(args);}}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;main_vasink(data, data);}
static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;{char * data_copy=data;char * data=data_copy;{char dest[100];memset(dest, 'C', 100-1);memcpy(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");_main_data=data;b_main_sink();}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, data, args);va_end(args);}}void b_main_sink(){wchar_t * data=_main_data;main_vasink(data, data);}
static void main(){long long * data;data=NULL;main_source(data);delete [] data;}void main_source(long long * &data){data=new long long[100];}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;data=NULL;{wchar_t * data=*data_ptr1;data=new wchar_t;}{wchar_t * data=*data_ptr2;delete data;}}
static void main(){int * data;data=NULL;data=(int *)malloc(100*sizeof(int));_main_data=data;b_main_sink();}void b_main_sink(){int * data=_main_data;free(data);}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;data=L"P";my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char data_buf[100]="";data=data_buf;strcpy(data, GOOD_OS_COMMAND);data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];system(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
static void main(){wchar_t * password;wchar_t * *password_ptr1=&password;wchar_t * *password_ptr2=&password;wchar_t password_buf[100]=L"";password=password_buf;{wchar_t * password=*password_ptr1;wcscpy(password, L"Password1234!");}{wchar_t * password=*password_ptr2;{HANDLE pHandle;wchar_t * username=L"User";wchar_t * domain=L"Domain";if (LogonUserW( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *, ...)=b_main_vasink;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");func_ptr(data);}void b_main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}
static void main_sink(){int * data=main_data;free(data);}static void main(){int * data;data=NULL;data=(int *)malloc(100*sizeof(int));main_data=data;main_sink();}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[250]=L"PATH=";data=data_buf;wcscat(data, NEW_PATH);my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;PUTENV(data);}
static void main(){int * data;void (*func_ptr) (int *)=b_main_sink;data=NULL;{int data_goodbuf[100];data=data_goodbuf;data[0]=5;printIntLine(data[0]);}func_ptr(data);}void b_main_sink(int * data){}
static void main(){struct _twoints * data;data=NULL;{struct _twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);}{struct _twoints * data_copy=data;struct _twoints * data=data_copy;}}
static void main_sink(char * data){if (strncmp(PASSWORD, data, strlen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;data=PASSWORD;func_ptr(data);}
void main_sink();static void main(){twoints * data;{twoints * data_buf=new twoints[100];{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}_main_data=data;main_sink();}void main_sink(){twoints * data=_main_data;printStructLine(&data[0]);delete [] data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){_wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
void b_main_sink(void * void_data_ptr);static void main(){int data;data=-1;data=7;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);printIntLine(100/data);}
static void main(){int * data;_union_type my_union;int data_badbuf[50];int data_goodbuf[100];data=data_goodbuf;my_union.a=data;{int * data=my_union.b;{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printIntLine(data[0]);}}}}
void b_main_sink(twoints * data);static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));b_main_sink(data);}void b_main_sink(twoints * data){{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memmove(data, src, 100*sizeof(twoints));printStructLine(&data[0]);free(data);}}
void b_main_sink(int * data);static void main(){int * data;data=NULL;data=(int *)malloc(10*sizeof(int));b_main_sink(data);}void b_main_sink(int * data){{int data_src[10]={0};size_t i;for (i=0;i < 10;i++){data[i]=data_src[i];}printIntLine(data[0]);free(data);}}
static unsigned int main_source(unsigned int data){data=0;return data;}static void main(){unsigned int data;data=0;data=main_source(data);{unsigned int result=0;if (data > 0){result=data-1;printUnsignedLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t data_src[10+1]=SRC_STRING;memcpy(data, data_src, wcslen(data_src)*sizeof(wchar_t));printWLine(data);free(data);}}}
static void main_sink(char * data){{int i, n, v;if (sscanf(data, "%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;strcpy(data, "15");func_ptr(data);}
static void main_sink(char * data){{char dest[100];strncpy(dest, data, strlen(dest));dest[100-1]='\0';printLine(dest);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}func_ptr(data);}
static wchar_t * main_source(wchar_t * data){wcscpy(data, L"C:\\Windows\\System32\\winsrv.dll");return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);{HMODULE hModule;hModule=LoadLibraryW(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_t_or_f()){wcscat(data, L"*.*");}else{wcscat(data, L"*.*");}EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){int data;data=7;b_main_sink(data);}void b_main_sink(int data){{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main(){unsigned char data;data=' ';data=5;{unsigned char result=data * 2;printHexUnsignedCharLine(result);}}
static void main(){char * data;data=NULL;data=main_source(data);}char * main_source(char * data){{char data_goodbuf[100];data=data_goodbuf;strcpy(data, "A String");printLine(data);}return data;}
static void main_sink(int data){printIntLine(100/data);}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=7;func_ptr(data);}
static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;{wchar_t dest[50]=L"";memmove(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);}}
static void main(){twoints * data;union_type my_union;data=NULL;data=new twoints;my_union.a=data;{twoints * data=my_union.b;delete data;}}
static void main(){int data;_union_type my_union;data=-1;data=7;my_union.a=data;{int data=my_union.b;printIntLine(100 % data);}}
void main_sink(void * void_data_ptr);static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}main_sink(&data);}void main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{char src[100];memmove(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}
static void main_sink(){wchar_t * data=_main_data;{wchar_t dest[50]=L"";wcsncpy(dest, data, wcslen(data));printWLine(data);}}static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;_main_data=data;main_sink();}
static void main_vasinkb(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, data, args);va_end(args);printLine(dest);}}static void main_vasinkg(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, "%s", args);va_end(args);printLine(dest);}}static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}main_vasinkg(data, data);}
static void main(){int * data;_union_type my_union;data=(int *)calloc(100, sizeof(int));my_union.a=data;{int * data=my_union.b;if (data!=NULL){data[0]=5;printIntLine(data[0]);free(data);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){short data;data=0;data=100-1;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main_sink(wchar_t * data){delete [] data;}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=NULL;data=new wchar_t[100];func_ptr(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;if (wcsncmp(PASSWORD, data, wcslen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){long long * data;data=NULL;data=new long long;main_sink_b(data);}void main_sink_b(long long * data){main_sink_c(data);}void main_sink_c(long long * data){main_sink_d(data);}void main_sink_d(long long * data){main_sink_e(data);}void main_sink_e(long long * data){delete data;}
void b_main_sink(_struct_type my_struct);static void main(){int data;_struct_type my_struct;data=-1;data=CHAR_MAX-5;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{char c=(char)data;printHexCharLine(c);}}
static void main(){unsigned int data;data=0;data=UINT_MAX;{unsigned int result=-1;if (data <=(unsigned int)sqrt((unsigned int)UINT_MAX)){result=data * data;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){int data;int data_array[5];data=-1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);wprintf(L"%s\n", data);}wchar_t * b_main_source(wchar_t * data){{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}return data;}
static void main(){wchar_t * data;data=NULL;data=b_main_source(data);}wchar_t * b_main_source(wchar_t * data){data=(wchar_t *)malloc(100*sizeof(wchar_t));free(data);return data;}
static void main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}main_sink(data);}
static wchar_t * main_source(wchar_t * data){wcscpy(data, L"fixedstringtest");return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);fwprintf(stdout, data);}
static void main_sink(long long * data){delete [] data;}static void main(){long long * data;void (*func_ptr) (long long *)=main_sink;data=NULL;data=new long long[100];func_ptr(data);}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, "%s", args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}main_vasink(data, data);}
static void main_sink(){twointsclass * data=main_data;}static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];delete [] data;main_data=data;main_sink();}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnvp(_P_WAIT, COMMAND_INT, args);}}
static void main(){twoints * data;b_main_sink(&data);}void b_main_sink(twoints * * data_ptr){twoints * data=*data_ptr;data=(twoints *)malloc(sizeof(twoints));data->a=5;data->b=6;printIntLine(data->a);printIntLine(data->b);}
static void main(){wchar_t * data;data=(wchar_t *)malloc(100);{wchar_t * data_copy=data;wchar_t * data=data_copy;if (data!=NULL){wcscpy(data, L"Initialize");printWLine(data);free(data);}}}
static void main(){int count;count=-1;count=20;b_main_sink(count);}void b_main_sink(int count){c_main_sink(count);}void c_main_sink(int count){d_main_sink(count);}void d_main_sink(int count){{size_t i=0;for (i=0;i < (size_t)count;i++){printLine("Hello");}}}
static void main(){long long * data;data=NULL;data=(long long *)calloc(100, sizeof(long long));main_sink(&data);}void main_sink(void * void_data_ptr){long long * * data_ptr=(long long * *)void_data_ptr;long long * data=(*data_ptr);free(data);}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{wchar_t src[100];wcscpy(data, src);printWLine(data);}}
static void main(){twoints * data;data=NULL;data=new twoints;main_sink_b(data);}void main_sink_b(twoints * data){main_sink_c(data);}void main_sink_c(twoints * data){main_sink_d(data);}void main_sink_d(twoints * data){main_sink_e(data);}void main_sink_e(twoints * data){delete data;}
void b_main_sink(int data);static void main(){int data;data=-1;data=7;b_main_sink(data);}void b_main_sink(int data){printIntLine(100 % data);}
static void main(){twoints * data;_struct_type my_struct;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));data[0].a=0;data[0].b=0;printStructLine(&data[0]);my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){twoints * data=my_struct.a;free(data);}
void main_sink_b(char * data);static void main(){char * data;{char * data_buf=new char[100];data=data_buf;}main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_d(char * data);void main_sink_c(char * data){main_sink_d(data);}void main_sink_e(char * data);void main_sink_d(char * data){main_sink_e(data);}void main_sink_e(char * data){printLine(data);delete [] data;}
static void main(){char * data;data=NULL;data=new char;main_sink_b(data);}void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){main_sink_d(data);}void main_sink_d(char * data){main_sink_e(data);}void main_sink_e(char * data){delete data;}
void _main_sink(char * data){{char src[100];memcpy(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;_main_sink(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}
static void main(){long long * data;long long * *data_ptr1=&data;long long * *data_ptr2=&data;data=NULL;{long long * data=*data_ptr1;data=new long long[100];}{long long * data=*data_ptr2;{memcpy(data, src, 100*sizeof(long long));printLongLongLine(data[0]);delete [] data;}}}
static void main(){int data;data=7;b_main_sink(data);}void b_main_sink(int data){{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main(){unsigned char data;data=' ';data=5;b_main_sink(data);}void b_main_sink(unsigned char data){c_main_sink(data);}void c_main_sink(unsigned char data){d_main_sink(data);}void d_main_sink(unsigned char data){{unsigned char result=data+1;printHexUnsignedCharLine(result);}}
static void main(){char * data;data=(char *)malloc(100*sizeof(char));data[0]='\0';strcpy(data, BAD_SRC_FIXED);if(global_returns_t_or_f()){{size_t i;for (i=0;i < strlen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}else{{size_t i;for (i=0;i < strlen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}}
static void main(){char * data;data=NULL;data=new char[100];{char * data_copy=data;char * data=data_copy;delete [] data;}}
void b_main_sink(int data_array[]);static void main(){int data;int data_array[5];data=-1;data=100-1;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
void b_main_sink();static void main(){float data;data=0.0F;data=7.0F;_main_data=data;b_main_sink();}void b_main_sink(){float data=_main_data;printDoubleLine((double)(100.0/data));}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';{char * data=*data_ptr1;data=data_buf;}{char * data=*data_ptr2;{char dest[100];memcpy(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;fwprintf(stdout, L"%s\n", data);}
static void main(){wchar_t * data;data=NULL;data=main_source(data);delete [] data;}wchar_t * main_source(wchar_t * data){data=new wchar_t[100];return data;}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;wcscat(data, L"*.*");}{wchar_t * data=*data_ptr2;_wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){int data;_union_type my_union;data=-1;data=100-1;my_union.a=data;{int data=my_union.b;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(data);}void b_main_sink(wchar_t * data){wprintf(data);}
static void main(){struct _twoints * data;data=NULL;{struct _twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);}}
static void main_sink(char * data){{char dest[100]="";SNPRINTF(dest, 100-1, data);printLine(dest);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");func_ptr(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){printf("%s\n", data);}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
void main_sink(struct_type my_struct);static void main(){char * data;struct_type my_struct;data=new char[100];my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){char * data=my_struct.a;{char dest[50]="";memcpy(dest, data, strlen(data)*sizeof(char));printLine(data);delete [] data;}}
static void main(){twoints * data;twoints * data_array[5];data=NULL;data=(twoints *)malloc(100*sizeof(twoints));{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}free(data);data_array[2]=data;b_main_sink(data_array);}void b_main_sink(twoints * data_array[]){twoints * data=data_array[2];}
void main_sink(wchar_t * data){{wchar_t src[100];wcsncpy(data, src, 100);printWLine(data);delete [] data;}}static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_sink(data);}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;data=NULL;{wchar_t * data=*data_ptr1;data=(wchar_t *)malloc(100*sizeof(wchar_t));}{wchar_t * data=*data_ptr2;free(data);}}
void b_main_sink(_struct_type my_struct);static void main(){int data;_struct_type my_struct;data=-1;data=100-1;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}}{int data=*data_ptr2;{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than the length of the source string or too large");}}}}
static void main(){char data;data=' ';data=b_main_source(data);{char result=data * data;printHexCharLine(result);}}char b_main_source(char data){data=5;return data;}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char data_buf[100]="";data=data_buf;strcat(data, "*.*");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];_spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static long long * main_source(long long * data){{long long data_goodbuf[100];data=data_goodbuf;data[0]=5L;printLongLongLine(data[0]);}return data;}static void main(){long long * data;data=NULL;data=main_source(data);}
static void main_sink(){wchar_t * data=_main_data;fwprintf(stdout, data);}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");_main_data=data;main_sink();}
static void main(){short data;data=0;if(global_returns_t_or_f()){data=100-1;}else{data=100-1;}{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}{wchar_t * data_copy=data;wchar_t * data=data_copy;wprintf(L"%s\n", data);}}
static void main_sink(){char * data=_main_data;if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;_main_data=data;main_sink();}
static void main(){wchar_t * data;wchar_t * &data_ref=data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}{wchar_t * data=data_ref;{wchar_t dest[100];wcsncpy(dest, data, wcslen(dest));dest[100-1]=L'\0';printWLine(dest);}}}
char * main_source(char * data);static void main(){char * data;data=new char[100];data=main_source(data);{char dest[50]="";strncat(dest, data, strlen(data));printLine(data);delete [] data;}}char * main_source(char * data){return data;}
static void main(){char * data;data=NULL;data=new char;printHexCharLine(*data);main_sink_b(data);}void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){main_sink_d(data);}void main_sink_d(char * data){main_sink_e(data);}void main_sink_e(char * data){delete data;}
static void main(){twointsclass * data;twointsclass * *data_ptr1=&data;twointsclass * *data_ptr2=&data;data=NULL;{twointsclass * data=*data_ptr1;data=new twointsclass[100];}{twointsclass * data=*data_ptr2;{twointsclass src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printIntLine(data[0].a);delete [] data;}}}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];delete [] data;}
static void main_sink(char data){{char result=-1;if (data <=(CHAR_MAX/2)){result=data * 2;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}static void main(){char data;data=' ';data=CHAR_MAX;main_sink(data);}
static void main(){int data;union_type my_union;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}my_union.a=data;{int data=my_union.b;{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}_main_data=data;b_main_sink();}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf("%s", args);va_end(args);}}void b_main_sink(){char * data=_main_data;main_vasink(data, data);}
static twointsclass * main_source(twointsclass * data){data=(twointsclass *)malloc(100*sizeof(twointsclass));return data;}static void main(){twointsclass * data;data=NULL;data=main_source(data);free(data);}
void main_sink(char * data){{size_t i, dest_sz;char dest[100];memset(dest, 'C', 100-1);dest_sz=strlen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);delete [] data;}}static void main(){char * data;data=NULL;data=new char[100];main_sink(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=-1;data=RAND32();func_ptr(data);}void b_main_sink(int data){{int result=-1;if (data <=(int)sqrt((int)INT_MAX)){result=data * data;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main_sink(){wchar_t * data=main_data;{wchar_t src[100];wcscpy(data, src);printWLine(data);delete [] data;}}static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_data=data;main_sink();}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){int data;data=-1;data=20;main_sink(data);}void main_sink(int data){{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");func_ptr(data);}void b_main_sink(wchar_t * data){fwprintf(stdout, data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;if (wcsncmp(PASSWORD, data, wcslen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){twoints * data;twoints * *data_ptr1=&data;twoints * *data_ptr2=&data;data=NULL;{twoints * data=*data_ptr1;data=new twoints[100];}{twoints * data=*data_ptr2;delete [] data;}}
static void main(){char * data;_union_type my_union;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");my_union.a=data;{char * data=my_union.b;{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}}
static void main(){char * data;char data_buf[100];data=data_buf;{size_t src_len;char src[100];src_len=strlen(src);strncat(data, src, src_len);printLine(data);}}
static void main_sink(twointsclass * data){free(data);}static void main(){twointsclass * data;data=NULL;data=(twointsclass *)malloc(100*sizeof(twointsclass));main_sink(data);}
static void main(){short data;data=0;if(global_returns_t_or_f()){data=100-1;}else{data=100-1;}{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
void b_main_sink(long long * data);static void main(){long long * data;long long data_badbuf[50];long long data_goodbuf[100];data=data_goodbuf;b_main_sink(data);}void b_main_sink(long long * data){{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printLongLongLine(data[0]);}}}
static void main(){int data;data=-1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}main_sink_b(data);}void main_sink_b(int data){main_sink_c(data);}void main_sink_c(int data){main_sink_d(data);}void main_sink_d(int data){{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;_wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
void _main_sink(wchar_t * data){PUTENV(data);}static void main(){wchar_t * data;wchar_t data_buf[250]=L"PATH=";data=data_buf;wcscat(data, NEW_PATH);_main_sink(data);}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(data, args);va_end(args);}}static void main_sink(wchar_t * data){main_vasink(data, data);}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");main_sink(data);}
void b_main_sink();static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
void b_main_sink(char * data);static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{char src[100];memmove(data, src, 100*sizeof(char));printLine(data);}}
static wchar_t * main_source(wchar_t * data){{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}return data;}static void main(){wchar_t * data;data=NULL;data=main_source(data);{wchar_t dest[100];memcpy(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){twoints data;data.a=0;data.b=0;printStructLine(&data);}
static void main_vasinkg(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(L"%s", args);va_end(args);}}static void main_vasinkb(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(data, args);va_end(args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_f()){wcscpy(data, L"fixedstringtest");}else{wcscpy(data, L"fixedstringtest");}if(global_returns_t()){main_vasinkb(data, data);}else{main_vasinkb(data, data);}}
static void main(){char * data;data=new char[100];if(global_returns_t_or_f()){}else{}{char dest[50]="";memmove(dest, data, strlen(data)*sizeof(char));printLine(data);delete [] data;}}
static void main_sink(){wchar_t * data=_main_data;if (wcsncmp(PASSWORD, data, wcslen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;_main_data=data;main_sink();}
static void main(){twointsclass * data;data=NULL;data=(twointsclass *)malloc(100*sizeof(twointsclass));main_sink_b(data);}void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_c(twointsclass * data){free(data);}
static void main(){char data;_struct_type my_struct;data=' ';fscanf (stdin, "%c", &data);my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char data=my_struct.a;{char result=-1;if (data < CHAR_MAX){result=data+1;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){int data;data=-1;if(global_returns_t_or_f()){data=100-1;}else{data=100-1;}{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));printWLine(data);free(data);}}}
static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
void _main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_sink(data);}
static void main(){twoints * data;data=NULL;data=NULL;data=(twoints *)realloc(data, 100*sizeof(twoints));data[0].a=0;data[0].b=0;printStructLine(&data[0]);b_main_sink(data);}void b_main_sink(twoints * data){c_main_sink(data);}void c_main_sink(twoints * data){free(data);}
static void main_sink(HANDLE data){}static void main(){HANDLE data;data=CreateFile("BadSource_w32CreateFile.txt", (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);CloseHandle(data);main_sink(data);}
static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_sink(data);}void main_sink(wchar_t * data){delete [] data;}
static void main(){double * data;data=(double *)malloc(sizeof(double));printDoubleLine(*data);}
static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}{size_t i;wchar_t dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);}}
static void main_sink(){char * data=_main_data;{char dest[50]="";strncpy(dest, data, strlen(data));printLine(data);}}static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;_main_data=data;main_sink();}
static void main(){struct _twoints * data;data=NULL;{struct _twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);}b_main_sink(data);}void b_main_sink(struct _twoints * data){}
static void main(){int data;data=-1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}b_main_sink(data);}void b_main_sink(int data){{int result=-1;if (data <=(int)sqrt((int)INT_MAX)){result=data * data;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){int data;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){twoints * data;data=NULL;data=NULL;data=(twoints *)realloc(data, 100*sizeof(twoints));main_sink_b(data);}void main_sink_b(twoints * data){main_sink_c(data);}void main_sink_c(twoints * data){free(data);}
static void main_sink(char * data){_spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;strcat(data, "*.*");func_ptr(data);}
static void main(){wchar_t * data;data=NULL;data=new wchar_t;delete data;}
static void main(){int count;count=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;count=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(count);}void b_main_sink(int count){c_main_sink(count);}void c_main_sink(int count){d_main_sink(count);}void d_main_sink(int count){{size_t i=0;FILE *file=NULL;const char *filename="output_good.txt";if (count > 0 && count <=20){file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}}
static void main_sink(int data){{int result=-1;if (data < INT_MAX){result=data+1;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=INT_MAX;func_ptr(data);}
static void main(){twoints * data;data=NULL;{twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine(&data[0]);}b_main_sink(data);}void b_main_sink(twoints * data){c_main_sink(data);}void c_main_sink(twoints * data){d_main_sink(data);}void d_main_sink(twoints * data){e_main_sink(data);}void e_main_sink(twoints * data){}
static void main(){unsigned int data;data=0;data=5;b_main_sink(data);}void b_main_sink(unsigned int data){{unsigned int result=data-1;printUnsignedLine(result);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");{char * data_copy=data;char * data=data_copy;fprintf(stdout, data);}}
void b_main_sink(_struct_type my_struct);static void main(){void * data;_struct_type my_struct;twoints data_goodbuf;int data_badbuf=100;data_goodbuf.a=0;data_goodbuf.b=0;data=&data_goodbuf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){void * data=my_struct.a;printStructLine((twoints *)data);}
static void main(){double * data;data=(double *)malloc(sizeof(double));b_main_sink(&data);}void b_main_sink(double * * data_ptr){double * data=*data_ptr;printDoubleLine(*data);}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{wchar_t src[100];wcsncpy(data, src, 100);data[100-1]=L'\0';printWLine(data);}}
static void main(){int data;data=-1;main_source(data);{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}void main_source(int &data){data=RAND32();}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];data=(wchar_t *)malloc(100*sizeof(wchar_t));data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t dest[50]=L"";memmove(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);free(data);}}
void b_main_sink(short data);static void main(){short data;data=-1;data=CHAR_MAX-5;b_main_sink(data);}void c_main_sink(short data);void b_main_sink(short data){c_main_sink(data);}void c_main_sink(short data){{char c=(char)data;printHexCharLine(c);}}
static void main(){{HANDLE hMutex=NULL;hMutex=CreateMutexA(NULL, FALSE, NULL);if (hMutex==NULL){exit(1);}if (GetLastError()==ERROR_ALREADY_EXISTS){exit(1);}CloseHandle(hMutex);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(data);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(data, args);va_end(args);}}void b_main_sink(wchar_t * data){main_vasink(data, data);}
void main_sink();static void main(){long long * data;data=NULL;data=new long long[100];_main_data=data;main_sink();}void main_sink(){long long * data=_main_data;{memmove(data, src, 100*sizeof(long long));printLongLongLine(data[0]);delete [] data;}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){if (strstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
static void main(){int data;_struct_type my_struct;data=10;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){char data;data=' ';data=5;b_main_sink(data);}void b_main_sink(char data){c_main_sink(data);}void c_main_sink(char data){{char result=data * 2;printHexCharLine(result);}}
static void main(){int * data;void (*func_ptr) (int *)=main_sink;data=NULL;data=(int *)malloc(100*sizeof(int));func_ptr(data);}void main_sink(int * data){free(data);}
static void main(){twointsclass * data;twointsclass * *data_ptr1=&data;twointsclass * *data_ptr2=&data;data=NULL;{twointsclass * data=*data_ptr1;data=NULL;data=(twointsclass *)realloc(data, 100*sizeof(twointsclass));}{twointsclass * data=*data_ptr2;free(data);}}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;func_ptr(data);}void b_main_sink(char * data){{char src[100];memcpy(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;wcscpy(data, L"C:\\Windows\\System32\\winsrv.dll");}{wchar_t * data=*data_ptr2;{HMODULE hModule;hModule=LoadLibraryW(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}}
static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");{FILE *pipe;pipe=POPEN(data, "wb");if (pipe!=NULL) PCLOSE(pipe);}}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;if(global_returns_t_or_f()){wcscat(data, L"file.txt");}else{wcscat(data, L"file.txt");}{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main_sink(wchar_t * data){wprintf(L"%s\n", data);}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=NULL;data=L"Good";func_ptr(data);}
static void main_sink(int data){{wchar_t data_buf[10]=L"AAAAAAAAA";if (data >=0){printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}static void main(){int data;data=7;main_sink(data);}
static void main(){twoints * data;data=(twoints *)realloc(data, 100);if (data!=NULL){data[0].a=1;data[0].b=1;printStructLine(&data[0]);free(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);if (wcsncmp(PASSWORD, data, wcslen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){char * data;data=NULL;data=new char;printHexCharLine(*data);main_sink(&data);}void main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);delete data;}
static void main(){char data;_struct_type my_struct;data=' ';data=CHAR_MIN;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char data=my_struct.a;{char result=0;if (data > CHAR_MIN){result=data-1;printHexCharLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static void main(){int data;data=-1;data=20;_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{char * char_string;if (data > 0){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than 0");}}}
static char * main_source(char * data){data=PASSWORD;return data;}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){char * data;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]='\0';printLine(data);}}
static void main(){unsigned int data;data=0;data=5;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){unsigned int * data_ptr=(unsigned int *)void_data_ptr;unsigned int data=(*data_ptr);{unsigned int result=data-1;printUnsignedLine(result);}}
static void main_vasinkb(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}static void main_vasinkg(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, L"%s", args);va_end(args);printWLine(dest);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_t_or_f()){{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}}else{{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}}if(global_returns_t_or_f()){main_vasinkg(data, data);}else{main_vasinkg(data, data);}}
static void main_sink(int data){{int result=-1;if (data < INT_MAX){result=data+1;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}static void main(){int data;data=-1;data=RAND32();main_sink(data);}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}
static void main(){wchar_t * data;data=NULL;{wchar_t mystring[]=L"mystring";data=wcsdup(mystring);}main_sink_b(data);}void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_d(wchar_t * data){main_sink_e(data);}void main_sink_e(wchar_t * data){free(data);}
static char * main_source(char * data){strcpy(data, "fixedstringtest");return data;}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);fprintf(stdout, data);}
static void main(){{wchar_t * data=SRC_STR;wchar_t dst[100]=L"";wchar_t * end=wcschr(data, L'/');memmove(dst, data, sizeof(wchar_t)*(end-data));printWLine(dst);}}
static void main(){wchar_t * data;wchar_t data_buf[250]=L"PATH=";data=data_buf;wcscat(data, NEW_PATH);PUTENV(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(short data);static void main(){short data;data=-1;data=CHAR_MAX-5;b_main_sink(data);}void c_main_sink(short data);void b_main_sink(short data){c_main_sink(data);}void c_main_sink(short data){{char c=(char)data;printHexCharLine(c);}}
void main_source(wchar_t * &data);static void main(){wchar_t * data;data=NULL;main_source(data);{wchar_t dest[100];wcscpy(dest, data);printWLine(dest);}}void main_source(wchar_t * &data){{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}}
static void main(){int data;fscanf (stdin, "%d", &data);b_main_sink(data);}void b_main_sink(int data){{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){{long long * data=(long long *)malloc(100*sizeof(long long));long long * tmp;data[0]=5L;printLongLongLine(data[0]);tmp=(long long *)realloc(data, (130000)*sizeof(long long));if (tmp!=NULL){data=tmp;data[0]=10L;printLongLongLine(data[0]);}free(data);}}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;data=b_main_source(data);{wchar_t src[100];wcscat(data, src);printWLine(data);}}wchar_t * b_main_source(wchar_t * data){return data;}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;{char * data=*data_ptr1;data=(char *)calloc(100, sizeof(char));}{char * data=*data_ptr2;if (data!=NULL){strcpy(data, "Initialize");printLine(data);free(data);}}}
void b_main_sink(void * void_data_ptr);static void main(){FILE * data;data=NULL;data=WFOPEN(L"file.txt", L"w+");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){FILE * * data_ptr=(FILE * *)void_data_ptr;FILE * data=(*data_ptr);if (data!=NULL){fclose(data);}}
void main_sink(long long * * data);static void main(){long long * data;{long long * data_buf=new long long[100];{size_t i;for (i=0;i < 100;i++){data_buf[i]=5L;}}data=data_buf;}main_sink(&data);}void main_sink(long long * * data_ptr){long long * data=*data_ptr;printLongLongLine(data[0]);delete [] data;}
void b_main_sink();static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){wchar_t * data;data=new wchar_t[100];if(global_returns_t_or_f()){}else{}{wchar_t dest[50]=L"";memmove(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);delete [] data;}}
static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];if(global_returns_t_or_f()){data=data_goodbuf;}else{data=data_goodbuf;}{char src[100];strcpy(data, src);printLine(data);}}
static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;{char dest[50]="";strcpy(dest, data);printLine(data);}}
static void main_sink(char * data){}static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;data=new char[100];memset(data, 'A', 100-1);data[100-1]='\0';delete [] data;func_ptr(data);}
static void main(){short data;data=0;if(global_returns_t_or_f()){data=100-1;}else{data=100-1;}{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));if(global_returns_t_or_f()){data=data_goodbuf;}else{data=data_goodbuf;}{wchar_t dest[100];wmemset(dest, L'C', 100-1);memmove(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){wchar_t * data;data=NULL;{wchar_t mystring[]=L"mystring";data=wcsdup(mystring);}main_sink_b(data);}void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_d(wchar_t * data){free(data);}
static void main(){wchar_t * data;_union_type my_union;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;my_union.a=data;{wchar_t * data=my_union.b;{wchar_t src[100];wcsncpy(data, src, 100);printWLine(data);}}}
static void main(){twointsclass * data;union_type my_union;data=NULL;data=(twointsclass *)malloc(100*sizeof(twointsclass));my_union.a=data;{twointsclass * data=my_union.b;free(data);}}
static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=20;func_ptr(data);}void main_sink(int data){{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;data=(char *)malloc(100*sizeof(char));data[0]='\0';{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}func_ptr(data);}void b_main_sink(char * data){{size_t i;for (i=0;i < strlen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}
void main_sink(twointsclass * data);static void main(){twointsclass * data;void (*func_ptr) (twointsclass *)=main_sink;data=NULL;data=new twointsclass[100];func_ptr(data);}void main_sink(twointsclass * data){{twointsclass src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memmove(data, src, 100*sizeof(twointsclass));printIntLine(data[0].a);delete [] data;}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}void e_main_sink(wchar_t * data){main_vasink(data, data);}
static void main(){unsigned char data;unsigned char data_array[5];data=' ';data=(unsigned char)rand();data_array[2]=data;b_main_sink(data_array);}void b_main_sink(unsigned char data_array[]){unsigned char data=data_array[2];{unsigned char result=-1;if (data <=(unsigned char)sqrt((unsigned char)UCHAR_MAX)){result=data * data;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char dest[100];strcpy(dest, data);printLine(dest);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;wprintf(L"%s\n", data);}
static void main(){char * data;data=NULL;data=(char *)calloc(100, sizeof(char));main_sink(&data);}void main_sink(char * * data_ptr){char * data=*data_ptr;free(data);}
static void main(){wchar_t * data;data=NULL;if(global_returns_t_or_f()){{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}}else{{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}}{wchar_t src[100];wcscpy(data, src);printWLine(data);}}
static void main(){int data;data=-1;data=OPEN("BadSource_open.txt", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);{int data_copy=data;int data=data_copy;if (data!=-1){CLOSE(data);}}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;data->a=1;data->b=2;main_sink(&data);}void main_sink(void * void_data_ptr){twointsclass * * data_ptr=(twointsclass * *)void_data_ptr;twointsclass * data=(*data_ptr);printIntLine(data->a);}
static void main(){int data;data=-1;if(global_returns_t_or_f()){data=7;}else{data=7;}printIntLine(100 % data);}
void b_main_sink(int data);static void main(){int data;data=-1;data=100-1;b_main_sink(data);}void b_main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
void main_sink();static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];_main_data=data;main_sink();}void main_sink(){wchar_t * data=_main_data;{wchar_t dest[100];wmemset(dest, L'C', 100-1);memmove(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);delete [] data;}}
static void main(){unsigned int data;data=0;data=5;{unsigned int result=data-1;printUnsignedLine(result);}}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, GOOD_OS_COMMAND);data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}
void b_main_sink(int * * data);static void main(){int * data;{int * data_buf=(int *)malloc(100*sizeof(int));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}b_main_sink(&data);}void b_main_sink(int * * data_ptr){int * data=*data_ptr;printIntLine(data[0]);free(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(data);}void b_main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main_vasinkg(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, L"%s", args);va_end(args);}}static void main_vasinkb(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, data, args);va_end(args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_f()){wcscpy(data, L"fixedstringtest");}else{wcscpy(data, L"fixedstringtest");}if(global_returns_t()){main_vasinkb(data, data);}else{main_vasinkb(data, data);}}
void b_main_sink(FILE * data);static void main(){FILE * data;data=NULL;data=fopen("file.txt", "w+");b_main_sink(data);}void c_main_sink(FILE * data);void b_main_sink(FILE * data){c_main_sink(data);}void c_main_sink(FILE * data){if (data!=NULL){fclose(data);}}
static void main_sink(int data){{int result=data * 2;printIntLine(result);}}static void main(){int data;data=-1;data=5;main_sink(data);}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));free(data);b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);}
static void main(){int * data;data=NULL;data=(int *)malloc(100*sizeof(int));{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printIntLine(data[0]);free(data);}}}
static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}my_struct.a=data;b_main_sink(my_struct);}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, "%s", args);va_end(args);}}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;main_vasink(data, data);}
static void main(){unsigned int data;data=0;data=5;{unsigned int result=data-1;printUnsignedLine(result);}}
static void main(){twoints * data;data=NULL;{twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine(&data[0]);}main_sink_b(data);}void main_sink_b(twoints * data){main_sink_c(data);}void main_sink_c(twoints * data){}
static void main(){char * data;data=NULL;data=new char;delete data;}
void _main_sink(int data){{char c=(char)data;printHexCharLine(c);}}static void main(){int data;data=-1;data=CHAR_MAX-5;_main_sink(data);}
static void main(){int data;data=b_main_source(data);{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}int b_main_source(int data){{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}return data;}
static void main_sink(wchar_t * data){}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=NULL;{wchar_t data_goodbuf[100];data=data_goodbuf;wcscpy(data, L"A String");printWLine(data);}func_ptr(data);}
static void main(){if(global_returns_t_or_f()){{wchar_t * pipeName=L"\\\\.\\pipe\\mypipe";HANDLE hPipe=INVALID_HANDLE_VALUE;hPipe=CreateNamedPipeW( pipeName, FILE_FLAG_FIRST_PIPE_INSTANCE, PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, BUFSIZE, BUFSIZE, NMPWAIT_USE_DEFAULT_WAIT, NULL);if (hPipe==INVALID_HANDLE_VALUE){exit(1);}if (GetLastError()==ERROR_ACCESS_DENIED){exit(1);}if (!ImpersonateNamedPipeClient(hPipe)){exit(1);}CloseHandle(hPipe);}}else{{wchar_t * pipeName=L"\\\\.\\pipe\\mypipe";HANDLE hPipe=INVALID_HANDLE_VALUE;hPipe=CreateNamedPipeW( pipeName, FILE_FLAG_FIRST_PIPE_INSTANCE, PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, BUFSIZE, BUFSIZE, NMPWAIT_USE_DEFAULT_WAIT, NULL);if (hPipe==INVALID_HANDLE_VALUE){exit(1);}if (GetLastError()==ERROR_ACCESS_DENIED){exit(1);}if (!ImpersonateNamedPipeClient(hPipe)){exit(1);}CloseHandle(hPipe);}}}
static void main(){int count;count=-1;count=20;b_main_sink(&count);}void b_main_sink(int * count_ptr){int count=*count_ptr;{size_t i=0;FILE *file=NULL;const char *filename="output_bad.txt";file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}
static void main(){if(global_returns_t_or_f()){{try{throw 25;}catch (int e){printLine("Exception caught-value: ");printIntLine(e);}}}else{{try{throw 25;}catch (int e){printLine("Exception caught-value: ");printIntLine(e);}}}}
static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, data, args);va_end(args);printLine(dest);}}static void main(){char * data;void (*func_ptr) (char *, ...)=main_vasink;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");func_ptr(data);}
static void main(){int data;data=-1;fscanf (stdin, "%d", &data);b_main_sink(data);}void b_main_sink(int data){{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=20;func_ptr(data);}void main_sink(int data){{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}
static void main_sink(){wchar_t * data=main_data;printWcharLine(*data);}static void main(){wchar_t * data;data=NULL;data=new wchar_t;main_data=data;main_sink();}
static void main_sink(){wchar_t * data=main_data;delete [] data;}static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_data=data;main_sink();}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);wprintf(data);}wchar_t * b_main_source(wchar_t * data){wcscpy(data, L"fixedstringtest");return data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);if (wcsncmp(PASSWORD, data, wcslen(data))==0) printLine("Access granted");else printLine("Access denied!");}wchar_t * b_main_source(wchar_t * data){data=PASSWORD;return data;}
static void main_sink(){wchar_t * data=_main_data;if (wcsncmp(PASSWORD, data, wcslen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;_main_data=data;main_sink();}
static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;if(global_returns_t_or_f()){strcat(data, "*.*");}else{strcat(data, "*.*");}system(data);}
static void main(){int * data;data=NULL;data=new int;main_sink(&data);}void main_sink(void * void_data_ptr){int * * data_ptr=(int * *)void_data_ptr;int * data=(*data_ptr);delete data;}
static void main(){int data;data=-1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}main_sink(&data);}void main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){int * data;int data_uninit_array[10];data=data_uninit_array;{int i;for(i=0;i<10;i++){data[i]=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}}
static void main_sink(){char * data=_main_data;printLine(data);free(data);}static void main(){char * data;{char * data_buf=(char *)malloc(100*sizeof(char));data=data_buf;}_main_data=data;main_sink();}
static void main_sink(wchar_t * data){free(data);}static void main(){wchar_t * data;data=NULL;data=NULL;data=(wchar_t *)realloc(data, 100*sizeof(wchar_t));main_sink(data);}
void b_main_sink(char * data);static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{char src[100];strncpy(data, src, 100);printLine(data);free(data);}}
void _main_sink(char * data){{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");_main_sink(data);}
void main_source(char * &data);static void main(){char * data;data=NULL;main_source(data);{char src[100];strcpy(data, src);printLine(data);delete [] data;}}void main_source(char * &data){data=new char[100];}
void b_main_sink(char * data);static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;b_main_sink(data);}void b_main_sink(char * data){{char src[100];strcpy(data, src);printLine(data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(char * data){if (strstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
static void main(){int data;data=7;_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
void main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_sink(data);}void main_sink(wchar_t * data){{size_t i, dest_sz;wchar_t dest[100];wmemset(dest, L'C', 100-1);dest_sz=wcslen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);delete [] data;}}
static void main_sink(){int * data=main_data;delete [] data;}static void main(){int * data;data=NULL;data=new int[100];main_data=data;main_sink();}
static void main(){int data;data=-1;data=5;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){{int result=data+1;printIntLine(result);}}
void b_main_sink();static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{wchar_t dest[100];wmemset(dest, L'C', 100-1);memmove(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
static void main(){long long * data;void (*func_ptr) (long long *)=main_sink;data=NULL;data=NULL;data=(long long *)realloc(data, 100*sizeof(long long));func_ptr(data);}void main_sink(long long * data){free(data);}
static void main(){int data;data=-1;data=5;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{int result=data * data;printIntLine(result);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){if (wcsncmp(PASSWORD, data, wcslen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){char data;char *data_ptr1=&data;char *data_ptr2=&data;data=' ';{char data=*data_ptr1;fscanf (stdin, "%c", &data);}{char data=*data_ptr2;{char result=0;if (data > CHAR_MIN){result=data-1;printHexCharLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}}
void b_main_sink(long long * data);static void main(){long long * data;long long data_badbuf[50];long long data_goodbuf[100];data=data_goodbuf;b_main_sink(data);}void c_main_sink(long long * data);void b_main_sink(long long * data){c_main_sink(data);}void c_main_sink(long long * data){{memcpy(data, src, 100*sizeof(long long));printLongLongLine(data[0]);}}
static void main_sink(){bad_struct data=_main_data;* */prev=data.list.prev;next=data.list.next;prev->next=next;next->prev=prev;}static void main(){bad_struct data;linked_list head={&head, &head};data.list.next=head.next;data.list.prev=&head;head.next=&data.list;head.next->prev=&data.list;_main_data=data;main_sink();}
void b_main_sink(int data);static void main(){int data;data=-1;data=100-1;b_main_sink(data);}void b_main_sink(int data){{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t dest[50]=L"";wcscat(dest, data);printWLine(data);free(data);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, data);printWLine(dest);}}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){wchar_t * data;data=NULL;data=NULL;data=(wchar_t *)realloc(data, 100*sizeof(wchar_t));main_sink_b(data);}void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_d(wchar_t * data){main_sink_e(data);}void main_sink_e(wchar_t * data){free(data);}
static void main(){int data;data=-1;data=5;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{int result=data * 2;printIntLine(result);}}
static void main_sink(unsigned char data){{unsigned char result=data+1;printHexUnsignedCharLine(result);}}static void main(){unsigned char data;data=' ';data=5;main_sink(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;data="P";b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static int * main_source(int * data){data=new int[100];{size_t i;for(i=0;i < 100;i++){data[i]=5;}}return data;}static void main(){int * data;data=NULL;data=main_source(data);printIntLine(data[0]);}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100];data=data_buf;b_main_sink(data);}void b_main_sink(char * data){{char dest[50]="";memcpy(dest, data, strlen(data)*sizeof(char));printLine(data);}}
void main_sink(char * data){{char src[100];strcpy(data, src);printLine(data);}}static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}main_sink(data);}
static void main(){int * data;data=NULL;data=(int *)malloc(100*sizeof(int));free(data);b_main_sink(data);}void b_main_sink(int * data){}
static void main(){twoints * data;data=NULL;data=main_source(data);delete [] data;}twoints * main_source(twoints * data){data=new twoints[100];return data;}
static void main(){int * data;data=NULL;data=(int *)malloc(100*sizeof(int));data[0]=5;printIntLine(data[0]);free(data);}
void b_main_sink(char * data);static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;b_main_sink(data);}void b_main_sink(char * data){{char dest[50]="";size_t i, data_len;data_len=strlen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printLine(data);}}
static void main(){{char data_buf[100]="";char * data=data_buf;if (sscanf(SRC, "%99s\0", data)==EOF){printLine("sscanf failed!");}}}
static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=-1;data=5;func_ptr(data);}void b_main_sink(int data){{int result=data+1;printIntLine(result);}}
static void main(){twoints * data;data=NULL;data=new twoints;delete data;main_sink_b(data);}void main_sink_b(twoints * data){main_sink_c(data);}void main_sink_c(twoints * data){main_sink_d(data);}void main_sink_d(twoints * data){}
static void main(){int * data;int data_badbuf[50];int data_goodbuf[100];data=data_goodbuf;{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printIntLine(data[0]);}}}
void b_main_sink();static void main(){char * data;data=(char *)malloc(100*sizeof(char));_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{char dest[50]="";strcpy(dest, data);printLine(data);free(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");_wsystem(data);}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");my_union.a=data;{wchar_t * data=my_union.b;{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, data);printWLine(dest);}}}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];_wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t dest[50]=L"";wcsncat(dest, data, wcslen(data));printWLine(data);}}}
static void main(){int * data;data=NULL;data=NULL;data=(int *)realloc(data, 100*sizeof(int));data[0]=5;printIntLine(data[0]);b_main_sink(data);}void b_main_sink(int * data){c_main_sink(data);}void c_main_sink(int * data){d_main_sink(data);}void d_main_sink(int * data){free(data);}
static void main(){int * data;_struct_type my_struct;data=NULL;data=(int *)malloc(100*sizeof(int));my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int * data=my_struct.a;free(data);}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{char src[100];strcpy(data, src);printLine(data);}}
static void main(){wchar_t * data;if(global_returns_t_or_f()){data=L"string";}else{data=L"string";}if(global_returns_t_or_f()){printWLine(data);}else{printWLine(data);}}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main_sink(char * data){delete [] data;}static void main(){char * data;data=NULL;data=new char[100];main_sink(data);}
static void main(){twoints * data;data=NULL;data=main_source(data);delete data;}twoints * main_source(twoints * data){data=new twoints;return data;}
void b_main_sink(void * void_data_ptr);static void main(){twoints * data;data=(twoints *)calloc(100, sizeof(twoints));b_main_sink(&data);}void b_main_sink(void * void_data_ptr){twoints * * data_ptr=(twoints * *)void_data_ptr;twoints * data=(*data_ptr);if (data!=NULL){data[0].a=1;data[0].b=1;printStructLine(&data[0]);free(data);}}
static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}my_struct.a=data;b_main_sink(my_struct);}static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, "%s", args);va_end(args);printLine(dest);}}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;main_vasink(data, data);}
static void main_sink(){wchar_t * data=main_data;}static void main(){wchar_t * data;data=NULL;data=new wchar_t;delete data;main_data=data;main_sink();}
static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));free(data);b_main_sink(data);}void b_main_sink(long long * data){c_main_sink(data);}void c_main_sink(long long * data){d_main_sink(data);}void d_main_sink(long long * data){}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{int i, n, v;if (swscanf(data, L"%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static void main_source(twointsclass * &data){for(int i=0;i<10;i++){data[i].a=i;data[i].b=i;}}static void main(){twointsclass * data;data=new twointsclass[10];main_source(data);for(int i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");my_struct.a=data;b_main_sink(my_struct);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, data, args);va_end(args);}}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;main_vasink(data, data);}
void b_main_sink(char * data);static void main(){char * data;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{char src[100];strcpy(data, src);printLine(data);}}
void main_sink(struct_type my_struct);static void main(){twointsclass * data;struct_type my_struct;data=NULL;data=new twointsclass[100];my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){twointsclass * data=my_struct.a;{twointsclass src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printIntLine(data[0].a);delete [] data;}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void b_main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;printf(data);}
char * b_main_source(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;data=b_main_source(data);{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}char * b_main_source(char * data){strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");return data;}
static void main(){long long * data;data=NULL;data=new long long[100];{size_t i;for(i=0;i < 100;i++){data[i]=5L;}}delete [] data;main_sink(&data);}void main_sink(long long * * data_ptr){long long * data=*data_ptr;}
void b_main_sink(char * data);static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{char dest[100];memmove(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
static void main(){wchar_t * data;data=NULL;wchar_t data_good;data=&data_good;printHexCharLine((char)*data);{wchar_t * data_copy=data;wchar_t * data=data_copy;}}
static void main(){unsigned int data;data=0;data=5;_main_data=data;b_main_sink();}void b_main_sink(){unsigned int data=_main_data;{unsigned int result=data * 2;printUnsignedLine(result);}}
static void main(){unsigned int data;data=0;if(global_returns_t_or_f()){data=5;}else{data=5;}if(global_returns_t_or_f()){{unsigned int result=data * data;printUnsignedLine(result);}}else{{unsigned int result=data * data;printUnsignedLine(result);}}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=NULL;{char * data=*data_ptr1;data=new char;delete data;}{char * data=*data_ptr2;}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_t_or_f()){data=L"P";}else{data=L"P";}if(global_returns_t_or_f()){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}else{if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}wchar_t * b_main_source(wchar_t * data){wcscat(data, L"*.*");return data;}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];main_sink(&data);}void main_sink(twointsclass * * data_ptr){twointsclass * data=*data_ptr;delete [] data;}
void b_main_sink(wchar_t * password);static void main(){wchar_t * password;wchar_t password_buf[100]=L"";password=password_buf;{size_t password_len=0;fgetws(password, 100, stdin);password_len=wcslen(password);if (password_len > 0){password[password_len-1]=L'\0';}}b_main_sink(password);}void c_main_sink(wchar_t * password);void b_main_sink(wchar_t * password){c_main_sink(password);}void d_main_sink(wchar_t * password);void c_main_sink(wchar_t * password){d_main_sink(password);}void d_main_sink(wchar_t * password){{HANDLE pHandle;wchar_t * username=L"User";wchar_t * domain=L"Domain";if (LogonUserW( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)calloc(100, sizeof(wchar_t));free(data);}
static void main_sink(char * data){{size_t i, dest_sz;char dest[100];memset(dest, 'C', 100-1);dest_sz=strlen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);free(data);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;data=(char *)malloc(100*sizeof(char));func_ptr(data);}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(int data){{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than the length of the source string or too large");}}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;data=NULL;data="Good";my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;printf("%s\n", data);}
void main_sink();static void main(){int data;data=-1;data=20;_main_data=data;main_sink();}void main_sink(){int data=_main_data;{size_t a,i;int *b;b=(int*)new char[a];for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);delete [] b;}}
static void main(){struct _twoints * data;data=NULL;data=new struct _twoints[100];data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);main_sink(&data);}void main_sink(struct _twoints * * data_ptr){struct _twoints * data=*data_ptr;delete[] data;}
static void main(){char data;data=' ';data=5;b_main_sink(data);}void b_main_sink(char data){c_main_sink(data);}void c_main_sink(char data){{char result=data * 2;printHexCharLine(result);}}
static wchar_t * main_source(wchar_t * data){{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}return data;}static void main(){wchar_t * data;data=NULL;data=main_source(data);{wchar_t dest[100];wcsncpy(dest, data, wcslen(dest));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));main_sink(data);}void main_sink(wchar_t * data){free(data);}
void b_main_sink();static void main(){char data;data=' ';data='a';_main_data=data;b_main_sink();}void b_main_sink(){char data=_main_data;{char char_array[4];char_array[0]='x';char_array[1]=data;char_array[2]='z';char_array[3]='\0';printLine(char_array);}}
static void main(){int * data;data=NULL;if(global_returns_t_or_f()){data=new int[100];}else{data=new int[100];}if(global_returns_t_or_f()){delete [] data;}else{delete [] data;}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t;main_sink_b(data);}void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){delete data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");_wsystem(data);}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;data=(wchar_t *)calloc(100, sizeof(wchar_t));b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;if (data!=NULL){wcscpy(data, L"Initialize");printWLine(data);free(data);}}
static int main_source(int data){data=CHAR_MAX-5;return data;}static void main(){int data;data=-1;data=main_source(data);{char c=(char)data;printHexCharLine(c);}}
void b_main_sink();static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{size_t i, dest_sz;wchar_t dest[100];wmemset(dest, L'C', 100-1);dest_sz=wcslen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);}}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
static void main(){int * data;int * *data_ptr1=&data;int * *data_ptr2=&data;{int * data=*data_ptr1;{int * data_buf=(int *)malloc(100*sizeof(int));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}}{int * data=*data_ptr2;printIntLine(data[0]);free(data);}}
static void main(){long long * data;struct_type my_struct;data=NULL;data=NULL;data=(long long *)realloc(data, 100*sizeof(long long));my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){long long * data=my_struct.a;free(data);}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;{char * data=*data_ptr1;{char * data_buf=(char *)malloc(100*sizeof(char));data=data_buf;}}{char * data=*data_ptr2;printLine(data);free(data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){unsigned int data;data=0;data=b_main_source(data);{unsigned int result=-1;if (data <=(UINT_MAX/2)){result=data * 2;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}unsigned int b_main_source(unsigned int data){data=(unsigned int)RAND32();return data;}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
void b_main_sink();static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}
static void main(){int * data;struct_type my_struct;data=NULL;data=(int *)calloc(100, sizeof(int));my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){int * data=my_struct.a;free(data);}
static void main(){wchar_t * data;data=NULL;if(global_returns_t_or_f()){data=new wchar_t[100];wcscpy(data, L"A String");printWLine(data);}else{data=new wchar_t[100];wcscpy(data, L"A String");printWLine(data);}if(global_returns_t_or_f()){delete[] data;}else{delete[] data;}}
void b_main_sink(void * void_data_ptr);static void main(){long long * data;long long data_badbuf[50];long long data_goodbuf[100];data=data_goodbuf;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){long long * * data_ptr=(long long * *)void_data_ptr;long long * data=(*data_ptr);{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printLongLongLine(data[0]);}}}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;wprintf(data);}
void b_main_sink(short data);static void main(){short data;data=0;data=100-1;b_main_sink(data);}void b_main_sink(short data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
static void main(){int data;data=-1;data=5;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){{int result=data+1;printIntLine(result);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");fwprintf(stdout, data);}
void b_main_sink();static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';{wchar_t * data=*data_ptr1;data=data_buf;}{wchar_t * data=*data_ptr2;{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnvp(_P_WAIT, COMMAND_INT, args);}}
static void main_sink(){wchar_t * data=_main_data;fwprintf(stdout, L"%s\n", data);}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}_main_data=data;main_sink();}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]="";data=data_buf;{char * data=*data_ptr1;strcpy(data, "fixedstringtest");}{char * data=*data_ptr2;main_vasink(data, data);}}
static void main_source(wchar_t * &data){data=new wchar_t;printHexCharLine((char)*data);}static void main(){wchar_t * data;data=NULL;main_source(data);delete data;}
void b_main_sink(short data_array[]);static void main(){short data;short data_array[5];data=-1;data=CHAR_MAX-5;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(short data_array[]){short data=data_array[2];{char c=(char)data;printHexCharLine(c);}}
void main_sink(char * data);static void main(){char * data;data=new char[100];main_sink(data);}void main_sink(char * data){{char dest[50]="";_snprintf(dest, strlen(data), "%s", data);printLine(data);delete [] data;}}
static void main(){int data;data=-1;data=5;_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{int result=data * data;printIntLine(result);}}
static void main(){short data;data=0;data=100-1;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
static void main(){twoints * data;data=NULL;data=new twoints;delete data;}
static void main_sink(){twoints * data=main_data;}static void main(){twoints * data;data=NULL;{twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine(&data[0]);}main_data=data;main_sink();}
static void main(){twoints * data;data=NULL;data=new twoints[100];main_sink(data);}void main_sink(twoints * data){delete [] data;}
static void main(){int data;fscanf (stdin, "%d", &data);{int data_copy=data;int data=data_copy;{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}}
static void main(){char * data;data=NULL;{char data_goodbuf[100];data=data_goodbuf;strcpy(data, "A String");printLine(data);}b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;}
void main_sink_b(char * data);static void main(){char * data;data=NULL;data=new char[100];main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){{char src[100];memmove(data, src, 100*sizeof(char));printLine(data);delete [] data;}}
static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;if(global_returns_t_or_f()){strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");}else{strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");}{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main_vasinkb(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, data, args);va_end(args);}}static void main_vasinkg(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, L"%s", args);va_end(args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}main_vasinkg(data, data);}
void b_main_sink(twoints * data);static void main(){twoints * data;void (*func_ptr) (twoints *)=b_main_sink;twoints * data_badbuf=(twoints *)ALLOCA(50*sizeof(twoints));twoints * data_goodbuf=(twoints *)ALLOCA(100*sizeof(twoints));data=data_goodbuf;func_ptr(data);}void b_main_sink(twoints * data){{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memmove(data, src, 100*sizeof(twoints));printStructLine(&data[0]);}}
static void main(){int data;int data_array[5];data=-1;data=5;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{int result=data * data;printIntLine(result);}}
static void main(){wchar_t * data;wchar_t * &data_ref=data;data=NULL;data=new wchar_t[100];{wchar_t * data=data_ref;{wchar_t src[100];wcsncat(data, src, 100);printWLine(data);delete [] data;}}}
static void main(){unsigned int data;data=0;data=5;b_main_sink(data);}void b_main_sink(unsigned int data){{unsigned int result=data * 2;printUnsignedLine(result);}}
void _main_sink(char * data){_spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_main_sink(data);}
static void main(){int data;int data_array[5];{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){twoints * data;{twoints * data_buf=(twoints *)malloc(100*sizeof(twoints));{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}printStructLine(&data[0]);free(data);}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"15");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main(){int data;data=-1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){{int result=-1;if (data <=(int)sqrt((int)INT_MAX)){result=data * data;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){twoints * data;union_type my_union;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));my_union.a=data;{twoints * data=my_union.b;free(data);}}
void main_sink();static void main(){int * data;data=NULL;data=new int[100];_main_data=data;main_sink();}void main_sink(){int * data=_main_data;{memcpy(data, src, 100*sizeof(int));printIntLine(data[0]);delete [] data;}}
static void main(){twointsclass * data;twointsclass * *data_ptr1=&data;twointsclass * *data_ptr2=&data;data=NULL;{twointsclass * data=*data_ptr1;data=new twointsclass;}{twointsclass * data=*data_ptr2;delete data;}}
static void main(){bad_struct data;_union_type my_union;linked_list head={&head, &head};data.list.next=head.next;data.list.prev=&head;head.next=&data.list;head.next->prev=&data.list;my_union.a=data;{bad_struct data=my_union.b;* */prev=data.list.prev;next=data.list.next;prev->next=next;next->prev=prev;}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){twoints * data;twoints data_uninit_array[10];data=data_uninit_array;{int i;for(i=0;i<10;i++){data[i].a=i;data[i].b=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}}
static void main_sink(char data){{char result=data * 2;printHexCharLine(result);}}static void main(){char data;void (*func_ptr) (char)=main_sink;data=' ';data=5;func_ptr(data);}
void b_main_sink();static void main(){int * data;data=(int *)calloc(100, sizeof(int));_bad_data_for_good_sink=data;b_main_sink();}void b_main_sink(){int * data=_bad_data_for_good_sink;if (data!=NULL){data[0]=5;printIntLine(data[0]);free(data);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnvp(_P_WAIT, COMMAND_INT, args);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){long long * data;union_type my_union;data=NULL;data=new long long[100];my_union.a=data;{long long * data=my_union.b;delete [] data;}}
static void main_sink(){wchar_t * data=_main_data;{wchar_t dest[50]=L"";size_t i, data_len;data_len=wcslen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printWLine(data);}}static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;_main_data=data;main_sink();}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;data=NULL;data=(char *)malloc((10+1)*sizeof(char));func_ptr(data);}void b_main_sink(char * data){{char data_src[10+1]=SRC_STRING;strncpy(data, data_src, strlen(data_src));printLine(data);free(data);}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100];data=data_buf;{wchar_t * data=*data_ptr1;}{wchar_t * data=*data_ptr2;{wchar_t dest[50]=L"";wcscat(dest, data);printWLine(data);}}}
static void main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}func_ptr(data);}
void main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];data=NULL;data=new char[100];data_array[2]=data;main_sink(data_array);}void main_sink(char * data_array[]){char * data=data_array[2];{char dest[100];memset(dest, 'C', 100-1);memcpy(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);delete [] data;}}
static wchar_t * main_source(wchar_t * data){{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, L"%s", data);printWLine(dest);}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_sink_b(data);}void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){delete [] data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_t_or_f()){wcscat(data, L"*.*");}else{wcscat(data, L"*.*");}_wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"C:\\Windows\\System32\\winsrv.dll");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{HMODULE hModule;hModule=LoadLibraryW(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
static void main(){int * data;int * &data_ref=data;{int * data_buf=new int[100];{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}{int * data=data_ref;printIntLine(data[0]);delete [] data;}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;system(data);}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char src[100];strncpy(data, src, 100);data[100-1]='\0';printLine(data);}}
void b_main_sink(void * void_data_ptr);static void main(){int data;data=-1;data=ASSERT_VALUE+1;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);assert(data > ASSERT_VALUE);}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];main_sink_b(data);}void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_c(twointsclass * data){main_sink_d(data);}void main_sink_d(twointsclass * data){main_sink_e(data);}void main_sink_e(twointsclass * data){delete [] data;}
static void main_source(twointsclass * &data){{twointsclass * data_buf=new twointsclass[100];{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}}static void main(){twointsclass * data;main_source(data);printIntLine(data[0].a);delete [] data;}
static void main(){long long * data;_struct_type my_struct;data=NULL;{long long data_goodbuf[100];data=data_goodbuf;data[0]=5L;printLongLongLine(data[0]);}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){long long * data=my_struct.a;}
void main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];data=new char[100];data_array[2]=data;main_sink(data_array);}void main_sink(char * data_array[]){char * data=data_array[2];{char dest[50]="";memcpy(dest, data, strlen(data)*sizeof(char));printLine(data);delete [] data;}}
static void main(){char * data;data=NULL;if(global_returns_t_or_f()){{char data_goodbuf[100];data=data_goodbuf;strcpy(data, "A String");printLine(data);}}else{{char data_goodbuf[100];data=data_goodbuf;strcpy(data, "A String");printLine(data);}}if(global_returns_t_or_f()){}else{}}
static void main_sink(){int data=_main_data;assert(data > ASSERT_VALUE);}static void main(){int data;data=-1;data=ASSERT_VALUE+1;_main_data=data;main_sink();}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{wchar_t data_src[10+1]=SRC_STRING;memcpy(data, data_src, wcslen(data_src)*sizeof(wchar_t));printWLine(data);free(data);}}
static void main(){char * data;data=NULL;data=new char[100];{char * data_copy=data;char * data=data_copy;{char src[100];memcpy(data, src, 100*sizeof(char));printLine(data);delete [] data;}}}
static void main(){char * data;data=NULL;{char data_goodbuf[100];data=data_goodbuf;strcpy(data, "A String");printLine(data);}{char * data_copy=data;char * data=data_copy;}}
void b_main_sink(float * data);static void main(){float data;data=0.0F;data=7.0F;b_main_sink(&data);}void b_main_sink(float * data_ptr){float data=*data_ptr;printDoubleLine((double)(100.0/data));}
static void main(){char * data;data=NULL;{char mystring[]="mystring";data=strdup(mystring);}free(data);}
static char * main_source(char * data){strcat(data, "*.*");return data;}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);_spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){long long * data;data=NULL;main_source(data);delete [] data;}void main_source(long long * &data){data=new long long[100];}
static void main(){int * data;data=NULL;{int data_goodbuf[100];data=data_goodbuf;data[0]=5;printIntLine(data[0]);}}
static void main_sink(struct _twoints * data){delete data;}static void main(){struct _twoints * data;data=NULL;data=new struct _twoints;data->a=0;data->b=0;printStructLine((twoints *)data);main_sink(data);}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=b_main_source(data);{wchar_t data_src[10+1]=SRC_STRING;wcscpy(data, data_src);printWLine(data);free(data);}}wchar_t * b_main_source(wchar_t * data){data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));return data;}
static char * main_source(char * data){data=NULL;data=(char *)realloc(data, 100*sizeof(char));return data;}static void main(){char * data;data=NULL;data=main_source(data);free(data);}
void main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;data=new char[100];func_ptr(data);}void main_sink(char * data){{char src[100];memmove(data, src, 100*sizeof(char));printLine(data);delete [] data;}}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];_wsystem(data);}
void b_main_sink(int data);static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=-1;data=100-1;func_ptr(data);}void b_main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]="";data=data_buf;{char * data=*data_ptr1;strcat(data, "*.*");}{char * data=*data_ptr2;EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}}
static void main(){wchar_t * data;_union_type my_union;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;my_union.a=data;{wchar_t * data=my_union.b;{wchar_t dest[50]=L"";wcscpy(dest, data);printWLine(data);}}}
static void main(){int count;count=-1;fscanf (stdin, "%d", &count);b_main_sink(&count);}void b_main_sink(int * count_ptr){int count=*count_ptr;{size_t i=0;FILE *file=NULL;const char *filename="output_good.txt";if (count > 0 && count <=20){file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}}
void main_sink_b(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_sink_b(data);}void main_sink_c(wchar_t * data);void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_d(wchar_t * data);void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_e(wchar_t * data);void main_sink_d(wchar_t * data){main_sink_e(data);}void main_sink_e(wchar_t * data){{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));printWLine(data);delete [] data;}}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{wchar_t src[100];wcscpy(data, src);printWLine(data);}}
static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;free(data);}
void b_main_sink(int data);static void main(){int data;data=-1;data=OPEN("BadSource_open.txt", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void d_main_sink(int data);void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){if (data!=-1){CLOSE(data);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void b_main_sink(wchar_t * data){_wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main_sink(HANDLE data){if (data!=INVALID_HANDLE_VALUE){CloseHandle(data);}}static void main(){HANDLE data;void (*func_ptr) (HANDLE)=main_sink;data=INVALID_HANDLE_VALUE;data=CreateFile("BadSource_w32CreateFile.txt", (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);func_ptr(data);}
static void main(){twoints * data;data=NULL;data=new twoints;data->a=1;data->b=2;delete data;}
void b_main_sink();static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static int * main_source(int * data){data=(int *)malloc(100*sizeof(int));{size_t i;for(i=0;i < 100;i++){data[i]=5;}}free(data);return data;}static void main(){int * data;data=NULL;data=main_source(data);}
static void main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}func_ptr(data);}
static void main(){twointsclass * data;data=NULL;data=main_source(data);}twointsclass * main_source(twointsclass * data){data=new twointsclass[100];delete [] data;return data;}
static void main(){twoints * data;data=NULL;data=b_main_source(data);free(data);}twoints * b_main_source(twoints * data){data=(twoints *)malloc(100*sizeof(twoints));return data;}
static twoints * main_source(twoints * data){data=(twoints *)calloc(100, sizeof(twoints));return data;}static void main(){twoints * data;data=NULL;data=main_source(data);free(data);}
static void main_sink(wchar_t * data){{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;func_ptr(data);}
static void main(){char * data;data=NULL;data=new char[100];delete [] data;main_sink_b(data);}void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){main_sink_d(data);}void main_sink_d(char * data){main_sink_e(data);}void main_sink_e(char * data){}
static void main(){long long * data;data=NULL;data=main_source(data);delete [] data;}long long * main_source(long long * data){data=new long long[100];return data;}
static void main(){wchar_t * data;wchar_t * &data_ref=data;data=NULL;data=new wchar_t[100];{wchar_t * data=data_ref;delete [] data;}}
static void main_sink(int data){{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=20;func_ptr(data);}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnvp(_P_WAIT, COMMAND_INT, args);}}
static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t src[100];wcscpy(data, src);printWLine(data);}}}
static void main(){int * data;int * *data_ptr1=&data;int * *data_ptr2=&data;data=NULL;{int * data=*data_ptr1;data=new int;}{int * data=*data_ptr2;delete data;}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(char * data){{char dest[100]="";SNPRINTF(dest, 100-1, "%s", data);printLine(dest);}}
static void main_sink(wchar_t * data){free(data);}static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));main_sink(data);}
static void main(){int * data;data=(int *)malloc(sizeof(int));b_main_sink(&data);}void b_main_sink(int * * data_ptr){int * data=*data_ptr;printIntLine(*data);}
static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;wcscpy(data, L"fixedstringtest");}{wchar_t * data=*data_ptr2;main_vasink(data, data);}}
static void main(){int count;count=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;count=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(&count);}void b_main_sink(void * void_count_ptr){int * count_ptr=(int *)void_count_ptr;int count=(*count_ptr);{size_t i=0;if (count > 0 && count <=20){for (i=0;i < (size_t)count;i++){printLine("Hello");}}}}
static void main(){char * data;data=NULL;data=(char *)calloc(100, sizeof(char));main_sink_b(data);}void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){main_sink_d(data);}void main_sink_d(char * data){free(data);}
static void main(){if(global_returns_t_or_f()){{long long data;data=5L;long long * pointer=new long long;{long long data=*pointer;printLongLongLine(data);}delete pointer;}}else{{long long data;data=5L;long long * pointer=new long long;{long long data=*pointer;printLongLongLine(data);}delete pointer;}}}
static char * main_source(char * data){strcat(data, "file.txt");return data;}static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;data=main_source(data);{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{int result=-1;if (data <=(int)sqrt((int)INT_MAX)){result=data * data;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static char * main_source(char * data){{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}return data;}static void main(){char * data;data=NULL;data=main_source(data);{char dest[100];strcpy(dest, data);printLine(dest);}}
static void main(){struct _twoints * data;data=NULL;data=NULL;data=(struct _twoints *)realloc(data, 100*sizeof(struct _twoints));data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);_main_data=data;b_main_sink();}void b_main_sink(){struct _twoints * data=_main_data;free(data);}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{char dest[100];memmove(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
void main_sink_b(wchar_t * data);static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}main_sink_b(data);}void main_sink_c(wchar_t * data);void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_d(wchar_t * data);void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_e(wchar_t * data);void main_sink_d(wchar_t * data){main_sink_e(data);}void main_sink_e(wchar_t * data){{wchar_t dest[100];memcpy(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;strcat(data, "*.*");my_union.a=data;{char * data=my_union.b;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *, ...)=main_vasink;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");func_ptr(data);}
static void main(){long long * data;data=NULL;data=new long long[100];main_sink_b(data);}void main_sink_b(long long * data){main_sink_c(data);}void main_sink_c(long long * data){main_sink_d(data);}void main_sink_d(long long * data){main_sink_e(data);}void main_sink_e(long long * data){delete [] data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");fwprintf(stdout, data);}
static void main(){int data;data=-1;data=20;{int data_copy=data;int data=data_copy;{char * char_string;if (data > 0){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than 0");}}}}
static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));main_sink(&data);}void main_sink(twoints * * data_ptr){twoints * data=*data_ptr;free(data);}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));free(data);func_ptr(data);}void b_main_sink(wchar_t * data){}
void b_main_sink(char * data);static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{char src[100];strncat(data, src, 100);printLine(data);}}
static wchar_t * main_source(wchar_t * data){data=(wchar_t *)malloc(100*sizeof(wchar_t));return data;}static void main(){wchar_t * data;data=NULL;data=main_source(data);{wchar_t dest[100];wmemset(dest, L'C', 100-1);memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);free(data);}}
static void main(){int data;data=-1;data=5;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{int result=data-1;printIntLine(result);}}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
static void main(){char data;data=' ';data=CHAR_MAX;{char data_copy=data;char data=data_copy;{char result=-1;if (data <=(char)sqrt((char)CHAR_MAX)){result=data * data;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t dest[100];memmove(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){int data;data=-1;data=100-1;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
static void main_sink(int count){{size_t i=0;if (count > 0 && count <=20){for (i=0;i < (size_t)count;i++){printLine("Hello");}}}}static void main(){int count;void (*func_ptr) (int)=main_sink;count=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;count=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}func_ptr(count);}
static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=7;func_ptr(data);}void b_main_sink(int data){{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main(){wchar_t * data;_struct_type my_struct;data=NULL;data=NULL;data=(wchar_t *)realloc(data, 100*sizeof(wchar_t));wcscpy(data, L"A String");printWLine(data);my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;free(data);}
static void main(){char * data;char data_buf[100];data=data_buf;if(global_returns_t_or_f()){}else{}{char dest[50]="";strncat(dest, data, strlen(data));printLine(data);}}
static void main_sink(){int data=_main_data;{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}static void main(){int data;data=7;_main_data=data;main_sink();}
static void main(){twoints * data;data=(twoints *)malloc(10*sizeof(twoints));{int i;for(i=0;i<10;i++){data[i].a=i;data[i].b=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}}
static void main(){twointsclass * data;data=NULL;data=main_source(data);free(data);}twointsclass * main_source(twointsclass * data){data=NULL;data=(twointsclass *)realloc(data, 100*sizeof(twointsclass));return data;}
void b_main_sink(_struct_type my_struct);static void main(){short data;_struct_type my_struct;data=0;data=100-1;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){short data=my_struct.a;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
static void main(){twointsclass * data;twointsclass * data_array[5];data=NULL;data=new twointsclass[100];data_array[2]=data;main_sink(data_array);}void main_sink(twointsclass * data_array[]){twointsclass * data=data_array[2];delete [] data;}
static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));main_sink_b(data);}void main_sink_b(twoints * data){main_sink_c(data);}void main_sink_c(twoints * data){main_sink_d(data);}void main_sink_d(twoints * data){free(data);}
void b_main_sink(void * void_data_ptr);static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{char dest[100];memset(dest, 'C', 100-1);memmove(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);free(data);}}
void main_source(wchar_t * &data);static void main(){wchar_t * data;data=NULL;main_source(data);{wchar_t src[100];_snwprintf(data, 100, L"%s", src);printWLine(data);delete [] data;}}void main_source(wchar_t * &data){data=new wchar_t[100];}
char * b_main_source(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;data=b_main_source(data);{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}char * b_main_source(char * data){strcat(data, "file.txt");return data;}
static void main_sink(struct _twoints * data){}static void main(){struct _twoints * data;data=NULL;{struct _twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);}main_sink(data);}
static void main(){long long * data;_union_type my_union;data=(long long *)calloc(100, sizeof(long long));my_union.a=data;{long long * data=my_union.b;if (data!=NULL){data[0]=5L;printLongLongLine(data[0]);free(data);}}}
void _main_sink(wchar_t * data){{HMODULE hModule;hModule=LoadLibraryW(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"C:\\Windows\\System32\\winsrv.dll");_main_sink(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
static void main(){int data;data=-1;data=RAND32();b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){{int result=-1;if (data <=(INT_MAX/2)){result=data * 2;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){int data;data=-1;data=100-1;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main(){int data;data=-1;data=main_source(data);{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}int main_source(int data){{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}return data;}
static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}static void main_sink(){wchar_t * data=_main_data;main_vasink(data, data);}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");_main_data=data;main_sink();}
static void main(){wchar_t * data;_union_type my_union;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;my_union.a=data;{wchar_t * data=my_union.b;{wchar_t src[100];wcsncpy(data, src, 100);data[100-1]=L'\0';printWLine(data);}}}
static void main_sink(long long * data){free(data);}static void main(){long long * data;data=NULL;data=(long long *)calloc(100, sizeof(long long));data[0]=5L;printLongLongLine(data[0]);main_sink(data);}
static void main(){unsigned int data;unsigned int data_array[5];data=0;data=5;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(unsigned int data_array[]){unsigned int data=data_array[2];{unsigned int result=data-1;printUnsignedLine(result);}}
static void main(){char * data;data=NULL;data=b_main_source(data);free(data);}char * b_main_source(char * data){{char mystring[]="mystring";data=strdup(mystring);printLine(data);}return data;}
static void main(){wchar_t * data;data=NULL;main_source(data);printWcharLine(*data);}void main_source(wchar_t * &data){data=new wchar_t;}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);main_vasink(data, data);}char * b_main_source(char * data){strcpy(data, "fixedstringtest");return data;}
static void main_source(wchar_t * &data){{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}}static void main(){wchar_t * data;data=NULL;main_source(data);{wchar_t dest[100];memmove(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){try{if (rand()%2==0) throw out_of_range("err1");if (rand()%2==0) throw domain_error("err2");}catch (out_of_range &){printLine("out_of_range");}catch (domain_error &){printLine("domain_error");return;}printLine("ok");}
static void main_source(twointsclass * &data){for(int i=0;i<10;i++){data[i].a=i;data[i].b=i;}}static void main(){twointsclass * data;data=(twointsclass *)ALLOCA(10*sizeof(twointsclass));main_source(data);for(int i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}
static void main(){unsigned int data;unsigned int *data_ptr1=&data;unsigned int *data_ptr2=&data;data=0;{unsigned int data=*data_ptr1;data=(unsigned int)RAND32();}{unsigned int data=*data_ptr2;{unsigned int result=-1;if (data <=(UINT_MAX/2)){result=data * 2;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
static void main(){twointsclass * data;twointsclass data_uninit_array[10];data=data_uninit_array;if(global_returns_t_or_f()){for(int i=0;i<10;i++){data[i].a=i;data[i].b=i;}}else{for(int i=0;i<10;i++){data[i].a=i;data[i].b=i;}}if(global_returns_t_or_f()){for(int i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}else{for(int i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");fwprintf(stdout, data);}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");b_main_sink(data);}void b_main_sink(char * data){{FILE *pipe;pipe=POPEN(data, "wb");if (pipe!=NULL) PCLOSE(pipe);}}
static void main_sink(char * data){EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;strcat(data, "*.*");func_ptr(data);}
static void main_sink(){char * data=_main_data;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_main_data=data;main_sink();}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;data=b_main_source(data);{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}wchar_t * b_main_source(wchar_t * data){wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");return data;}
static void main(){char * data;char * &data_ref=data;data=new char[100];{char * data=data_ref;{char dest[50]="";strcpy(dest, data);printLine(data);delete [] data;}}}
static void main(){twoints * data;data=NULL;data=new twoints;data->a=1;data->b=2;{twoints * data_copy=data;twoints * data=data_copy;printStructLine(data);}}
static void main(){twoints * data;data=NULL;{twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine(&data[0]);}main_sink(&data);}void main_sink(void * void_data_ptr){twoints * * data_ptr=(twoints * *)void_data_ptr;twoints * data=(*data_ptr);}
static int * main_source(int * data){{int data_goodbuf[100];data=data_goodbuf;data[0]=5;printIntLine(data[0]);}return data;}static void main(){int * data;data=NULL;data=main_source(data);}
static wchar_t * main_source(wchar_t * data){data=PASSWORD;return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);if (wcsstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(_struct_type my_struct);static void main(){short data;_struct_type my_struct;data=0;data=100-1;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){short data=my_struct.a;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t;main_sink_b(data);}void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_d(wchar_t * data){main_sink_e(data);}void main_sink_e(wchar_t * data){delete data;}
static void main(){char data;char data_array[5];data=' ';data=(char)rand();data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char data_array[]){char data=data_array[2];{char result=-1;if (data <=(CHAR_MAX/2)){result=data * 2;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){char data;data=' ';data=5;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * data_ptr=(char *)void_data_ptr;char data=(*data_ptr);{char result=data * data;printHexCharLine(result);}}
void main_sink_b(int * data);static void main(){int * data;data=NULL;data=new int[100];main_sink_b(data);}void main_sink_c(int * data);void main_sink_b(int * data){main_sink_c(data);}void main_sink_d(int * data);void main_sink_c(int * data){main_sink_d(data);}void main_sink_e(int * data);void main_sink_d(int * data){main_sink_e(data);}void main_sink_e(int * data){{memcpy(data, src, 100*sizeof(int));printIntLine(data[0]);delete [] data;}}
static void main(){long long * data;long long * *data_ptr1=&data;long long * *data_ptr2=&data;data=NULL;{long long * data=*data_ptr1;data=new long long[100];}{long long * data=*data_ptr2;delete [] data;}}
static void main(){int * data;int * &data_ref=data;data=new int[10];{int i;for(i=0;i<10;i++){data[i]=i;}}{int * data=data_ref;{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}delete [] data;}}
static void main(){int count;int *count_ptr1=&count;int *count_ptr2=&count;count=-1;{int count=*count_ptr1;count=20;}{int count=*count_ptr2;{size_t i=0;FILE *file=NULL;const char *filename="output_bad.txt";file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}}{int data=*data_ptr2;{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}}
static void main(){char data;void (*func_ptr) (char)=b_main_sink;data=' ';fscanf (stdin, "%c", &data);func_ptr(data);}void b_main_sink(char data){{char result=-1;if (data <=(CHAR_MAX/2)){result=data * 2;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){int data;data=-1;data=RAND32();b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
int b_main_source(int data);static void main(){int data;data=-1;data=b_main_source(data);{short s=(short)data;printf("%hd\n", s);}}int b_main_source(int data){data=CHAR_MAX-5;return data;}
void b_main_sink(long long * data);static void main(){long long * data;data=(long long *)calloc(100, sizeof(long long));b_main_sink(data);}void c_main_sink(long long * data);void b_main_sink(long long * data){c_main_sink(data);}void c_main_sink(long long * data){if (data!=NULL){data[0]=5L;printLongLongLine(data[0]);free(data);}}
static void main(){char * data;data=NULL;data=new char[100];main_sink_b(data);}void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){delete [] data;}
static void main(){twointsclass * data;data=new twointsclass[10];main_sink(&data);}void main_sink(void * void_data_ptr){twointsclass * * data_ptr=(twointsclass * *)void_data_ptr;twointsclass * data=(*data_ptr);for(int i=0;i<10;i++){data[i].a=i;data[i].b=i;}for(int i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}
static void main(){char * data;union_type my_union;{char * data_buf=new char[100];data=data_buf;}my_union.a=data;{char * data=my_union.b;printLine(data);delete [] data;}}
static void main(){twoints * data;twoints * &data_ref=data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));{twoints * data=data_ref;free(data);}}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(L"%s", args);va_end(args);}}static void main_sink(){wchar_t * data=_main_data;main_vasink(data, data);}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}_main_data=data;main_sink();}
void main_sink_b(char * data);static void main(){char * data;data=new char[100];main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){{char dest[50]="";_snprintf(dest, strlen(data), "%s", data);printLine(data);delete [] data;}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");{char dest[100]="";SNPRINTF(dest, 100-1, data);printLine(dest);}}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");{wchar_t * data_copy=data;wchar_t * data=data_copy;{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));data[0]=L'\0';data=b_main_source(data);{size_t i;for (i=0;i < wcslen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}wchar_t * b_main_source(wchar_t * data){{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}return data;}
wchar_t * b_main_source(wchar_t * password);static void main(){wchar_t * password;password=L"";password=b_main_source(password);{HANDLE pHandle;wchar_t * username=L"User";wchar_t * domain=L"Domain";if (LogonUserW( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}wchar_t * b_main_source(wchar_t * password){password=(wchar_t *)malloc(100*sizeof(wchar_t));if(!VirtualLock(password, 100*sizeof(wchar_t))){printLine("Memory could not be locked");exit(1);}wcscpy(password, L"Password1234!");return password;}
static void main(){char * data;data=NULL;{char data_goodbuf[100];data=data_goodbuf;strcpy(data, "A String");printLine(data);}}
static void main(){int count;count=-1;count=20;b_main_sink(count);}void b_main_sink(int count){c_main_sink(count);}void c_main_sink(int count){{size_t i=0;for (i=0;i < (size_t)count;i++){printLine("Hello");}}}
void b_main_sink();static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{size_t i, dest_sz;char dest[100];memset(dest, 'C', 100-1);dest_sz=strlen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);}}
void b_main_sink(char * data);static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{char src[100];_snprintf(data, 100, "%s", src);printLine(data);free(data);}}
static void main(){long long * data;data=NULL;{long long data_goodbuf[100];data=data_goodbuf;data[0]=5L;printLongLongLine(data[0]);}_main_data=data;b_main_sink();}void b_main_sink(){long long * data=_main_data;}
static void main(){char * data;_union_type my_union;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;my_union.a=data;{char * data=my_union.b;{char dest[100];memmove(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=(char *)malloc(100*sizeof(char));{char * data=*data_ptr1;}{char * data=*data_ptr2;{char dest[50]="";size_t i, data_len;data_len=strlen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printLine(data);free(data);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");{wchar_t * data_copy=data;wchar_t * data=data_copy;EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;func_ptr(data);}void b_main_sink(wchar_t * data){{wchar_t dest[100];wmemset(dest, L'C', 100-1);memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){unsigned int data;data=0;if(global_returns_t_or_f()){data=5;}else{data=5;}if(global_returns_t_or_f()){{unsigned int result=data * data;printUnsignedLine(result);}}else{{unsigned int result=data * data;printUnsignedLine(result);}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){system(data);}
static void main(){int * data;data=NULL;data=NULL;data=(int *)realloc(data, 100*sizeof(int));{int * data_copy=data;int * data=data_copy;free(data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]="";data=data_buf;strcat(data, "*.*");func_ptr(data);}void b_main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnvp(_P_WAIT, COMMAND_INT, args);}}
static void main(){int data;data=-1;data=7;printIntLine(100/data);}
void b_main_sink(char * * data);static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char src[100];memmove(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");func_ptr(data);}void b_main_sink(wchar_t * data){wprintf(data);}
void main_sink(twointsclass * data);static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];main_sink(data);}void main_sink(twointsclass * data){{twointsclass src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printIntLine(data[0].a);delete [] data;}}}
static void main_sink(int data){{int result=-1;if (data < INT_MAX){result=data+1;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}func_ptr(data);}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[250]=L"PATH=";data=data_buf;wcscat(data, NEW_PATH);my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;PUTENV(data);}
void _main_sink(char * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");_main_sink(data);}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");{wchar_t * data_copy=data;wchar_t * data=data_copy;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;data=(wchar_t *)malloc(100*sizeof(wchar_t));func_ptr(data);}void b_main_sink(wchar_t * data){{wchar_t dest[50]=L"";wcscat(dest, data);printWLine(data);free(data);}}
static void main(){double * data;data=(double *)malloc(10*sizeof(double));b_main_sink(&data);}void b_main_sink(void * void_data_ptr){double * * data_ptr=(double * *)void_data_ptr;double * data=(*data_ptr);{int i;for(i=0;i<10;i++){data[i]=(double)i;}}{int i;for(i=0;i<10;i++){printDoubleLine(data[i]);}}}
static void main(){int data;data=-1;data=20;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}
static void main_sink(){wchar_t * data=_main_data;{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");_main_data=data;main_sink();}
static void main(){char data;void (*func_ptr) (char)=b_main_sink;data=' ';data=5;func_ptr(data);}void b_main_sink(char data){{char result=data+1;printHexCharLine(result);}}
static wchar_t * main_source(wchar_t * data){{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));data=data_buf;}return data;}static void main(){wchar_t * data;data=main_source(data);printWLine(data);free(data);}
static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;{char src[100];strncat(data, src, 100);printLine(data);}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;data=(wchar_t *)malloc(100*sizeof(wchar_t));data[0]=L'\0';{wchar_t * data=*data_ptr1;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}}{wchar_t * data=*data_ptr2;{size_t i;for (i=0;i < wcslen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];delete [] data;}
static void main_sink(wchar_t * data){_wsystem(data);}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");func_ptr(data);}
static void main_sink(twointsclass * data){free(data);}static void main(){twointsclass * data;void (*func_ptr) (twointsclass *)=main_sink;data=NULL;data=(twointsclass *)malloc(100*sizeof(twointsclass));func_ptr(data);}
static void main(){double data;if(global_returns_t_or_f()){data=5.0;}else{data=5.0;}if(global_returns_t_or_f()){printDoubleLine(data);}else{printDoubleLine(data);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;{char * data_copy=data;char * data=data_copy;{char dest[100];memmove(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{wchar_t dest[50]=L"";_snwprintf(dest, wcslen(data), L"%s", data);printWLine(data);free(data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");{char dest[100]="";SNPRINTF(dest, 100-1, data);printLine(dest);}}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{char src[100];strncpy(data, src, 100);printLine(data);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;data=NULL;data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));func_ptr(data);}void b_main_sink(wchar_t * data){{wchar_t data_src[10+1]=SRC_STRING;memmove(data, data_src, wcslen(data_src)*sizeof(wchar_t));printWLine(data);free(data);}}
static void main(){unsigned int data;void (*func_ptr) (unsigned int)=b_main_sink;data=0;data=(unsigned int)RAND32();func_ptr(data);}void b_main_sink(unsigned int data){{unsigned int result=-1;if (data <=(unsigned int)sqrt((unsigned int)UINT_MAX)){result=data * data;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main_sink(){char * data=_main_data;if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;_main_data=data;main_sink();}
static void main(){char * data;data=(char *)malloc(100*sizeof(char));{char * data_copy=data;char * data=data_copy;{char dest[50]="";strncpy(dest, data, strlen(data));printLine(data);free(data);}}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;data=NULL;data=(char *)malloc((10+1)*sizeof(char));my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char data_src[10+1]=SRC_STRING;strcpy(data, data_src);printLine(data);free(data);}}
static void main(){wchar_t * data;data=new wchar_t[100];{wchar_t dest[50]=L"";wcsncat(dest, data, wcslen(data));printWLine(data);delete [] data;}}
void b_main_sink(char * * data);static void main(){char * data;data=(char *)malloc(100*sizeof(char));b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char dest[50]="";size_t i, data_len;data_len=strlen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printLine(data);free(data);}}
void main_sink_b(twointsclass * data);static void main(){twointsclass * data;{twointsclass * data_buf=new twointsclass[100];{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}main_sink_b(data);}void main_sink_c(twointsclass * data);void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_d(twointsclass * data);void main_sink_c(twointsclass * data){main_sink_d(data);}void main_sink_e(twointsclass * data);void main_sink_d(twointsclass * data){main_sink_e(data);}void main_sink_e(twointsclass * data){printIntLine(data[0].a);delete [] data;}
static void main(){int * data;if(global_returns_t_or_f()){{int * data_buf=(int *)malloc(100*sizeof(int));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}}else{{int * data_buf=(int *)malloc(100*sizeof(int));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}}printIntLine(data[0]);free(data);}
static void main(){long long * data;long long * &data_ref=data;data=NULL;data=new long long;{long long * data=data_ref;delete data;}}
static void main(){char data;char data_array[5];data=' ';fscanf (stdin, "%c", &data);data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char data_array[]){char data=data_array[2];{char result=0;if (data > CHAR_MIN){result=data-1;printHexCharLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
static void main(){char data;data=' ';data=5;b_main_sink(data);}void b_main_sink(char data){c_main_sink(data);}void c_main_sink(char data){d_main_sink(data);}void d_main_sink(char data){{char result=data * data;printHexCharLine(result);}}
static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, data, args);va_end(args);printLine(dest);}}static void main_sink(char * data){main_vasink(data, data);}static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");main_sink(data);}
static void main_sink(wchar_t * data){{wchar_t dest[50]=L"";wcsncpy(dest, data, wcslen(data));printWLine(data);free(data);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=(wchar_t *)malloc(100*sizeof(wchar_t));func_ptr(data);}
void b_main_sink();static void main(){HANDLE data;data=INVALID_HANDLE_VALUE;data=CreateFile("BadSource_w32CreateFile.txt", (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);_bad_data_for_good_sink=data;b_main_sink();}void b_main_sink(){HANDLE data=_bad_data_for_good_sink;if (data!=INVALID_HANDLE_VALUE){CloseHandle(data);}}
void main_sink_b(wchar_t * data);static void main(){wchar_t * data;data=new wchar_t[100];main_sink_b(data);}void main_sink_c(wchar_t * data);void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){{wchar_t dest[50]=L"";wcscpy(dest, data);printWLine(data);delete [] data;}}
void main_sink(long long * data);static void main(){long long * data;{long long * data_buf=new long long[100];{size_t i;for (i=0;i < 100;i++){data_buf[i]=5L;}}data=data_buf;}main_sink(data);}void main_sink(long long * data){printLongLongLine(data[0]);delete [] data;}
static void main_sink(int data){{int result=data * data;printIntLine(result);}}static void main(){int data;data=-1;data=5;main_sink(data);}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;data->a=0;data->b=0;printIntLine(data->a);printIntLine(data->b);main_sink_b(data);}void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_c(twointsclass * data){main_sink_d(data);}void main_sink_d(twointsclass * data){main_sink_e(data);}void main_sink_e(twointsclass * data){delete data;}
static void main(){twointsclass * data;data=NULL;data=main_source(data);delete [] data;}twointsclass * main_source(twointsclass * data){data=new twointsclass[100];return data;}
static void main(){char data;data=' ';data=b_main_source(data);{char result=0;if (data > CHAR_MIN){result=data-1;printHexCharLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}char b_main_source(char data){data=(char)rand();return data;}
static void main_sink(){char * data=main_data;{char src[100];memcpy(data, src, 100*sizeof(char));printLine(data);delete [] data;}}static void main(){char * data;data=NULL;data=new char[100];main_data=data;main_sink();}
static void main(){{if (fwrite((wchar_t *)L"string", sizeof(wchar_t), wcslen(L"string"), stdout)!=wcslen(L"string")){printLine("fwrite failed!");exit(1);}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;if (strstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
static void main_sink(){wchar_t * data=_main_data;{wchar_t dest[50]=L"";wcscat(dest, data);printWLine(data);}}static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;_main_data=data;main_sink();}
static void main(){int count;count=-1;count=b_main_source(count);{size_t i=0;FILE *file=NULL;const char *filename="output_good.txt";if (count > 0 && count <=20){file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}}int b_main_source(int count){{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;count=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}return count;}
static void main(){int data;data=-1;data=RAND32();b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){short data;data=-1;data=CHAR_MAX-5;{short data_copy=data;short data=data_copy;{char c=(char)data;printHexCharLine(c);}}}
static void main(){twointsclass * data;struct_type my_struct;data=NULL;data=new twointsclass[100];data[0].a=0;data[0].b=0;printIntLine(data[0].a);printIntLine(data[0].b);my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){twointsclass * data=my_struct.a;delete[] data;}
void main_sink_b(wchar_t * data);static void main(){wchar_t * data;data=new wchar_t[100];main_sink_b(data);}void main_sink_c(wchar_t * data);void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){{wchar_t dest[50]=L"";wcsncpy(dest, data, wcslen(data));printWLine(data);delete [] data;}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){char * data;struct_type my_struct;data=NULL;data=(char *)malloc(100*sizeof(char));my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){char * data=my_struct.a;free(data);}
void b_main_sink(int data);static void main(){int data;data=-1;data=OPEN("BadSource_open.txt", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void d_main_sink(int data);void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){if (data!=-1){CLOSE(data);}}
static void main_sink(int data){{int result=data+1;printIntLine(result);}}static void main(){int data;data=-1;data=5;main_sink(data);}
static void main(){int data;_struct_type my_struct;data=-1;data=10000;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){int * data;int * *data_ptr1=&data;int * *data_ptr2=&data;data=NULL;{int * data=*data_ptr1;data=(int *)malloc(100*sizeof(int));}{int * data=*data_ptr2;{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printIntLine(data[0]);free(data);}}}}
static void main(){int data;data=-1;data=RAND32();{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){wchar_t * data;data=NULL;main_source(data);delete [] data;}void main_source(wchar_t * &data){data=new wchar_t[100];}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(L"%s", args);va_end(args);}}void c_main_sink(wchar_t * data){main_vasink(data, data);}
static void main_sink(int data){{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than the length of the source string or too large");}}}static void main(){int data;data=-1;data=RAND32();main_sink(data);}
static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");my_union.a=data;{char * data=my_union.b;printf(data);}}
static void main(){char * data;char * &data_ref=data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}{char * data=data_ref;{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]='\0';printLine(data);}}}
void b_main_sink();static void main(){char * data;char data_buf[250]="PATH=";data=data_buf;strcat(data, NEW_PATH);_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;PUTENV(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
static void main(){long long * data;data=NULL;data=NULL;data=(long long *)realloc(data, 100*sizeof(long long));main_sink(data);}void main_sink(long long * data){free(data);}
static void main_sink(wchar_t * data){EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");func_ptr(data);}
static void main_source(twoints * &data){data=new twoints;}static void main(){twoints * data;data=NULL;main_source(data);delete data;}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=NULL;{char * data=*data_ptr1;data=new char;}{char * data=*data_ptr2;delete data;}}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{wchar_t dest[100];wmemset(dest, L'C', 100-1);memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);free(data);}}
void main_source(char * &data);static void main(){char * data;data=NULL;main_source(data);{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}printLine(data);delete [] data;}}void main_source(char * &data){data=new char[100];}
static void main(){int data;data=10;_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0 && data < 10){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){{wchar_t * password=(wchar_t *)malloc(100*sizeof(wchar_t));size_t password_len=0;HANDLE pHandle;wchar_t * username=L"User";wchar_t * domain=L"Domain";password[0]=L'\0';fgetws(password, 100, stdin);password_len=wcslen(password);if (password_len > 0){password[password_len-1]=L'\0';}if (LogonUserW( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}password_len=wcslen(password);SecureZeroMemory(password, password_len * sizeof(wchar_t));}}
static void main_source(long long * &data){data=(long long *)malloc(100*sizeof(long long));}static void main(){long long * data;data=NULL;main_source(data);free(data);}
static void main(){int * data;if(global_returns_t_or_f()){{int * data_buf=new int[100];{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}}else{{int * data_buf=new int[100];{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}}printIntLine(data[0]);delete [] data;}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}
void _main_sink(wchar_t * data){printWLine(data);free(data);}static void main(){wchar_t * data;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));data=data_buf;}_main_sink(data);}
void _main_sink(wchar_t * data){EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_sink(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){int data;_struct_type my_struct;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{int result=-1;if (data <=(int)sqrt((int)INT_MAX)){result=data * data;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char dest[100];strcpy(dest, data);printLine(dest);}}
static void main(){int data;data=7;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main(){int data;int &data_ref=data;data=-1;data=20;{int data=data_ref;{size_t a,i;int *b;b=(int*)new char[a];for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);delete [] b;}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){short data;short *data_ptr1=&data;short *data_ptr2=&data;data=0;{short data=*data_ptr1;data=100-1;}{short data=*data_ptr2;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}}
static void main(){unsigned char data;data=' ';data=b_main_source(data);{unsigned char result=data * data;printHexUnsignedCharLine(result);}}unsigned char b_main_source(unsigned char data){data=5;return data;}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;{twointsclass * data_copy=data;twointsclass * data=data_copy;delete data;}}
static void main_vasinkb(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}static void main_vasinkg(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, L"%s", args);va_end(args);printWLine(dest);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}main_vasinkg(data, data);}
static void main(){long long * data;data=NULL;if(global_returns_t_or_f()){data=new long long;}else{data=new long long;}if(global_returns_t_or_f()){delete data;}else{delete data;}}
void main_sink(struct_type my_struct);static void main(){wchar_t * data;struct_type my_struct;data=NULL;data=new wchar_t[100];my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){wchar_t * data=my_struct.a;{wchar_t src[100];wcsncpy(data, src, 100);printWLine(data);delete [] data;}}
static void main(){long long * data;union_type my_union;data=NULL;data=new long long[100];my_union.a=data;{long long * data=my_union.b;{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printLongLongLine(data[0]);delete [] data;}}}}
void b_main_sink(char * data);static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{size_t i, dest_sz;char dest[100];memset(dest, 'C', 100-1);dest_sz=strlen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);}}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(data, args);va_end(args);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *, ...)=main_vasink;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");func_ptr(data);}
void b_main_sink(int data);static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=-1;data=20;func_ptr(data);}void b_main_sink(int data){{size_t i;int *b;b=(int*)malloc(data * sizeof(int));for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);free(b);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t dest[50]=L"";wcsncat(dest, data, wcslen(data));printWLine(data);}}
static void main(){twointsclass * data;void (*func_ptr) (twointsclass *)=main_sink;data=NULL;data=new twointsclass[100];data[0].a=0;data[0].b=0;printIntLine(data[0].a);printIntLine(data[0].b);func_ptr(data);}void main_sink(twointsclass * data){delete[] data;}
void b_main_sink(_struct_type my_struct);static void main(){int * data;_struct_type my_struct;int * data_badbuf=(int *)ALLOCA(50*sizeof(int));int * data_goodbuf=(int *)ALLOCA(100*sizeof(int));data=data_goodbuf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int * data=my_struct.a;{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printIntLine(data[0]);}}}
static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;if(global_returns_t_or_f()){}else{}{wchar_t dest[50]=L"";wcscpy(dest, data);printWLine(data);}}
static int main_source(int data){data=5;return data;}static void main(){int data;data=-1;data=main_source(data);{int result=data+1;printIntLine(result);}}
static void main_sink(int data){{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than the length of the source string or too large");}}}static void main(){int data;data=-1;data=10000;main_sink(data);}
static void main(){twoints * data;data=NULL;data=(twoints *)calloc(100, sizeof(twoints));{twoints * data_copy=data;twoints * data=data_copy;free(data);}}
static void main(){twoints * data;struct_type my_struct;data=NULL;data=new twoints;my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){twoints * data=my_struct.a;delete data;}
static void main(){wchar_t * data;wchar_t * data_array[5];data=NULL;data=NULL;data=(wchar_t *)realloc(data, 100*sizeof(wchar_t));data_array[2]=data;main_sink(data_array);}void main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];free(data);}
static void main(){wchar_t * data;_union_type my_union;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;my_union.a=data;{wchar_t * data=my_union.b;{wchar_t dest[100];wmemset(dest, L'C', 100-1);memmove(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}}
void b_main_sink(_struct_type my_struct);static void main(){int data;_struct_type my_struct;data=-1;data=CHAR_MAX-5;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{char c=(char)data;printHexCharLine(c);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){_spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static struct _twoints * main_source(struct _twoints * data){data=(struct _twoints *)calloc(100, sizeof(struct _twoints));data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);return data;}static void main(){struct _twoints * data;data=NULL;data=main_source(data);free(data);}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;strcat(data, "*.*");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
void b_main_sink();static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;system(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(data);}void b_main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static unsigned int main_source(unsigned int data){data=UINT_MAX;return data;}static void main(){unsigned int data;data=0;data=main_source(data);{unsigned int result=-1;if (data <=(UINT_MAX/2)){result=data * 2;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){char * data;data=NULL;data=new char[100];memset(data, 'A', 100-1);data[100-1]='\0';delete [] data;main_sink(data);}void main_sink(char * data){}
static void main(){char * data;data=(char *)malloc(100*sizeof(char));data[0]='\0';{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}{size_t i;for (i=0;i < strlen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}
static void main(){twoints * data;data=NULL;main_source(data);delete [] data;}void main_source(twoints * &data){data=new twoints[100];}
static void main(){char data;char data_array[5];data=' ';data=5;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char data_array[]){char data=data_array[2];{char result=data+1;printHexCharLine(result);}}
static void main(){int count;count=-1;count=20;b_main_sink(&count);}void b_main_sink(void * void_count_ptr){int * count_ptr=(int *)void_count_ptr;int count=(*count_ptr);{size_t i=0;FILE *file=NULL;const char *filename="output_bad.txt";file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}
static void main_source(double * &data){}static void main(){double * data;data=new double[10];main_source(data);{int i;for(i=0;i<10;i++){data[i]=(double)i;}}{int i;for(i=0;i<10;i++){printDoubleLine(data[i]);}}delete [] data;}
static void main(){twoints * data;union_type my_union;data=NULL;data=new twoints;delete data;my_union.a=data;{twoints * data=my_union.b;}}
static void main(){twoints * data;twoints * *data_ptr1=&data;twoints * *data_ptr2=&data;data=NULL;{twoints * data=*data_ptr1;data=(twoints *)malloc(100*sizeof(twoints));}{twoints * data=*data_ptr2;{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memcpy(data, src, 100*sizeof(twoints));printStructLine(&data[0]);free(data);}}}
static void main(){int data;data=-1;main_source(data);{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}void main_source(int &data){data=20;}
static void main_sink(short data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}static void main(){short data;void (*func_ptr) (short)=main_sink;data=0;data=100-1;func_ptr(data);}
void b_main_sink(char * data);static void main(){char * data;char data_buf[250]="PATH=";data=data_buf;strcat(data, NEW_PATH);b_main_sink(data);}void b_main_sink(char * data){PUTENV(data);}
void b_main_sink(short data);static void main(){short data;data=0;data=100-1;b_main_sink(data);}void c_main_sink(short data);void b_main_sink(short data){c_main_sink(data);}void c_main_sink(short data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
static void main(){int data;_struct_type my_struct;data=-1;data=20;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{char * char_string;if (data > 0){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than 0");}}}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char data_buf[100];data=data_buf;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{char dest[50]="";size_t i, data_len;data_len=strlen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printLine(data);}}
static void main(){long long * data;data=NULL;data=new long long;{long long * data_copy=data;long long * data=data_copy;delete data;}}
void b_main_sink(char * data);static void main(){char * data;data=(char *)malloc(100*sizeof(char));data[0]='\0';{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{size_t i;for (i=0;i < strlen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}
static void main(){int * data;data=NULL;if(global_returns_t_or_f()){data=new int;}else{data=new int;}if(global_returns_t_or_f()){delete data;}else{delete data;}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t src[100];_snwprintf(data, 100, L"%s", src);printWLine(data);delete [] data;}}}
void b_main_sink(long long * data);static void main(){long long * data;long long * data_badbuf=(long long *)ALLOCA(50*sizeof(long long));long long * data_goodbuf=(long long *)ALLOCA(100*sizeof(long long));data=data_goodbuf;b_main_sink(data);}void c_main_sink(long long * data);void b_main_sink(long long * data){c_main_sink(data);}void c_main_sink(long long * data){{memcpy(data, src, 100*sizeof(long long));printLongLongLine(data[0]);}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}main_data=data;main_sink();}void main_sink(){twointsclass * data=main_data;printIntLine(data[0].a);}
static void main(){wchar_t * data;data=NULL;data=new wchar_t;main_data=data;main_sink();}void main_sink(){wchar_t * data=main_data;delete data;}
static void main(){int * data;data=NULL;data=(int *)malloc(100*sizeof(int));{size_t i;for(i=0;i < 100;i++){data[i]=5;}}free(data);}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, L"%s", args);va_end(args);}}static void main_sink(wchar_t * data){main_vasink(data, data);}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}main_sink(data);}
static void main(){int * data;int * *data_ptr1=&data;int * *data_ptr2=&data;data=NULL;{int * data=*data_ptr1;data=(int *)malloc(100*sizeof(int));data[0]=5;printIntLine(data[0]);}{int * data=*data_ptr2;free(data);}}
static void main(){twoints * data;twoints * &data_ref=data;data=NULL;data=new twoints[100];data[0].a=0;data[0].b=0;printStructLine(&data[0]);{twoints * data=data_ref;delete[] data;}}
static twointsclass * main_source(twointsclass * data){data=new twointsclass[100];return data;}static void main(){twointsclass * data;data=NULL;data=main_source(data);delete [] data;}
static void main(){long long * data;void (*func_ptr) (long long *)=b_main_sink;data=NULL;{long long data_goodbuf[100];data=data_goodbuf;data[0]=5L;printLongLongLine(data[0]);}func_ptr(data);}void b_main_sink(long long * data){}
void b_main_sink(int * data);static void main(){int * data;int * data_badbuf=(int *)ALLOCA(50*sizeof(int));int * data_goodbuf=(int *)ALLOCA(100*sizeof(int));data=data_goodbuf;b_main_sink(data);}void c_main_sink(int * data);void b_main_sink(int * data){c_main_sink(data);}void d_main_sink(int * data);void c_main_sink(int * data){d_main_sink(data);}void d_main_sink(int * data){{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printIntLine(data[0]);}}}
static void main(){long long * data;data=NULL;data=b_main_source(data);free(data);}long long * b_main_source(long long * data){data=(long long *)malloc(100*sizeof(long long));data[0]=5L;printLongLongLine(data[0]);return data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]=L'\0';printWLine(data);}}
static void main(){int * data;data=new int[10];if(global_returns_t_or_f()){{int i;for(i=0;i<(10/2);i++){data[i]=i;}}}else{{int i;for(i=0;i<(10/2);i++){data[i]=i;}}}if(global_returns_t_or_f()){{int i;for(i=0;i<10;i++){data[i]=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}delete [] data;}else{{int i;for(i=0;i<10;i++){data[i]=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}delete [] data;}}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}static void main_sink(char * data){main_vasink(data, data);}static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");main_sink(data);}
void _main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_sink(data);}
static void main(){int * data;{int * data_buf=new int[100];{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}{int * data_copy=data;int * data=data_copy;printIntLine(data[0]);delete [] data;}}
static void main(){wchar_t * data;_struct_type my_struct;data=NULL;{wchar_t data_goodbuf[100];data=data_goodbuf;wcscpy(data, L"A String");printWLine(data);}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;}
static void main(){{if (fprintf(stdout, "%s\n", "string") < 0){printLine("fprintf failed!");}}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]="";data=data_buf;{char * data=*data_ptr1;strcpy(data, "fixedstringtest");}{char * data=*data_ptr2;{char dest[100]="";SNPRINTF(dest, 100-1, data);printLine(dest);}}}
static void main(){wchar_t * data;_union_type my_union;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;my_union.a=data;{wchar_t * data=my_union.b;{wchar_t dest[50]=L"";size_t i, data_len;data_len=wcslen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printWLine(data);}}}
void b_main_sink(int data);static void main(){int data;data=-1;data=CHAR_MAX-5;b_main_sink(data);}void b_main_sink(int data){{char c=(char)data;printHexCharLine(c);}}
static void main(){char * data;data=NULL;data=(char *)calloc(100, sizeof(char));main_data=data;main_sink();}void main_sink(){char * data=main_data;free(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{char dest[100]="";SNPRINTF(dest, 100-1, data);printLine(dest);}}
static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));printWLine(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){int data;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
void b_main_sink(char * data);static void main(){char * data;{char * data_buf=(char *)malloc(100*sizeof(char));data=data_buf;}b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){printLine(data);free(data);}
static void main(){{wchar_t data_buf[100]=L"";wchar_t * data=data_buf;printLine("Please enter a string: ");if (fgetws(data, 100, stdin)==NULL){printLine("fgetws failed!");exit(1);}printWLine(data);}}
static void main(){FILE * data;FILE * *data_ptr1=&data;FILE * *data_ptr2=&data;{FILE * data=*data_ptr1;data=fopen("GoodSource_fopen.txt", "w+");}{FILE * data=*data_ptr2;fclose(data);}}
static void main_sink(){int data=main_data;{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}main_data=data;main_sink();}
void main_sink();static void main(){char * data;data=NULL;data=new char[100];_main_data=data;main_sink();}void main_sink(){char * data=_main_data;{char src[100];strncpy(data, src, 100);printLine(data);delete [] data;}}
void b_main_sink(twoints * * data);static void main(){twoints * data;data=(twoints *)realloc(data, 100);b_main_sink(&data);}void b_main_sink(twoints * * data_ptr){twoints * data=*data_ptr;if (data!=NULL){data[0].a=1;data[0].b=1;printStructLine(&data[0]);free(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;if (wcsstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
static void main(){twoints * data;data=NULL;data=new twoints;data->a=0;data->b=0;printStructLine(data);main_sink(&data);}void main_sink(void * void_data_ptr){twoints * * data_ptr=(twoints * *)void_data_ptr;twoints * data=(*data_ptr);delete data;}
static void main(){unsigned char data;data=' ';data=5;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){unsigned char * data_ptr=(unsigned char *)void_data_ptr;unsigned char data=(*data_ptr);{unsigned char result=data-1;printHexUnsignedCharLine(result);}}
static void main(){char * data;data=NULL;data=new char[100];main_sink(&data);}void main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);delete [] data;}
static void main_source(char * &data){{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}}static void main(){char * data;data=NULL;main_source(data);{char src[100];strncpy(data, src, 100);data[100-1]='\0';printLine(data);}}
static void main(){twoints * data;data=NULL;main_source(data);}void main_source(twoints * &data){{twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine(&data[0]);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;{char * data_copy=data;char * data=data_copy;if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}}
static void main(){{if (RENAME(OLD_GOOD_FILE_NAME, L"newgoodfilename.txt")!=0){printLine("wrename failed!");exit(1);}}}
static wchar_t * main_source(wchar_t * data){data=PASSWORD;return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);if (wcsncmp(PASSWORD, data, wcslen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}}{int data=*data_ptr2;{int result=-1;if (data <=(INT_MAX/2)){result=data * 2;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
static void main(){helper_good(UINT_MAX);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnv(_P_WAIT, COMMAND_INT_PATH, args);}}}
static void main_source(char * &data){}static void main(){char * data;data=new char[100];main_source(data);{char dest[50]="";memmove(dest, data, strlen(data)*sizeof(char));printLine(data);delete [] data;}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(&data);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(data, args);va_end(args);}}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);main_vasink(data, data);}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;data=b_main_source(data);{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}wchar_t * b_main_source(wchar_t * data){wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");return data;}
static void main_sink(){char data=_main_data;{char result=-1;if (data < CHAR_MAX){result=data+1;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}static void main(){char data;data=' ';fscanf (stdin, "%c", &data);_main_data=data;main_sink();}
static void main_sink(wchar_t * data){{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");func_ptr(data);}
static void main(){int * data;data=NULL;main_source(data);delete [] data;}void main_source(int * &data){data=new int[100];}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}{wchar_t * data_copy=data;wchar_t * data=data_copy;wprintf(L"%s\n", data);}}
void main_sink_b(char * data);static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_d(char * data);void main_sink_c(char * data){main_sink_d(data);}void main_sink_d(char * data){{char src[100];strncpy(data, src, 100);data[100-1]='\0';printLine(data);}}
static void main_sink(char * data){{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");func_ptr(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t src[100];wcscpy(data, src);printWLine(data);}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;data=NULL;{wchar_t * data=*data_ptr1;{wchar_t data_goodbuf[100];data=data_goodbuf;wcscpy(data, L"A String");printWLine(data);}}{wchar_t * data=*data_ptr2;}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';{char * data=*data_ptr1;data=data_buf;}{char * data=*data_ptr2;{char src[100];strcpy(data, src);printLine(data);}}}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
void b_main_sink(HANDLE data);static void main(){HANDLE data;data=INVALID_HANDLE_VALUE;data=CreateFile("BadSource_w32CreateFile.txt", (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);b_main_sink(data);}void b_main_sink(HANDLE data){if (data!=INVALID_HANDLE_VALUE){CloseHandle(data);}}
static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;{char dest[50]="";size_t i, data_len;data_len=strlen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printLine(data);}}
static void main(){int count;int *count_ptr1=&count;int *count_ptr2=&count;count=-1;{int count=*count_ptr1;count=20;}{int count=*count_ptr2;{size_t i=0;for (i=0;i < (size_t)count;i++){printLine("Hello");}}}}
static void main(){{if (RENAME(OLD_GOOD_FILE_NAME, L"newgoodfilename.txt")!=0){printLine("wrename failed!");}}}
static void main(){unsigned int data;data=0;fscanf (stdin, "%u", &data);b_main_sink(&data);}void b_main_sink(void * void_data_ptr){unsigned int * data_ptr=(unsigned int *)void_data_ptr;unsigned int data=(*data_ptr);{unsigned int result=-1;if (data <=(UINT_MAX/2)){result=data * 2;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{int i, n, v;if (swscanf(data, L"%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
void main_sink(int * data);static void main(){int * data;void (*func_ptr) (int *)=main_sink;data=NULL;data=new int[100];func_ptr(data);}void main_sink(int * data){{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printIntLine(data[0]);delete [] data;}}}
static void main_sink(int data){{short s=(short)data;printf("%hd\n", s);}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=CHAR_MAX-5;func_ptr(data);}
static void main(){unsigned int data;data=0;data=(unsigned int)RAND32();b_main_sink(data);}void b_main_sink(unsigned int data){c_main_sink(data);}void c_main_sink(unsigned int data){{unsigned int result=-1;if (data < UINT_MAX){result=data+1;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
int b_main_source(int data);static void main(){int data;data=-1;data=b_main_source(data);{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}int b_main_source(int data){data=100-1;return data;}
static void main(){int data;if(global_returns_t_or_f()){data=RAND32();}else{data=RAND32();}if(global_returns_t_or_f()){{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0 && data < 10){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}else{{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0 && data < 10){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}}
void main_source(char * &data);static void main(){char * data;data=new char[100];main_source(data);{char dest[50]="";memcpy(dest, data, strlen(data)*sizeof(char));printLine(data);delete [] data;}}void main_source(char * &data){}
static void main(){int data;_struct_type my_struct;data=10;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{char data_buf[10]="AAAAAAAAA";{printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){wprintf(L"%s\n", data);}
static void main(){char data;data=' ';data=5;_main_data=data;b_main_sink();}void b_main_sink(){char data=_main_data;{char result=data-1;printHexCharLine(result);}}
static void main(){unsigned int data;data=0;data=5;b_main_sink(data);}void b_main_sink(unsigned int data){c_main_sink(data);}void c_main_sink(unsigned int data){{unsigned int result=data * data;printUnsignedLine(result);}}
static void main(){long long * data;data=NULL;data=new long long;main_sink_b(data);}void main_sink_b(long long * data){main_sink_c(data);}void main_sink_c(long long * data){main_sink_d(data);}void main_sink_d(long long * data){main_sink_e(data);}void main_sink_e(long long * data){delete data;}
static void main(){int * data;data=NULL;if(global_returns_t_or_f()){data=new int[100];}else{data=new int[100];}if(global_returns_t_or_f()){delete [] data;}else{delete [] data;}}
static void main(){{char * key="TEST\\TestKey";HKEY hKey;if (RegOpenKeyExA( HKEY_CURRENT_USER, key, 0, KEY_WRITE, &hKey)!=ERROR_SUCCESS){printLine("Registry key could not be opened");}else{printLine("Registry key opened successfully");}}}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{wchar_t src[100];wcsncpy(data, src, 100);printWLine(data);free(data);}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;{wchar_t * data=*data_ptr1;wcscat(data, L"*.*");}{wchar_t * data=*data_ptr2;{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}}
static void main(){unsigned int data;data=0;data=b_main_source(data);{unsigned int result=-1;if (data <=(unsigned int)sqrt((unsigned int)UINT_MAX)){result=data * data;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}unsigned int b_main_source(unsigned int data){data=(unsigned int)RAND32();return data;}
static void main(){twoints * data;data=NULL;data=(twoints *)calloc(100, sizeof(twoints));data[0].a=0;data[0].b=0;printStructLine(&data[0]);b_main_sink(data);}void b_main_sink(twoints * data){c_main_sink(data);}void c_main_sink(twoints * data){d_main_sink(data);}void d_main_sink(twoints * data){free(data);}
static void main(){int data;data=-1;fscanf (stdin, "%d", &data);{int data_copy=data;int data=data_copy;{int result=-1;if (data <=(int)sqrt((int)INT_MAX)){result=data * data;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
wchar_t * main_source(wchar_t * data);static void main(){wchar_t * data;data=main_source(data);printWLine(data);delete [] data;}wchar_t * main_source(wchar_t * data){{wchar_t * data_buf=new wchar_t[100];data=data_buf;}return data;}
static void main(){long long * data;{long long * data_buf=new long long[100];{size_t i;for (i=0;i < 100;i++){data_buf[i]=5L;}}data=data_buf;}printLongLongLine(data[0]);delete [] data;}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;fscanf (stdin, "%d", &data);}{int data=*data_ptr2;{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}}
static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}{wchar_t src[100];wcscpy(data, src);printWLine(data);}}
void b_main_sink(bad_struct data);static void main(){bad_struct data;void (*func_ptr) (bad_struct)=b_main_sink;linked_list head={&head, &head};data.list.next=head.next;data.list.prev=&head;head.next=&data.list;head.next->prev=&data.list;func_ptr(data);}void b_main_sink(bad_struct data){* */prev=data.list.prev;next=data.list.next;prev->next=next;next->prev=prev;}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf("%s", args);va_end(args);}}static void main(){char * data;void (*func_ptr) (char *, ...)=main_vasink;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}func_ptr(data);}
static void main(){list<int> data;data.push_back(100);data.push_back(200);main_sink_b(data);}void main_sink_b(list<int> data){main_sink_c(data);}void main_sink_c(list<int> data){{list<int>::iterator i;cout << "The list contains: ";for( i=data.begin();i!=data.end();i++){if (!*i){data.clear();}cout << " " << *i;}cout << endl;}}
static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]='\0';printLine(data);}}
static void main(){twoints * data;twoints * *data_ptr1=&data;twoints * *data_ptr2=&data;data=NULL;{twoints * data=*data_ptr1;data=(twoints *)malloc(100*sizeof(twoints));free(data);}{twoints * data=*data_ptr2;}}
static void main(){struct _twoints * data;data=NULL;data=(struct _twoints *)malloc(100*sizeof(struct _twoints));data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);{struct _twoints * data_copy=data;struct _twoints * data=data_copy;free(data);}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';{wchar_t * data=*data_ptr1;data=data_buf;}{wchar_t * data=*data_ptr2;{wchar_t dest[100];memmove(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;data=(wchar_t *)malloc(100*sizeof(wchar_t));data[0]=L'\0';wcscpy(data, BAD_SRC_FIXED);func_ptr(data);}void b_main_sink(wchar_t * data){{size_t i;for (i=0;i < wcslen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}
static void main_sink(char * data){{int i, n, v;if (sscanf(data, "%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;strcpy(data, "15");func_ptr(data);}
void _main_sink(int * data){{memcpy(data, src, 100*sizeof(int));printIntLine(data[0]);}}static void main(){int * data;int data_badbuf[50];int data_goodbuf[100];data=data_goodbuf;_main_sink(data);}
static void main(){int * data;union_type my_union;data=NULL;data=new int[100];{size_t i;for(i=0;i < 100;i++){data[i]=5;}}delete [] data;my_union.a=data;{int * data=my_union.b;}}
static void main_sink(unsigned int data){{unsigned int result=-1;if (data <=(unsigned int)sqrt((unsigned int)UINT_MAX)){result=data * data;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}static void main(){unsigned int data;void (*func_ptr) (unsigned int)=main_sink;data=0;data=UINT_MAX;func_ptr(data);}
static void main_sink(){short data=_main_data;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}static void main(){short data;data=0;data=100-1;_main_data=data;main_sink();}
void main_source(char * &data);static void main(){char * data;data=new char[100];main_source(data);{char dest[50]="";memmove(dest, data, strlen(data)*sizeof(char));printLine(data);delete [] data;}}void main_source(char * &data){}
static void main_sink(wchar_t * data){{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"15");main_sink(data);}
void b_main_sink(int * data);static void main(){int * data;data=NULL;data=(int *)malloc(100*sizeof(int));b_main_sink(data);}void c_main_sink(int * data);void b_main_sink(int * data){c_main_sink(data);}void c_main_sink(int * data){{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printIntLine(data[0]);free(data);}}}
static void main_sink(wchar_t * data){free(data);}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=NULL;data=NULL;data=(wchar_t *)realloc(data, 100*sizeof(wchar_t));func_ptr(data);}
static void main_sink(char * data){{size_t i;for (i=0;i < strlen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=(char *)malloc(100*sizeof(char));data[0]='\0';strcpy(data, BAD_SRC_FIXED);func_ptr(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, L"%s", data);printWLine(dest);}}wchar_t * b_main_source(wchar_t * data){{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}return data;}
void b_main_sink(int data_array[]);static void main(){int data;int data_array[5];data=-1;data=100-1;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
static int main_source(int data){data=CHAR_MAX-5;return data;}static void main(){int data;data=-1;data=main_source(data);{short s=(short)data;printf("%hd\n", s);}}
static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}data_array[2]=data;b_main_sink(data_array);}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, L"%s", args);va_end(args);printWLine(dest);}}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];main_vasink(data, data);}
static void main(){twointsclass * data;struct_type my_struct;data=NULL;data=new twointsclass;my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){twointsclass * data=my_struct.a;delete data;}
static void main(){wchar_t * data;_union_type my_union;data=(wchar_t *)malloc(100*sizeof(wchar_t));data[0]=L'\0';wcscpy(data, BAD_SRC_FIXED);my_union.a=data;{wchar_t * data=my_union.b;{size_t i;for (i=0;i < wcslen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}}
static void main(){twoints * data;data=NULL;data=new twoints;delete data;}
static wchar_t * main_source(wchar_t * data){wcscpy(data, L"C:\\Windows\\System32\\winsrv.dll");return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);{HMODULE hModule;hModule=LoadLibraryW(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}{size_t i;wchar_t dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);}}
static void main(){{char * pipeName="\\\\.\\pipe\\mypipe";HANDLE hPipe=INVALID_HANDLE_VALUE;hPipe=CreateNamedPipeA( pipeName, FILE_FLAG_FIRST_PIPE_INSTANCE, PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, BUFSIZE, BUFSIZE, NMPWAIT_USE_DEFAULT_WAIT, NULL);if (hPipe==INVALID_HANDLE_VALUE){exit(1);}if (GetLastError()==ERROR_ACCESS_DENIED){exit(1);}if (!ImpersonateNamedPipeClient(hPipe)){exit(1);}CloseHandle(hPipe);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){{wchar_t * data;wchar_t * * pointer=(wchar_t * *)ALLOCA(sizeof(wchar_t *));data=L"string";{wchar_t * data=*pointer;printWLine(data);}}}
static void main(){long long * data;_union_type my_union;long long data_badbuf[50];long long data_goodbuf[100];data=data_goodbuf;my_union.a=data;{long long * data=my_union.b;{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printLongLongLine(data[0]);}}}}
static void main(){char data;data=' ';data=5;b_main_sink(data);}void b_main_sink(char data){c_main_sink(data);}void c_main_sink(char data){d_main_sink(data);}void d_main_sink(char data){{char result=data * 2;printHexCharLine(result);}}
static void main(){twoints * data;data=NULL;data=new twoints;main_sink(data);}void main_sink(twoints * data){delete data;}
static void main(){unsigned char data;unsigned char data_array[5];data=' ';data=5;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(unsigned char data_array[]){unsigned char data=data_array[2];{unsigned char result=data+1;printHexUnsignedCharLine(result);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{wchar_t dest[50]=L"";memcpy(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t src[100];wcscat(data, src);printWLine(data);delete [] data;}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;{wchar_t * data_copy=data;wchar_t * data=data_copy;if (wcsstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"C:\\Windows\\System32\\winsrv.dll");my_union.a=data;{wchar_t * data=my_union.b;{HMODULE hModule;hModule=LoadLibraryW(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}}
void main_sink(twoints * * data);static void main(){twoints * data;{twoints * data_buf=new twoints[100];{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}main_sink(&data);}void main_sink(twoints * * data_ptr){twoints * data=*data_ptr;printStructLine(&data[0]);delete [] data;}
static void main(){void * data;twoints data_goodbuf;int data_badbuf=100;data_goodbuf.a=0;data_goodbuf.b=0;data=&data_goodbuf;{void * data_copy=data;void * data=data_copy;printStructLine((twoints *)data);}}
static void main(){int data;data=-1;fscanf (stdin, "%d", &data);b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){{int result=-1;if (data <=(int)sqrt((int)INT_MAX)){result=data * data;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){int data;data=-1;data=b_main_source(data);{int result=data+1;printIntLine(result);}}int b_main_source(int data){data=5;return data;}
static void main(){FILE * data;data=NULL;data=WFOPEN(L"file.txt", L"w+");if (data!=NULL){fclose(data);}}
static void main(){{charvoid * cv_struct=(charvoid *)malloc(sizeof(charvoid));cv_struct->y=SRC_STR;printLine((char *)cv_struct->y);memcpy(cv_struct->x, SRC_STR, sizeof(cv_struct->x));printLine((char *)cv_struct->x);printLine((char *)cv_struct->y);free(cv_struct);}}
static void main(){int count;_union_type my_union;count=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;count=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}my_union.a=count;{int count=my_union.b;{size_t i=0;if (count > 0 && count <=20){for (i=0;i < (size_t)count;i++){printLine("Hello");}}}}}
static void main_source(twoints * &data){{int i;for(i=0;i<10;i++){data[i].a=i;data[i].b=i;}}}static void main(){twoints * data;data=new twoints[10];main_source(data);{int i;for(i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}delete [] data;}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;{int data=*data_ptr1;data=7;}{int data=*data_ptr2;{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}}
static void main_sink(twoints * data){}static void main(){twoints * data;data=NULL;data=new twoints;data->a=1;data->b=2;delete data;main_sink(data);}
static void main(){char * data;data=NULL;{char mystring[]="mystring";data=strdup(mystring);}main_data=data;main_sink();}void main_sink(){char * data=main_data;free(data);}
static void main(){twoints * data;data=NULL;main_source(data);free(data);}void main_source(twoints * &data){data=NULL;data=(twoints *)realloc(data, 100*sizeof(twoints));}
static void main(){int data;data=-1;data=RAND32();{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}
void b_main_sink();static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{char src[100];memcpy(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){_spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main_sink(char data){{char result=data+1;printHexCharLine(result);}}static void main(){char data;data=' ';data=5;main_sink(data);}
void b_main_sink(int * data);static void main(){int data;data=-1;data=100-1;b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main_sink(){int data=_main_data;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}static void main(){int data;data=-1;data=100-1;_main_data=data;main_sink();}
static void main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}main_sink(data);}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];data[0].a=0;data[0].b=0;printIntLine(data[0].a);printIntLine(data[0].b);main_sink_b(data);}void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_c(twointsclass * data){delete[] data;}
static void main_sink(void * data){{size_t data_len=strlen((char *)data);void * data_dest=(void *)calloc(data_len+1, 1);memcpy(data_dest, data, (data_len+1));printLine((char *)data_dest);free(data_dest);}}static void main(){void * data;data=NULL;data=CHAR_STRING;main_sink(data);}
static void main_sink(){int data=_main_data;assert(data > ASSERT_VALUE);}static void main(){int data;data=-1;data=ASSERT_VALUE+1;_main_data=data;main_sink();}
static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}my_union.a=data;{char * data=my_union.b;printf("%s\n", data);}}
static void main_sink(){wchar_t * data=main_data;{wchar_t dest[50]=L"";wcscat(dest, data);printWLine(data);delete [] data;}}static void main(){wchar_t * data;data=new wchar_t[100];main_data=data;main_sink();}
static void main_sink(char * data){delete data;}static void main(){char * data;data=NULL;data=new char;main_sink(data);}
static void main_sink(int data){{wchar_t data_buf[10]=L"AAAAAAAAA";if (data >=0){printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}static void main(){int data;data=7;main_sink(data);}
static void main(){twoints * data;data=NULL;data=new twoints;data->a=0;data->b=0;printStructLine(data);main_sink_b(data);}void main_sink_b(twoints * data){main_sink_c(data);}void main_sink_c(twoints * data){main_sink_d(data);}void main_sink_d(twoints * data){main_sink_e(data);}void main_sink_e(twoints * data){delete data;}
static void main(){unsigned char data;_union_type my_union;data=' ';data=5;my_union.a=data;{unsigned char data=my_union.b;{unsigned char result=data * 2;printHexUnsignedCharLine(result);}}}
static void main(){{wchar_t data_buf[100]=L"";wchar_t * data=data_buf;if (swscanf(SRC, L"%99s\0", data)==EOF){printLine("swscanf failed!");}}}
static void main(){if(global_returns_t_or_f()){{if (fwrite((wchar_t *)L"string", sizeof(wchar_t), wcslen(L"string"), stdout)!=wcslen(L"string")){printLine("fwrite failed!");exit(1);}}}else{{if (fwrite((wchar_t *)L"string", sizeof(wchar_t), wcslen(L"string"), stdout)!=wcslen(L"string")){printLine("fwrite failed!");exit(1);}}}}
static void main(){wchar_t * data;wchar_t * &data_ref=data;data=NULL;data=new wchar_t[100];{wchar_t * data=data_ref;delete [] data;}}
void b_main_sink(short data);static void main(){short data;data=0;data=100-1;b_main_sink(data);}void c_main_sink(short data);void b_main_sink(short data){c_main_sink(data);}void d_main_sink(short data);void c_main_sink(short data){d_main_sink(data);}void e_main_sink(short data);void d_main_sink(short data){e_main_sink(data);}void e_main_sink(short data){{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]="";data=data_buf;strcpy(data, "15");func_ptr(data);}void b_main_sink(char * data){{int i, n, v;if (sscanf(data, "%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main(){int * data;data=NULL;data=new int[100];data[0]=5;printIntLine(data[0]);main_sink(&data);}void main_sink(void * void_data_ptr){int * * data_ptr=(int * *)void_data_ptr;int * data=(*data_ptr);delete[] data;}
static void main(){char data;char data_array[5];data=' ';data=5;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char data_array[]){char data=data_array[2];{char result=data * 2;printHexCharLine(result);}}
static void main(){FILE * data;data=NULL;data=WFOPEN(L"file.txt", L"w+");{FILE * data_copy=data;FILE * data=data_copy;if (data!=NULL){fclose(data);}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(&data);}static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, data, args);va_end(args);printLine(dest);}}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);main_vasink(data, data);}
static void main_sink(){wchar_t * data=_main_data;{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");_main_data=data;main_sink();}
void b_main_sink(short data);static void main(){short data;data=0;data=100-1;b_main_sink(data);}void c_main_sink(short data);void b_main_sink(short data){c_main_sink(data);}void d_main_sink(short data);void c_main_sink(short data){d_main_sink(data);}void e_main_sink(short data);void d_main_sink(short data){e_main_sink(data);}void e_main_sink(short data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, data);printWLine(dest);}}
static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;strcat(data, "*.*");my_union.a=data;{char * data=my_union.b;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);wprintf(L"%s\n", data);}wchar_t * b_main_source(wchar_t * data){{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}return data;}
static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}void b_main_sink(char * data){{int i, n, v;if (sscanf(data, "%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
void b_main_sink(FILE * data);static void main(){FILE * data;data=NULL;data=fopen("BadSource_fopen.txt", "w+");b_main_sink(data);}void c_main_sink(FILE * data);void b_main_sink(FILE * data){c_main_sink(data);}void d_main_sink(FILE * data);void c_main_sink(FILE * data){d_main_sink(data);}void d_main_sink(FILE * data){if (data!=NULL){fclose(data);}}
static void main(){unsigned char data;data=' ';data=b_main_source(data);{unsigned char result=data-1;printHexUnsignedCharLine(result);}}unsigned char b_main_source(unsigned char data){data=5;return data;}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100];data=data_buf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{char dest[50]="";_snprintf(dest, strlen(data), "%s", data);printLine(data);}}
static void main(){char data;data=' ';data=(char)rand();{char result=-1;if (data <=(char)sqrt((char)CHAR_MAX)){result=data * data;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static char * main_source(char * data){return data;}static void main(){char * data;data=new char[100];data=main_source(data);{char dest[50]="";strncpy(dest, data, strlen(data));printLine(data);delete [] data;}}
static void main(){unsigned int data;data=0;data=UINT_MAX;b_main_sink(data);}void b_main_sink(unsigned int data){c_main_sink(data);}void c_main_sink(unsigned int data){d_main_sink(data);}void d_main_sink(unsigned int data){{unsigned int result=-1;if (data < UINT_MAX){result=data+1;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){int * data;data=NULL;data=main_source(data);delete data;}int * main_source(int * data){data=new int;printIntLine(*data);return data;}
static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';if(global_returns_t_or_f()){data=data_buf;}else{data=data_buf;}{wchar_t dest[100];memmove(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{wchar_t dest[100];memmove(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){int data;data=-1;data=5;{int data_copy=data;int data=data_copy;{int result=data * data;printIntLine(result);}}}
static void main_sink(){char * data=_main_data;_spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_main_data=data;main_sink();}
static void main_sink(char * data){{char dest[100];memcpy(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}func_ptr(data);}
static void main(){short data;short *data_ptr1=&data;short *data_ptr2=&data;data=0;{short data=*data_ptr1;data=100-1;}{short data=*data_ptr2;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}}
static void main_sink(FILE * data){if (data!=NULL){fclose(data);}}static void main(){FILE * data;void (*func_ptr) (FILE *)=main_sink;data=NULL;data=freopen("BadSource_freopen.txt","w+",stdin);func_ptr(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(short data_array[]);static void main(){short data;short data_array[5];data=-1;data=CHAR_MAX-5;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(short data_array[]){short data=data_array[2];{char c=(char)data;printHexCharLine(c);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){_wsystem(data);}
void b_main_sink(void * data);static void main(){void * data;void (*func_ptr) (void *)=b_main_sink;twoints data_goodbuf;int data_badbuf=100;data_goodbuf.a=0;data_goodbuf.b=0;data=&data_goodbuf;func_ptr(data);}void b_main_sink(void * data){printStructLine((twoints *)data);}
static void main(){wchar_t * data;data=NULL;wchar_t data_good;data=&data_good;printHexCharLine((char)*data);main_data=data;main_sink();}void main_sink(){wchar_t * data=main_data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_t_or_f()){data=PASSWORD;}else{data=PASSWORD;}if(global_returns_t_or_f()){if (wcsstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}else{if (wcsstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}}
static void main(){int data;fscanf (stdin, "%d", &data);b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0 && data < 10){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){twointsclass * data;twointsclass * *data_ptr1=&data;twointsclass * *data_ptr2=&data;data=NULL;{twointsclass * data=*data_ptr1;data=new twointsclass;data->a=1;data->b=2;}{twointsclass * data=*data_ptr2;printIntLine(data->a);}}
static void main(){if(global_returns_t_or_f()){{wchar_t data_buf[100]=L"";wchar_t * data=data_buf;printLine("Please enter a string: ");if (fgetws(data, 100, stdin)==NULL){printLine("fgetws failed!");exit(1);}printWLine(data);}}else{{wchar_t data_buf[100]=L"";wchar_t * data=data_buf;printLine("Please enter a string: ");if (fgetws(data, 100, stdin)==NULL){printLine("fgetws failed!");exit(1);}printWLine(data);}}}
void b_main_sink(int data);static void main(){int data;data=-1;data=CHAR_MAX-5;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void d_main_sink(int data);void c_main_sink(int data){d_main_sink(data);}void e_main_sink(int data);void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{short s=(short)data;printf("%hd\n", s);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}wprintf(L"%s\n", data);}
static void main_sink(long long * data){delete data;}static void main(){long long * data;void (*func_ptr) (long long *)=main_sink;data=NULL;data=new long long;func_ptr(data);}
static void main(){int data;data=-1;main_source(data);{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}void main_source(int &data){{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}}
static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';if(global_returns_t_or_f()){data=data_buf;}else{data=data_buf;}{char dest[100];strncpy(dest, data, strlen(dest));dest[100-1]='\0';printLine(dest);}}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{char dest[50]="";memmove(dest, data, strlen(data)*sizeof(char));printLine(data);}}
static void main(){char * data;char data_buf[250]="PATH=";data=data_buf;strcat(data, NEW_PATH);PUTENV(data);}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=CHAR_MAX-5;}{int data=*data_ptr2;{short s=(short)data;printf("%hd\n", s);}}}
void main_sink_b(char * data);static void main(){char * data;{char * data_buf=new char[100];data=data_buf;}main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_d(char * data);void main_sink_c(char * data){main_sink_d(data);}void main_sink_e(char * data);void main_sink_d(char * data){main_sink_e(data);}void main_sink_e(char * data){printLine(data);delete [] data;}
static void main_sink(wchar_t * data){{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}printWLine(data);free(data);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));func_ptr(data);}
void b_main_sink(int * data);static void main(){int * data;void (*func_ptr) (int *)=b_main_sink;{int * data_buf=(int *)malloc(100*sizeof(int));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}func_ptr(data);}void b_main_sink(int * data){printIntLine(data[0]);free(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}{wchar_t * data_copy=data;wchar_t * data=data_copy;{int i, n, v;if (swscanf(data, L"%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}}
static void main(){char * data;data=NULL;{char data_goodbuf[100];data=data_goodbuf;strcpy(data, "A String");printLine(data);}}
void b_main_sink(short data);static void main(){short data;data=0;data=100-1;b_main_sink(data);}void c_main_sink(short data);void b_main_sink(short data){c_main_sink(data);}void c_main_sink(short data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "C:\\Windows\\System32\\winsrv.dll");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{HMODULE hModule;hModule=LoadLibraryA(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{int result=-1;if (data <=(int)sqrt((int)INT_MAX)){result=data * data;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){twoints * data;_union_type my_union;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));my_union.a=data;{twoints * data=my_union.b;{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memcpy(data, src, 100*sizeof(twoints));printStructLine(&data[0]);free(data);}}}
static void main(){wchar_t * data;data=NULL;data=b_main_source(data);printWLine(data);}wchar_t * b_main_source(wchar_t * data){data=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data, L'A', 100-1);data[100-1]=L'\0';return data;}
static void main(){int data;data=-1;data=main_source(data);{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}int main_source(int data){data=20;return data;}
static void main(){char * data;char * data_array[5];char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}data_array[2]=data;b_main_sink(data_array);}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, "%s", args);va_end(args);}}void b_main_sink(char * data_array[]){char * data=data_array[2];main_vasink(data, data);}
void _main_sink(int * data){{int data_src[10]={0};memmove(data, data_src, 10*sizeof(int));printIntLine(data[0]);free(data);}}static void main(){int * data;data=NULL;data=(int *)malloc(10*sizeof(int));_main_sink(data);}
void b_main_sink();static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{char dest[100];memset(dest, 'C', 100-1);memmove(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);}}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data, L'A', 100-1);data[100-1]=L'\0';{wchar_t * data_copy=data;wchar_t * data=data_copy;printWLine(data);}}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{size_t i, dest_sz;wchar_t dest[100];wmemset(dest, L'C', 100-1);dest_sz=wcslen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);free(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, data);printWLine(dest);}}
static void main(){bad_struct data;linked_list head={&head, &head};data.list.next=head.next;data.list.prev=&head;head.next=&data.list;head.next->prev=&data.list;* */prev=data.list.prev;next=data.list.next;prev->next=next;next->prev=prev;}
static void main_sink(char * data){{char src[100];_snprintf(data, 100, "%s", src);printLine(data);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;func_ptr(data);}
static void main(){char * data;data=NULL;data=new char[100];main_data=data;main_sink();}void main_sink(){char * data=main_data;delete [] data;}
static void main(){int data;data=-1;data=100-1;{int data_copy=data;int data=data_copy;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}}
static void main_sink(){char * data=_main_data;_spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_main_data=data;main_sink();}
static void main(){int data;data=-1;data=100-1;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
static void main(){if(global_returns_t_or_f()){{twoints data;twoints * pointer=(twoints *)ALLOCA(sizeof(twoints));data.a=1;data.b=2;{twoints data=*pointer;printIntLine(data.a);printIntLine(data.b);}}}else{{twoints data;twoints * pointer=(twoints *)ALLOCA(sizeof(twoints));data.a=1;data.b=2;{twoints data=*pointer;printIntLine(data.a);printIntLine(data.b);}}}}
static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));data[0]=L'\0';{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}{size_t i;for (i=0;i < wcslen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}
static twoints * main_source(twoints * data){data=(twoints *)malloc(100*sizeof(twoints));{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}return data;}static void main(){twoints * data;data=NULL;data=main_source(data);printStructLine(&data[0]);}
static void main(){int data;data=-1;data=5;{int result=data+1;printIntLine(result);}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]="";data=data_buf;{char * data=*data_ptr1;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}}{char * data=*data_ptr2;{char dest[100]="";SNPRINTF(dest, 100-1, "%s", data);printLine(dest);}}}
static void main(){long long * data;data=NULL;if(global_returns_t_or_f()){data=new long long;}else{data=new long long;}if(global_returns_t_or_f()){delete data;}else{delete data;}}
static void main(){short data;data=0;data=100-1;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]=L'\0';printWLine(data);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){_wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){int count;count=-1;fscanf (stdin, "%d", &count);b_main_sink(count);}void b_main_sink(int count){c_main_sink(count);}void c_main_sink(int count){d_main_sink(count);}void d_main_sink(int count){{size_t i=0;FILE *file=NULL;const char *filename="output_good.txt";if (count > 0 && count <=20){file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}}
static void main(){wchar_t * data;_union_type my_union;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;my_union.a=data;{wchar_t * data=my_union.b;{wchar_t dest[100];wmemset(dest, L'C', 100-1);memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}}
static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));memset(data, 'A', 100-1);data[100-1]='\0';free(data);_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);{char dest[100]="";SNPRINTF(dest, 100-1, "%s", data);printLine(dest);}}char * b_main_source(char * data){{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}return data;}
static void main(){double * data;data=(double *)malloc(10*sizeof(double));{int i;for(i=0;i<10;i++){data[i]=(double)i;}}b_main_sink(&data);}void b_main_sink(double * * data_ptr){double * data=*data_ptr;{int i;for(i=0;i<10;i++){printDoubleLine(data[i]);}}}
static void main(){FILE * data;data=NULL;data=freopen("BadSource_freopen.txt","w+",stdin);if(global_returns_t_or_f()){if (data!=NULL){fclose(data);}}else{if (data!=NULL){fclose(data);}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{char dest[100]="";SNPRINTF(dest, 100-1, "%s", data);printLine(dest);}}
void b_main_sink(int * data);static void main(){int data;data=-1;data=100-1;b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
static void main(){int * data;struct_type my_struct;data=NULL;data=new int[100];delete [] data;my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){int * data=my_struct.a;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, L"%s", args);va_end(args);printWLine(dest);}}void e_main_sink(wchar_t * data){main_vasink(data, data);}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{char src[100];strncpy(data, src, 100);data[100-1]='\0';printLine(data);}}
static void main(){char * data;data=NULL;if(global_returns_t_or_f()){data=(char *)malloc(100*sizeof(char));}else{data=(char *)malloc(100*sizeof(char));}if(global_returns_t_or_f()){free(data);}else{free(data);}}
static void main(){wchar_t * data;_union_type my_union;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;my_union.a=data;{wchar_t * data=my_union.b;{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{char src[100];strncpy(data, src, 100);data[100-1]='\0';printLine(data);}}
static void main(){twoints * data;data=NULL;main_source(data);}void main_source(twoints * &data){twoints data_good;data=&data_good;data->a=0;data->b=0;printStructLine(data);}
static void main_sink(){twoints * data=_main_data;printStructLine(&data[0]);free(data);}static void main(){twoints * data;{twoints * data_buf=(twoints *)malloc(100*sizeof(twoints));{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}_main_data=data;main_sink();}
static void main(){int * data;data=NULL;if(global_returns_t_or_f()){data=(int *)calloc(100, sizeof(int));}else{data=(int *)calloc(100, sizeof(int));}if(global_returns_t_or_f()){free(data);}else{free(data);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100];data=data_buf;b_main_sink(data);}void b_main_sink(char * data){{char dest[50]="";strncpy(dest, data, strlen(data));printLine(data);}}
static void main_source(twointsclass * &data){for(int i=0;i<10;i++){data[i].a=i;data[i].b=i;}}static void main(){twointsclass * data;data=(twointsclass *)malloc(10*sizeof(twointsclass));main_source(data);for(int i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");func_ptr(data);}void b_main_sink(wchar_t * data){_wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main_sink(){char * data=_main_data;{size_t i;char dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);}}static void main(){char * data;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}_main_data=data;main_sink();}
static void main_sink(){char * data=_main_data;{char src[100];memcpy(data, src, 100*sizeof(char));printLine(data);}}static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;_main_data=data;main_sink();}
static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=-1;data=RAND32();func_ptr(data);}void b_main_sink(int data){{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){unsigned char data;data=' ';data=UCHAR_MAX;b_main_sink(data);}void b_main_sink(unsigned char data){c_main_sink(data);}void c_main_sink(unsigned char data){{unsigned char result=-1;if (data < UCHAR_MAX){result=data+1;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}{char * data_copy=data;char * data=data_copy;fprintf(stdout, "%s\n", data);}}
void b_main_sink(char * * data);static void main(){char * data;data=(char *)malloc(100*sizeof(char));b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char dest[50]="";strcpy(dest, data);printLine(data);free(data);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnv(_P_WAIT, COMMAND_INT_PATH, args);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");func_ptr(data);}
void b_main_sink();static void main(){wchar_t * password;wchar_t password_buf[100]=L"";password=password_buf;wcscpy(password, L"Password1234!");_main_data=password;b_main_sink();}void b_main_sink(){wchar_t * password=_main_data;{HANDLE pHandle;wchar_t * username=L"User";wchar_t * domain=L"Domain";if (LogonUserW( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}
static void main(){twoints * data;twoints * data_array[5];data=NULL;{twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine(&data[0]);}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(twoints * data_array[]){twoints * data=data_array[2];}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{wchar_t dest[100];wmemset(dest, L'C', 100-1);memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){short data;data=0;data=100-1;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main(){wchar_t * data;data=NULL;if(global_returns_t_or_f()){data=(wchar_t *)malloc(100*sizeof(wchar_t));}else{data=(wchar_t *)malloc(100*sizeof(wchar_t));}{wchar_t src[100];wcscpy(data, src);printWLine(data);free(data);}}
static void main(){twointsclass * data;data=NULL;if(global_returns_t_or_f()){data=(twointsclass *)malloc(100*sizeof(twointsclass));}else{data=(twointsclass *)malloc(100*sizeof(twointsclass));}if(global_returns_t_or_f()){free(data);}else{free(data);}}
static void main(){int data;data=-1;data=5;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){{int result=data+1;printIntLine(result);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, L"%s", args);va_end(args);}}static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}}{wchar_t * data=*data_ptr2;main_vasink(data, data);}}
void b_main_sink(char * data);static void main(){char * data;data=(char *)malloc(100*sizeof(char));b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{char dest[50]="";_snprintf(dest, strlen(data), "%s", data);printLine(data);free(data);}}
static void main(){int * data;data=NULL;data=new int;main_sink_b(data);}void main_sink_b(int * data){main_sink_c(data);}void main_sink_c(int * data){main_sink_d(data);}void main_sink_d(int * data){main_sink_e(data);}void main_sink_e(int * data){printIntLine(*data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=L"P";b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[250]="PATH=";data=data_buf;strcat(data, NEW_PATH);b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;PUTENV(data);}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main_sink(unsigned int data){{unsigned int result=data * 2;printUnsignedLine(result);}}static void main(){unsigned int data;void (*func_ptr) (unsigned int)=main_sink;data=0;data=5;func_ptr(data);}
static void main(){char * data;data=NULL;data=main_source(data);free(data);}char * main_source(char * data){data=NULL;data=(char *)realloc(data, 100*sizeof(char));return data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;if(global_returns_t_or_f()){{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}}else{{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}}if(global_returns_t_or_f()){{char dest[100]="";SNPRINTF(dest, 100-1, "%s", data);printLine(dest);}}else{{char dest[100]="";SNPRINTF(dest, 100-1, "%s", data);printLine(dest);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){if (wcsstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;{char * data_copy=data;char * data=data_copy;if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}}
static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");my_struct.a=data;b_main_sink(my_struct);}static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, data, args);va_end(args);printLine(dest);}}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;main_vasink(data, data);}
static void main(){int data;data=-1;data=RAND32();{int data_copy=data;int data=data_copy;{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}}
static void main_sink(char * data){{char src[100];memmove(data, src, 100*sizeof(char));printLine(data);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;func_ptr(data);}
static void main(){int * data;data=NULL;if(global_returns_t_or_f()){int data_good;data=&data_good;printIntLine(*data);}else{int data_good;data=&data_good;printIntLine(*data);}if(global_returns_t_or_f()){}else{}}
static void main(){int data;data=7;b_main_sink(data);}void b_main_sink(int data){{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t src[100];wcsncpy(data, src, 100);data[100-1]=L'\0';printWLine(data);}}
static void main(){char data;data=' ';data=5;{char result=data * 2;printHexCharLine(result);}}
void b_main_sink(short data);static void main(){short data;data=0;data=100-1;b_main_sink(data);}void c_main_sink(short data);void b_main_sink(short data){c_main_sink(data);}void d_main_sink(short data);void c_main_sink(short data){d_main_sink(data);}void d_main_sink(short data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
void main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;data=new char[100];func_ptr(data);}void main_sink(char * data){{char dest[100];memset(dest, 'C', 100-1);memcpy(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);delete [] data;}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, L"%s", args);va_end(args);}}void c_main_sink(wchar_t * data){main_vasink(data, data);}
static char * main_source(char * data){strcat(data, "*.*");return data;}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);_spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
void main_sink(struct_type my_struct);static void main(){char * data;struct_type my_struct;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){char * data=my_struct.a;{char src[100];strncpy(data, src, 100);data[100-1]='\0';printLine(data);}}
static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}my_union.a=data;{char * data=my_union.b;{char dest[100]="";SNPRINTF(dest, 100-1, "%s", data);printLine(dest);}}}
static void main(){wchar_t * data;union_type my_union;data=NULL;data=new wchar_t[100];my_union.a=data;{wchar_t * data=my_union.b;delete [] data;}}
static int main_source(int data){{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}return data;}static void main(){int data;data=-1;data=main_source(data);{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}
void b_main_sink(FILE * data);static void main(){FILE * data;void (*func_ptr) (FILE *)=b_main_sink;data=NULL;data=fopen("BadSource_fopen.txt", "w+");func_ptr(data);}void b_main_sink(FILE * data){if (data!=NULL){fclose(data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{char dest[100]="";SNPRINTF(dest, 100-1, data);printLine(dest);}}
static void main(){long long * data;data=NULL;long long data_good;data=&data_good;printLongLongLine(*data);main_sink_b(data);}void main_sink_b(long long * data){main_sink_c(data);}void main_sink_c(long long * data){}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{FILE *pipe;pipe=POPEN(data, "wb");if (pipe!=NULL) PCLOSE(pipe);}}
static void main_sink(){int data=_main_data;{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0 && data < 10){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}static void main(){int data;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}_main_data=data;main_sink();}
static void main_sink(){char * data=_main_data;{char src[100];strncpy(data, src, 100);printLine(data);}}static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;_main_data=data;main_sink();}
void _main_sink(wchar_t * data){{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]=L'\0';printWLine(data);}}static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}_main_sink(data);}
static void main(){twointsclass * data;twointsclass data_uninit_array[10];data=data_uninit_array;for(int i=0;i<10;i++){data[i].a=i;data[i].b=i;}for(int i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}
void main_sink(twoints * data);static void main(){twoints * data;void (*func_ptr) (twoints *)=main_sink;{twoints * data_buf=new twoints[100];{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}func_ptr(data);}void main_sink(twoints * data){printStructLine(&data[0]);delete [] data;}
static void main_sink(wchar_t * data){{size_t src_len;wchar_t src[100];src_len=wcslen(src);wcsncat(data, src, src_len);printWLine(data);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100];data=data_buf;func_ptr(data);}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){int data;data=-1;data=CHAR_MAX-5;{short s=(short)data;printf("%hd\n", s);}}
void main_sink_b(char * data);static void main(){char * data;data=NULL;data=new char[100];main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_d(char * data);void main_sink_c(char * data){main_sink_d(data);}void main_sink_e(char * data);void main_sink_d(char * data){main_sink_e(data);}void main_sink_e(char * data){{char src[100];strncpy(data, src, 100);printLine(data);delete [] data;}}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100];data=data_buf;func_ptr(data);}void b_main_sink(char * data){{char dest[50]="";_snprintf(dest, strlen(data), "%s", data);printLine(data);}}
static void main(){int * data;union_type my_union;data=NULL;data=new int[100];my_union.a=data;{int * data=my_union.b;delete [] data;}}
static void main_sink(){char * data=main_data;}static void main(){char * data;data=NULL;data=new char[100];memset(data, 'A', 100-1);data[100-1]='\0';delete [] data;main_data=data;main_sink();}
void b_main_sink(short * data);static void main(){short data;data=-1;data=CHAR_MAX-5;b_main_sink(&data);}void b_main_sink(short * data_ptr){short data=*data_ptr;{char c=(char)data;printHexCharLine(c);}}
static void main(){int data;data=-1;fscanf (stdin, "%d", &data);{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));free(data);}
void b_main_sink(int data);static void main(){int data;data=-1;data=7;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void d_main_sink(int data);void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){printIntLine(100/data);}
static void main(){int data;data=-1;data=b_main_source(data);{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}int b_main_source(int data){fscanf (stdin, "%d", &data);return data;}
static void main(){twointsclass * data;data=new twointsclass[10];for(int i=0;i<10;i++){data[i].a=i;data[i].b=i;}main_sink(&data);}void main_sink(twointsclass * * data_ptr){twointsclass * data=*data_ptr;for(int i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}
static void main(){long long * data;data=NULL;data=main_source(data);delete data;}long long * main_source(long long * data){data=new long long;return data;}
void b_main_sink(void * void_data_ptr);static void main(){int data;data=-1;data=7;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);printIntLine(100 % data);}
static short main_source(short data){data=100-1;return data;}static void main(){short data;data=0;data=main_source(data);{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
static void main_sink(){char * data=main_data;free(data);}static void main(){char * data;data=NULL;data=NULL;data=(char *)realloc(data, 100*sizeof(char));main_data=data;main_sink();}
static void main(){unsigned char data;data=' ';data=5;b_main_sink(data);}void b_main_sink(unsigned char data){c_main_sink(data);}void c_main_sink(unsigned char data){d_main_sink(data);}void d_main_sink(unsigned char data){{unsigned char result=data * 2;printHexUnsignedCharLine(result);}}
static void main(){int data;_struct_type my_struct;data=-1;data=5;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{int result=data-1;printIntLine(result);}}
static void main(){int data;_union_type my_union;data=RAND32();my_union.a=data;{int data=my_union.b;{char data_buf[10]="AAAAAAAAA";{printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}}
void b_main_sink();static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;fwprintf(stdout, L"%s\n", data);}
static void main_sink(){char * data=main_data;{char dest[100];memcpy(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}main_data=data;main_sink();}
static void main(){char data;data=' ';if(global_returns_t_or_f()){data=5;}else{data=5;}if(global_returns_t_or_f()){{char result=data+1;printHexCharLine(result);}}else{{char result=data+1;printHexCharLine(result);}}}
static void main(){unsigned char data;data=' ';fscanf (stdin, "%hc", &data);b_main_sink(&data);}void b_main_sink(unsigned char * data_ptr){unsigned char data=*data_ptr;{unsigned char result=-1;if (data <=(UCHAR_MAX/2)){result=data * 2;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data, L'A', 100-1);data[100-1]=L'\0';free(data);{wchar_t * data_copy=data;wchar_t * data=data_copy;}}
int b_main_source(int data);static void main(){int data;data=-1;data=b_main_source(data);{char c=(char)data;printHexCharLine(c);}}int b_main_source(int data){data=CHAR_MAX-5;return data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;if (strstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
static void main(){char data;data=' ';data=5;b_main_sink(data);}void b_main_sink(char data){c_main_sink(data);}void c_main_sink(char data){d_main_sink(data);}void d_main_sink(char data){e_main_sink(data);}void e_main_sink(char data){{char result=data+1;printHexCharLine(result);}}
short b_main_source(short data);static void main(){short data;data=0;data=b_main_source(data);{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}short b_main_source(short data){data=100-1;return data;}
static void main_sink(char * data){if (strstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;main_sink(data);}
static void main(){char * data;char data_buf[100];data=data_buf;{char dest[50]="";strncat(dest, data, strlen(data));printLine(data);}}
static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, data, args);va_end(args);printLine(dest);}}static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");{char * data_copy=data;char * data=data_copy;main_vasink(data, data);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[250]=L"PATH=";data=data_buf;wcscat(data, NEW_PATH);b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){PUTENV(data);}
static void main(){twointsclass * data;twointsclass * *data_ptr1=&data;twointsclass * *data_ptr2=&data;data=NULL;{twointsclass * data=*data_ptr1;{twointsclass data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printIntLine(data[0].a);printIntLine(data[0].b);}}{twointsclass * data=*data_ptr2;}}
static void main_sink(int data){printIntLine(100 % data);}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=7;func_ptr(data);}
void main_sink(void * void_data_ptr);static void main(){long long * data;data=NULL;data=new long long[100];main_sink(&data);}void main_sink(void * void_data_ptr){long long * * data_ptr=(long long * *)void_data_ptr;long long * data=(*data_ptr);{memcpy(data, src, 100*sizeof(long long));printLongLongLine(data[0]);delete [] data;}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=(char *)malloc(100*sizeof(char));data[0]='\0';{char * data=*data_ptr1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}}{char * data=*data_ptr2;{size_t i;for (i=0;i < strlen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char dest[100];memmove(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_t_or_f()){wcscat(data, L"*.*");}else{wcscat(data, L"*.*");}{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
static void main_sink(int data){{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=20;func_ptr(data);}
static void main_sink(twointsclass * data){free(data);}static void main(){twointsclass * data;void (*func_ptr) (twointsclass *)=main_sink;data=NULL;data=(twointsclass *)malloc(100*sizeof(twointsclass));func_ptr(data);}
static void main_sink(){char * data=_main_data;if (strstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;_main_data=data;main_sink();}
static void main(){int * data;data=NULL;data=(int *)malloc(100*sizeof(int));{size_t i;for(i=0;i < 100;i++){data[i]=5;}}b_main_sink(data);}void b_main_sink(int * data){c_main_sink(data);}void c_main_sink(int * data){printIntLine(data[0]);}
void _main_sink(char data){{char char_array[4];char_array[0]='x';char_array[1]=data;char_array[2]='z';char_array[3]='\0';printLine(char_array);}}static void main(){char data;data=' ';data='a';_main_sink(data);}
void _main_sink(int data){{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}static void main(){int data;data=-1;data=100-1;_main_sink(data);}
static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));free(data);b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;}
static char * main_source(char * data){data=new char[100];return data;}static void main(){char * data;data=NULL;data=main_source(data);delete [] data;}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, data);printWLine(dest);}}
static wchar_t * main_source(wchar_t * data){{wchar_t data_goodbuf[100];data=data_goodbuf;wcscpy(data, L"A String");printWLine(data);}return data;}static void main(){wchar_t * data;data=NULL;data=main_source(data);}
static void main_sink(wchar_t * data){{wchar_t src[100];wcscpy(data, src);printWLine(data);free(data);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));func_ptr(data);}
void main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=new wchar_t[100];func_ptr(data);}void main_sink(wchar_t * data){{wchar_t dest[50]=L"";wcscpy(dest, data);printWLine(data);delete [] data;}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);if (strncmp(PASSWORD, data, strlen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=NULL;{char * data=*data_ptr1;data=new char[100];}{char * data=*data_ptr2;delete [] data;}}
static void main(){twoints * data;data=NULL;if(global_returns_t_or_f()){data=(twoints *)malloc(100*sizeof(twoints));data[0].a=0;data[0].b=0;printStructLine(&data[0]);}else{data=(twoints *)malloc(100*sizeof(twoints));data[0].a=0;data[0].b=0;printStructLine(&data[0]);}if(global_returns_t_or_f()){free(data);}else{free(data);}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]="";data=data_buf;{char * data=*data_ptr1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}}{char * data=*data_ptr2;{int i, n, v;if (sscanf(data, "%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(&data);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, L"%s", args);va_end(args);}}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);main_vasink(data, data);}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");func_ptr(data);}void b_main_sink(char * data){{FILE *pipe;pipe=POPEN(data, "wb");if (pipe!=NULL) PCLOSE(pipe);}}
void main_sink(twointsclass * data){printIntLine(data[0].a);delete [] data;}static void main(){twointsclass * data;{twointsclass * data_buf=new twointsclass[100];{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}main_sink(data);}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
char * b_main_source(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);_spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}char * b_main_source(char * data){strcat(data, "*.*");return data;}
static void main_sink(){short data=_main_data;{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}static void main(){short data;data=0;data=100-1;_main_data=data;main_sink();}
static void main_source(char * &data){data=new char[100];delete [] data;}static void main(){char * data;data=NULL;main_source(data);}
static void main(){int data;data=-1;data=20;main_sink_b(data);}void main_sink_b(int data){main_sink_c(data);}void main_sink_c(int data){main_sink_d(data);}void main_sink_d(int data){main_sink_e(data);}void main_sink_e(int data){{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}
static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;if(global_returns_t_or_f()){strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");}else{strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");}{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");b_main_sink(data);}void b_main_sink(char * data){{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t;main_sink(&data);}void main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);delete data;}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, data, args);va_end(args);}}static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");my_union.a=data;{wchar_t * data=my_union.b;main_vasink(data, data);}}
void _main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}static void main(){int data;data=-1;data=100-1;_main_sink(data);}
static void main(){int * data;data=NULL;data=(int *)calloc(100, sizeof(int));main_sink(data);}void main_sink(int * data){free(data);}
static void main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnvp(_P_WAIT, COMMAND_INT, args);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;strcat(data, "*.*");func_ptr(data);}
static void main(){try{if (rand()%2==0) throw out_of_range("err1");if (rand()%2==0) throw domain_error("err2");}catch (out_of_range &){printLine("out_of_range");}catch (domain_error &){printLine("domain_error");return;}printLine("ok");}
static void main(){if(global_returns_t_or_f()){{char s[DST_SZ];cin.width(DST_SZ);cin >> s;s[DST_SZ-1]='\0';printLine(s);}}else{{char s[DST_SZ];cin.width(DST_SZ);cin >> s;s[DST_SZ-1]='\0';printLine(s);}}}
static void main(){twoints * data;twoints * data_badbuf=(twoints *)ALLOCA(50*sizeof(twoints));twoints * data_goodbuf=(twoints *)ALLOCA(100*sizeof(twoints));data=data_goodbuf;{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printStructLine(&data[0]);}}}
void b_main_sink(int data);static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=-1;data=100-1;func_ptr(data);}void b_main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main_sink(){int data=main_data;{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}static void main(){int data;data=-1;data=20;main_data=data;main_sink();}
void b_main_sink(int * data);static void main(){int data;data=-1;data=ASSERT_VALUE+1;b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;assert(data > ASSERT_VALUE);}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=5;}{int data=*data_ptr2;{int result=data * 2;printIntLine(result);}}}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}printWLine(data);free(data);}}
void b_main_sink(twoints * data);static void main(){twoints * data;{twoints * data_buf=(twoints *)malloc(100*sizeof(twoints));{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}b_main_sink(data);}void c_main_sink(twoints * data);void b_main_sink(twoints * data){c_main_sink(data);}void d_main_sink(twoints * data);void c_main_sink(twoints * data){d_main_sink(data);}void d_main_sink(twoints * data){printStructLine(&data[0]);free(data);}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{FILE *pipe;pipe=POPEN(data, "wb");if (pipe!=NULL) PCLOSE(pipe);}}
void b_main_sink(char * * data);static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char src[100];memmove(data, src, 100*sizeof(char));printLine(data);}}
static void main(){char data;data=' ';data=5;b_main_sink(data);}void b_main_sink(char data){c_main_sink(data);}void c_main_sink(char data){d_main_sink(data);}void d_main_sink(char data){e_main_sink(data);}void e_main_sink(char data){{char result=data-1;printHexCharLine(result);}}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(int data){{int result=-1;if (data < INT_MAX){result=data+1;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");{FILE *pipe;pipe=POPEN(data, "wb");if (pipe!=NULL) PCLOSE(pipe);}}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(data, args);va_end(args);}}static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");my_union.a=data;{wchar_t * data=my_union.b;main_vasink(data, data);}}
static void main(){{FILE *f;f=FOPEN(L"temp.txt", L"w");if (f!=NULL){fwprintf(f, L"Temporary file");fclose(f);}}}
static void main(){char * data;data=NULL;if(global_returns_t_or_f()){data=(char *)malloc((10+1)*sizeof(char));}else{data=(char *)malloc((10+1)*sizeof(char));}{char data_src[10+1]=SRC_STRING;memmove(data, data_src, strlen(data_src)*sizeof(char));printLine(data);free(data);}}
void _main_sink(char * data){{HMODULE hModule;hModule=LoadLibraryA(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "C:\\Windows\\System32\\winsrv.dll");_main_sink(data);}
void b_main_sink(int data);static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=-1;data=20;func_ptr(data);}void b_main_sink(int data){{size_t i;int *b;b=(int*)malloc(data * sizeof(int));for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);free(b);}}
static char * main_source(char * data){{char * data_buf=(char *)malloc(100*sizeof(char));data=data_buf;}return data;}static void main(){char * data;data=main_source(data);printLine(data);free(data);}
static void main(){char * data;data=NULL;data=new char[100];main_sink(data);}void main_sink(char * data){delete [] data;}
static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_data=data;main_sink();}void main_sink(){wchar_t * data=main_data;delete [] data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{int i, n, v;if (swscanf(data, L"%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static void main_source(twointsclass * &data){for(int i=0;i<(10/2);i++){data[i].a=i;data[i].b=i;}}static void main(){twointsclass * data;data=(twointsclass *)malloc(10*sizeof(twointsclass));main_source(data);for(int i=0;i<10;i++){data[i].a=i;data[i].b=i;}for(int i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}
static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t dest[100];memmove(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}}
static void main(){twoints data;if(global_returns_t_or_f()){data.a=1;data.b=2;}else{data.a=1;data.b=2;}if(global_returns_t_or_f()){printIntLine(data.a);printIntLine(data.b);}else{printIntLine(data.a);printIntLine(data.b);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, data);printWLine(dest);}}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
static void main(){int * data;data=NULL;data=NULL;data=(int *)realloc(data, 100*sizeof(int));data[0]=5;printIntLine(data[0]);b_main_sink(data);}void b_main_sink(int * data){c_main_sink(data);}void c_main_sink(int * data){d_main_sink(data);}void d_main_sink(int * data){e_main_sink(data);}void e_main_sink(int * data){free(data);}
static void main(){int * data;data=NULL;data=new int;{int * data_copy=data;int * data=data_copy;delete data;}}
static int main_source(int data){data=RAND32();return data;}static void main(){int data;data=-1;data=main_source(data);{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));data[0]=L'\0';data=b_main_source(data);{size_t i;for (i=0;i < wcslen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}wchar_t * b_main_source(wchar_t * data){{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}return data;}
static char * main_source(char * data){data=(char *)malloc(100);return data;}static void main(){char * data;data=main_source(data);if (data!=NULL){strcpy(data, "Initialize");printLine(data);free(data);}}
static void main(){unsigned char data;data=' ';data=5;b_main_sink(data);}void b_main_sink(unsigned char data){c_main_sink(data);}void c_main_sink(unsigned char data){d_main_sink(data);}void d_main_sink(unsigned char data){{unsigned char result=data-1;printHexUnsignedCharLine(result);}}
static void main(){int data;data=7;b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{wchar_t data_buf[10]=L"AAAAAAAAA";if (data >=0){printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{size_t i, dest_sz;char dest[100];memset(dest, 'C', 100-1);dest_sz=strlen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);}}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));main_sink_b(data);}void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){free(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));printWLine(data);free(data);}}
static void main(){char * data;void (*func_ptr) (char *, ...)=b_main_vasink;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");func_ptr(data);}void b_main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, data, args);va_end(args);printLine(dest);}}
void b_main_sink(int data);static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=-1;data=CHAR_MAX-5;func_ptr(data);}void b_main_sink(int data){{char c=(char)data;printHexCharLine(c);}}
static void main(){int count;int count_array[5];count=-1;count=RAND32();count_array[2]=count;b_main_sink(count_array);}void b_main_sink(int count_array[]){int count=count_array[2];{size_t i=0;FILE *file=NULL;const char *filename="output_good.txt";if (count > 0 && count <=20){file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");func_ptr(data);}void b_main_sink(wchar_t * data){fwprintf(stdout, data);}
void b_main_sink(long long * data);static void main(){long long * data;data=NULL;data=(long long *)malloc(sizeof(*data));b_main_sink(data);}void c_main_sink(long long * data);void b_main_sink(long long * data){c_main_sink(data);}void d_main_sink(long long * data);void c_main_sink(long long * data){d_main_sink(data);}void e_main_sink(long long * data);void d_main_sink(long long * data){e_main_sink(data);}void e_main_sink(long long * data){printLongLongLine(*data);free(data);}
void main_source(wchar_t * &data);static void main(){wchar_t * data;data=NULL;main_source(data);{wchar_t dest[100];wcsncpy(dest, data, wcslen(dest));dest[100-1]=L'\0';printWLine(dest);}}void main_source(wchar_t * &data){{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}}
static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;free(data);}
static void main_sink(int count){{size_t i=0;if (count > 0 && count <=20){for (i=0;i < (size_t)count;i++){printLine("Hello");}}}}static void main(){int count;count=-1;count=RAND32();main_sink(count);}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);_wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static struct _twoints * main_source(struct _twoints * data){data=new struct _twoints[100];data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);return data;}static void main(){struct _twoints * data;data=NULL;data=main_source(data);delete[] data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
static void main(){char * data;char * &data_ref=data;data=NULL;data=new char[100];{char * data=data_ref;delete [] data;}}
static void main(){int * data;data=NULL;data=(int *)malloc(100*sizeof(int));{size_t i;for(i=0;i < 100;i++){data[i]=5;}}free(data);b_main_sink(data);}void b_main_sink(int * data){c_main_sink(data);}void c_main_sink(int * data){d_main_sink(data);}void d_main_sink(int * data){}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}{char dest[100]="";SNPRINTF(dest, 100-1, "%s", data);printLine(dest);}}
void b_main_sink(void * void_data_ptr);static void main(){int data;data=-1;data=CHAR_MAX-5;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);{char c=(char)data;printHexCharLine(c);}}
static void main_sink(char * data){{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");func_ptr(data);}
static void main(){char data;data=' ';data=5;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * data_ptr=(char *)void_data_ptr;char data=(*data_ptr);{char result=data+1;printHexCharLine(result);}}
static void main_sink(unsigned char data){{unsigned char result=data * 2;printHexUnsignedCharLine(result);}}static void main(){unsigned char data;void (*func_ptr) (unsigned char)=main_sink;data=' ';data=5;func_ptr(data);}
static void main_sink(unsigned int data){{unsigned int result=data * 2;printUnsignedLine(result);}}static void main(){unsigned int data;void (*func_ptr) (unsigned int)=main_sink;data=0;data=5;func_ptr(data);}
static void main(){long long * data;data=NULL;data=(long long *)calloc(100, sizeof(long long));data[0]=5L;printLongLongLine(data[0]);b_main_sink(data);}void b_main_sink(long long * data){free(data);}
static void main(){unsigned int data;data=0;data=5;{unsigned int data_copy=data;unsigned int data=data_copy;{unsigned int result=data * 2;printUnsignedLine(result);}}}
static void main(){int * data;data=NULL;main_source(data);free(data);}void main_source(int * &data){data=(int *)malloc(100*sizeof(int));}
static void main_sink(twointsclass * data){free(data);}static void main(){twointsclass * data;data=NULL;data=NULL;data=(twointsclass *)realloc(data, 100*sizeof(twointsclass));main_sink(data);}
static int main_source(int data){data=5;return data;}static void main(){int data;data=-1;data=main_source(data);{int result=data * 2;printIntLine(result);}}
static void main(){int * data;data=NULL;data=new int[100];main_sink(&data);}void main_sink(void * void_data_ptr){int * * data_ptr=(int * *)void_data_ptr;int * data=(*data_ptr);delete [] data;}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}printLine(data);}}
static void main_sink(){char * data=_main_data;{char src[100];strncpy(data, src, 100);data[100-1]='\0';printLine(data);}}static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;_main_data=data;main_sink();}
static void main(){int count;count=-1;count=20;{size_t i=0;for (i=0;i < (size_t)count;i++){printLine("Hello");}}}
static char * main_source(char * data){strcpy(data, "fixedstringtest");return data;}static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, data, args);va_end(args);printLine(dest);}}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);main_vasink(data, data);}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]="";data=data_buf;{char * data=*data_ptr1;strcpy(data, "C:\\Windows\\System32\\winsrv.dll");}{char * data=*data_ptr2;{HMODULE hModule;hModule=LoadLibraryA(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}}
static void main(){int count;count=-1;count=20;b_main_sink(count);}void b_main_sink(int count){c_main_sink(count);}void c_main_sink(int count){{size_t i=0;for (i=0;i < (size_t)count;i++){printLine("Hello");}}}
static void main(){{twoints data;data.a=1;data.b=2;twoints * pointer=new twoints;{twoints data=*pointer;printIntLine(data.a);printIntLine(data.b);}delete pointer;}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=20;}{int data=*data_ptr2;{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");{char dest[100]="";SNPRINTF(dest, 100-1, data);printLine(dest);}}
static void main(){{char data;char * pointer=(char *)ALLOCA(sizeof(char));data=5;{char data=*pointer;printHexCharLine(data);}}}
static void main(){int data;union_type my_union;data=-1;data=20;my_union.a=data;{int data=my_union.b;{size_t a,i;int *b;b=(int*)new char[a];for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);delete [] b;}}}
void _main_sink(wchar_t * data){{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));printWLine(data);}}static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;_main_sink(data);}
static void main_sink(){char * data=main_data;delete data;}static void main(){char * data;data=NULL;data=new char;main_data=data;main_sink();}
static void main_sink(wchar_t * data){{size_t i;for (i=0;i < wcslen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=(wchar_t *)malloc(100*sizeof(wchar_t));data[0]=L'\0';{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}
static void main(){long long * data;data=NULL;main_source(data);}void main_source(long long * &data){{long long data_goodbuf[100];data=data_goodbuf;data[0]=5L;printLongLongLine(data[0]);}}
void _main_sink(char * data){{FILE *pipe;pipe=POPEN(data, "wb");if (pipe!=NULL) PCLOSE(pipe);}}static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");_main_sink(data);}
static void main(){int data;data=-1;data=20;{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}
static void main(){unsigned int data;data=0;data=0;b_main_sink(data);}void b_main_sink(unsigned int data){{unsigned int result=0;if (data > 0){result=data-1;printUnsignedLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;data=NULL;{wchar_t * data=*data_ptr1;data=new wchar_t[100];}{wchar_t * data=*data_ptr2;delete [] data;}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_t_or_f()){wcscat(data, L"*.*");}else{wcscat(data, L"*.*");}EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;main_sink_b(data);}void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_c(twointsclass * data){main_sink_d(data);}void main_sink_d(twointsclass * data){main_sink_e(data);}void main_sink_e(twointsclass * data){delete data;}
static void main(){int * data;data=NULL;data=new int[100];main_sink_b(data);}void main_sink_b(int * data){main_sink_c(data);}void main_sink_c(int * data){delete [] data;}
static void main(){short data;_union_type my_union;data=-1;data=CHAR_MAX-5;my_union.a=data;{short data=my_union.b;{char c=(char)data;printHexCharLine(c);}}}
static void main(){wchar_t * data;struct_type my_struct;data=NULL;data=new wchar_t;my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){wchar_t * data=my_struct.a;delete data;}
static void main_sink(char data){{char result=-1;if (data < CHAR_MAX){result=data+1;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}static void main(){char data;data=' ';data=(char)rand();main_sink(data);}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;{char * data=*data_ptr1;}{char * data=*data_ptr2;{char dest[50]="";memmove(dest, data, strlen(data)*sizeof(char));printLine(data);}}}
void _main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_main_sink(data);}
static void main_sink(char * data){{size_t i;for (i=0;i < strlen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=(char *)malloc(100*sizeof(char));data[0]='\0';{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}
static void main(){unsigned char data;data=' ';data=5;b_main_sink(data);}void b_main_sink(unsigned char data){c_main_sink(data);}void c_main_sink(unsigned char data){{unsigned char result=data-1;printHexUnsignedCharLine(result);}}
static void main(){wchar_t * data;_union_type my_union;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));my_union.a=data;{wchar_t * data=my_union.b;{wchar_t src[100];_snwprintf(data, 100, L"%s", src);printWLine(data);free(data);}}}
static void main(){short data;data=0;data=100-1;{short data_copy=data;short data=data_copy;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}}
static void main(){{int x;int y;x=(rand() % 3);y=0;if (x==0){printLine("x==0");y=1;}if (y) printLine("x was 0\n");}}
static void main(){char * data;char * data_array[5];data=NULL;data=NULL;data=(char *)realloc(data, 100*sizeof(char));strcpy(data, "A String");printLine(data);data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];free(data);}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;func_ptr(data);}void b_main_sink(char * data){{size_t i;char dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);}}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){twoints * data;union_type my_union;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));my_union.a=data;{twoints * data=my_union.b;free(data);}}
static void main_sink(unsigned int data){{unsigned int result=data+1;printUnsignedLine(result);}}static void main(){unsigned int data;void (*func_ptr) (unsigned int)=main_sink;data=0;data=5;func_ptr(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}wchar_t * b_main_source(wchar_t * data){{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}return data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnvp(_P_WAIT, COMMAND_INT, args);}}
void b_main_sink(void * void_password_ptr);static void main(){wchar_t * password;wchar_t password_buf[100]=L"";password=password_buf;wcscpy(password, L"Password1234!");b_main_sink(&password);}void b_main_sink(void * void_password_ptr){wchar_t * * password_ptr=(wchar_t * *)void_password_ptr;wchar_t * password=(*password_ptr);{HANDLE pHandle;wchar_t * username=L"User";wchar_t * domain=L"Domain";if (LogonUserW( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}
static void main(){int * data;data=NULL;data=(int *)malloc(100*sizeof(int));data[0]=5;printIntLine(data[0]);b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * * data_ptr=(int * *)void_data_ptr;int * data=(*data_ptr);free(data);}
static void main(){char * data;_union_type my_union;char data_buf[100];data=data_buf;my_union.a=data;{char * data=my_union.b;{char dest[50]="";memmove(dest, data, strlen(data)*sizeof(char));printLine(data);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=L"P";{wchar_t * data_copy=data;wchar_t * data=data_copy;if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}}
static void main(){char * data;data=NULL;data=new char;delete data;main_sink(&data);}void main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=RAND32();}{int data=*data_ptr2;{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(char * data){if (strstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data, L'A', 100-1);data[100-1]=L'\0';free(data);_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main_sink(int data){{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}main_sink(data);}
static void main_sink(){int count=_main_data;{size_t i=0;FILE *file=NULL;const char *filename="output_bad.txt";file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}static void main(){int count;count=-1;count=20;_main_data=count;main_sink();}
void b_main_sink(int * data);static void main(){int * data;void (*func_ptr) (int *)=b_main_sink;{int * data_buf=(int *)malloc(100*sizeof(int));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}func_ptr(data);}void b_main_sink(int * data){printIntLine(data[0]);free(data);}
static void main(){char * data;data=NULL;{char mystring[]="mystring";data=strdup(mystring);}main_sink_b(data);}void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){main_sink_d(data);}void main_sink_d(char * data){free(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}{int i, n, v;if (swscanf(data, L"%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
void b_main_sink();static void main(){float data;data=0.0F;data=7.0F;_main_data=data;b_main_sink();}void b_main_sink(){float data=_main_data;printDoubleLine((double)(100.0/data));}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;{char * data_copy=data;char * data=data_copy;if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=10000;}{int data=*data_ptr2;{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than the length of the source string or too large");}}}}
static void main_sink(wchar_t * data){{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");func_ptr(data);}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");func_ptr(data);}void b_main_sink(char * data){{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
static void main(){int data;_struct_type my_struct;data=-1;data=5;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{int result=data * 2;printIntLine(result);}}
static void main_sink(wchar_t * data){fwprintf(stdout, L"%s\n", data);}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}func_ptr(data);}
static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));if(global_returns_t_or_f()){data=data_goodbuf;}else{data=data_goodbuf;}{char src[100];strcpy(data, src);printLine(data);}}
static void main(){unsigned int data;data=0;data=0;b_main_sink(data);}void b_main_sink(unsigned int data){c_main_sink(data);}void c_main_sink(unsigned int data){{unsigned int result=0;if (data > 0){result=data-1;printUnsignedLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static void main(){char data;data=' ';data=5;b_main_sink(&data);}void b_main_sink(char * data_ptr){char data=*data_ptr;{char result=data * 2;printHexCharLine(result);}}
static void main(){twoints * data;twoints * *data_ptr1=&data;twoints * *data_ptr2=&data;data=NULL;{twoints * data=*data_ptr1;data=NULL;data=(twoints *)realloc(data, 100*sizeof(twoints));data[0].a=0;data[0].b=0;printStructLine(&data[0]);}{twoints * data=*data_ptr2;free(data);}}
void b_main_sink(_struct_type my_struct);static void main(){int data;_struct_type my_struct;data=-1;data=100-1;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
static int main_source(int data){data=CHAR_MAX-5;return data;}static void main(){int data;data=-1;data=main_source(data);{char c=(char)data;printHexCharLine(c);}}
void main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];{char * data_buf=new char[100];data=data_buf;}data_array[2]=data;main_sink(data_array);}void main_sink(char * data_array[]){char * data=data_array[2];printLine(data);delete [] data;}
static void main(){twoints * data;twoints * &data_ref=data;data=NULL;data=new twoints;{twoints * data=data_ref;delete data;}}
static wchar_t * main_source(wchar_t * data){data=L"P";return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char dest[50]="";strncpy(dest, data, strlen(data));printLine(data);}}
static void main(){char * data;data=NULL;if(global_returns_t_or_f()){data=NULL;data=(char *)realloc(data, 100*sizeof(char));strcpy(data, "A String");printLine(data);}else{data=NULL;data=(char *)realloc(data, 100*sizeof(char));strcpy(data, "A String");printLine(data);}if(global_returns_t_or_f()){free(data);}else{free(data);}}
static void main_sink(){char * data=main_data;}static void main(){char * data;data=NULL;{char data_goodbuf[100];data=data_goodbuf;strcpy(data, "A String");printLine(data);}main_data=data;main_sink();}
static void main(){int data;int data_array[5];data=-1;data=RAND32();data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{int result=-1;if (data <=(int)sqrt((int)INT_MAX)){result=data * data;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
void b_main_sink(FILE * data);static void main(){FILE * data;void (*func_ptr) (FILE *)=b_main_sink;data=NULL;data=fopen("file.txt", "w+");func_ptr(data);}void b_main_sink(FILE * data){if (data!=NULL){fclose(data);}}
static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}void b_main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;if (wcsstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf(data, args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");{char * data_copy=data;char * data=data_copy;main_vasink(data, data);}}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
void b_main_sink(twoints * data);static void main(){twoints * data;twoints data_badbuf[50];twoints data_goodbuf[100];data=data_goodbuf;b_main_sink(data);}void c_main_sink(twoints * data);void b_main_sink(twoints * data){c_main_sink(data);}void d_main_sink(twoints * data);void c_main_sink(twoints * data){d_main_sink(data);}void e_main_sink(twoints * data);void d_main_sink(twoints * data){e_main_sink(data);}void e_main_sink(twoints * data){{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memcpy(data, src, 100*sizeof(twoints));printStructLine(&data[0]);}}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{size_t i, dest_sz;wchar_t dest[100];wmemset(dest, L'C', 100-1);dest_sz=wcslen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);}}
static void main(){long long * data;data=NULL;data=new long long;main_sink(&data);}void main_sink(long long * * data_ptr){long long * data=*data_ptr;delete data;}
static void main_sink(){int data=_main_data;{char c=(char)data;printHexCharLine(c);}}static void main(){int data;data=-1;data=CHAR_MAX-5;_main_data=data;main_sink();}
static void main(){long long * data;long long * data_array[5];data=NULL;data=new long long[100];delete [] data;data_array[2]=data;main_sink(data_array);}void main_sink(long long * data_array[]){long long * data=data_array[2];}
void b_main_sink(long long * data_array[]);static void main(){long long * data;long long * data_array[5];data=NULL;{long long tmp=5L;data=&tmp;}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(long long * data_array[]){long long * data=data_array[2];printLongLongLine(*data);}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t src[100];wcsncpy(data, src, 100);printWLine(data);free(data);}}}
static void main(){twointsclass * data;data=(twointsclass *)ALLOCA(10*sizeof(twointsclass));for(int i=0;i<(10/2);i++){data[i].a=i;data[i].b=i;}main_sink(&data);}void main_sink(void * void_data_ptr){twointsclass * * data_ptr=(twointsclass * *)void_data_ptr;twointsclass * data=(*data_ptr);for(int i=0;i<10;i++){data[i].a=i;data[i].b=i;}for(int i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}
static void main(){char * data;data=NULL;data=new char[100];memset(data, 'A', 100-1);data[100-1]='\0';delete [] data;main_sink_b(data);}void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){main_sink_d(data);}void main_sink_d(char * data){}
static void main(){long long * data;data=(long long *)malloc(100);{long long * data_copy=data;long long * data=data_copy;if (data!=NULL){data[0]=5L;printLongLongLine(data[0]);free(data);}}}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){int data;if(global_returns_t_or_f()){data=5;}else{data=5;}if(global_returns_t_or_f()){printIntLine(data);}else{printIntLine(data);}}
static void main(){char data;data=' ';data=b_main_source(data);{char result=-1;if (data <=(char)sqrt((char)CHAR_MAX)){result=data * data;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}char b_main_source(char data){data=(char)rand();return data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_t_or_f()){wcscpy(data, GOOD_OS_COMMAND);}else{wcscpy(data, GOOD_OS_COMMAND);}{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}
static void main_sink(char * password){{HANDLE pHandle;char * username="User";char * domain="Domain";if (LogonUserA( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}static void main(){char * password;void (*func_ptr) (char *)=main_sink;char password_buf[100]="";password=password_buf;{size_t password_len=0;fgets(password, 100, stdin);password_len=strlen(password);if (password_len > 0){password[password_len-1]='\0';}}func_ptr(password);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, L"%s", args);va_end(args);printWLine(dest);}}void b_main_sink(wchar_t * data){main_vasink(data, data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");{char * data_copy=data;char * data=data_copy;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");func_ptr(data);}void b_main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
void b_main_sink(short data_array[]);static void main(){short data;short data_array[5];data=0;data=100-1;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(short data_array[]){short data=data_array[2];{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
char * main_source(char * data);static void main(){char * data;data=main_source(data);printLine(data);delete [] data;}char * main_source(char * data){{char * data_buf=new char[100];data=data_buf;}return data;}
static void main(){float data;_union_type my_union;data=0.0F;data=7.0F;my_union.a=data;{float data=my_union.b;printDoubleLine((double)(100.0/data));}}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=NULL;data=NULL;data=(wchar_t *)realloc(data, 100*sizeof(wchar_t));func_ptr(data);}void main_sink(wchar_t * data){free(data);}
static void main(){int data;data=-1;if(global_returns_t_or_f()){data=CHAR_MAX-5;}else{data=CHAR_MAX-5;}{char c=(char)data;printHexCharLine(c);}}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));data=b_main_source(data);{wchar_t dest[50]=L"";size_t i, data_len;data_len=wcslen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printWLine(data);free(data);}}wchar_t * b_main_source(wchar_t * data){return data;}
static void main(){twointsclass * data;data=NULL;{twointsclass data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printIntLine(data[0].a);printIntLine(data[0].b);}main_sink(data);}void main_sink(twointsclass * data){}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");func_ptr(data);}void b_main_sink(wchar_t * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
void main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}data_array[2]=data;main_sink(data_array);}void main_sink(char * data_array[]){char * data=data_array[2];{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]='\0';printLine(data);}}
static void main_sink(unsigned char data){{unsigned char result=-1;if (data <=(unsigned char)sqrt((unsigned char)UCHAR_MAX)){result=data * data;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}static void main(){unsigned char data;data=' ';data=UCHAR_MAX;main_sink(data);}
void b_main_sink();static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{char src[100];memcpy(data, src, 100*sizeof(char));printLine(data);}}
static void main(){if(global_returns_t_or_f()){{std_thread thread_a=NULL;std_thread thread_b=NULL;if (!std_thread_lock_create(&g_good_lock)){return;}if (!std_thread_create(helper_good, NULL, &thread_a)){thread_a=NULL;}if (!std_thread_create(helper_good, NULL, &thread_b)){thread_b=NULL;}if (thread_a && std_thread_join(thread_a)) std_thread_destroy(thread_a);if (thread_b && std_thread_join(thread_b)) std_thread_destroy(thread_b);std_thread_lock_destroy(g_good_lock);printIntLine(g_good);}}else{{std_thread thread_a=NULL;std_thread thread_b=NULL;if (!std_thread_lock_create(&g_good_lock)){return;}if (!std_thread_create(helper_good, NULL, &thread_a)){thread_a=NULL;}if (!std_thread_create(helper_good, NULL, &thread_b)){thread_b=NULL;}if (thread_a && std_thread_join(thread_a)) std_thread_destroy(thread_a);if (thread_b && std_thread_join(thread_b)) std_thread_destroy(thread_b);std_thread_lock_destroy(g_good_lock);printIntLine(g_good);}}}
static void main(){{try{string a="hello";string b=a.substr(rand(), rand());printLine(b.c_str());}catch (out_of_range &){printLine("Range specified was invalid");}}}
static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));{char * data_copy=data;char * data=data_copy;{char src[100];_snprintf(data, 100, "%s", src);printLine(data);free(data);}}}
static void main(){char * data;data=NULL;if(global_returns_t_or_f()){data=(char *)calloc(100, sizeof(char));}else{data=(char *)calloc(100, sizeof(char));}if(global_returns_t_or_f()){free(data);}else{free(data);}}
static void main(){twoints * data;data=NULL;if(global_returns_t_or_f()){data=new twoints;data->a=1;data->b=2;}else{data=new twoints;data->a=1;data->b=2;}if(global_returns_t_or_f()){printStructLine(data);}else{printStructLine(data);}}
void main_sink(struct_type my_struct);static void main(){int * data;struct_type my_struct;data=NULL;data=new int[100];my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){int * data=my_struct.a;{memmove(data, src, 100*sizeof(int));printIntLine(data[0]);delete [] data;}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(&data);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(L"%s", args);va_end(args);}}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);main_vasink(data, data);}
static void main(){wchar_t * password;password=L"";password=(wchar_t *)malloc(100*sizeof(wchar_t));if(!VirtualLock(password, 100*sizeof(wchar_t))){printLine("Memory could not be locked");exit(1);}wcscpy(password, L"Password1234!");{HANDLE pHandle;wchar_t * username=L"User";wchar_t * domain=L"Domain";if (LogonUserW( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}
static void main_source(char * &data){data=new char[100];}static void main(){char * data;data=NULL;main_source(data);{char src[100];strncpy(data, src, 100);printLine(data);delete [] data;}}
void b_main_sink(twoints * data);static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));b_main_sink(data);}void c_main_sink(twoints * data);void b_main_sink(twoints * data){c_main_sink(data);}void d_main_sink(twoints * data);void c_main_sink(twoints * data){d_main_sink(data);}void e_main_sink(twoints * data);void d_main_sink(twoints * data){e_main_sink(data);}void e_main_sink(twoints * data){{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printStructLine(&data[0]);free(data);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}{int i, n, v;if (swscanf(data, L"%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){int data;data=-1;if(global_returns_t_or_f()){data=5;}else{data=5;}if(global_returns_t_or_f()){{int result=data-1;printIntLine(result);}}else{{int result=data-1;printIntLine(result);}}}
static void main(){wchar_t * data;union_type my_union;data=NULL;data=new wchar_t[100];delete [] data;my_union.a=data;{wchar_t * data=my_union.b;}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "15");_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{int i, n, v;if (sscanf(data, "%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main(){twoints * data;twoints * &data_ref=data;data=NULL;data=new twoints[100];{twoints * data=data_ref;delete [] data;}}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *, ...)=b_main_vasink;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}func_ptr(data);}void b_main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, L"%s", args);va_end(args);printWLine(dest);}}
void b_main_sink();static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));printWLine(data);}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];main_sink(&data);}void main_sink(twointsclass * * data_ptr){twointsclass * data=*data_ptr;delete [] data;}
static void main(){int data;int data_array[5];data=-1;data=20;data_array[2]=data;main_sink(data_array);}void main_sink(int data_array[]){int data=data_array[2];{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}
void b_main_sink();static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{wchar_t src[100];wcsncpy(data, src, 100);printWLine(data);free(data);}}
static void main_sink(unsigned char data){{unsigned char result=-1;if (data <=(UCHAR_MAX/2)){result=data * 2;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}static void main(){unsigned char data;void (*func_ptr) (unsigned char)=main_sink;data=' ';fscanf (stdin, "%hc", &data);func_ptr(data);}
static void main_sink(wchar_t * data){{wchar_t dest[50]=L"";_snwprintf(dest, wcslen(data), L"%s", data);printWLine(data);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100];data=data_buf;func_ptr(data);}
short b_main_source(short data);static void main(){short data;data=0;data=b_main_source(data);{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}short b_main_source(short data){data=100-1;return data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}char * b_main_source(char * data){{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}return data;}
static void main(){char data;_union_type my_union;data=' ';data=5;my_union.a=data;{char data=my_union.b;{char result=data * data;printHexCharLine(result);}}}
static void main(){if(global_returns_t_or_f()){{char * data=NULL;data=(char *)realloc(data, 100);if (data==NULL){printLine("realloc() failed");exit(1);}strcpy(data, "BadSinkBody");printLine(data);if (data!=NULL){free(data);}}}else{{char * data=NULL;data=(char *)realloc(data, 100);if (data==NULL){printLine("realloc() failed");exit(1);}strcpy(data, "BadSinkBody");printLine(data);if (data!=NULL){free(data);}}}}
static void main_sink(char * data){fprintf(stdout, data);}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");func_ptr(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}_main_data=data;b_main_sink();}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, L"%s", args);va_end(args);printWLine(dest);}}void b_main_sink(){wchar_t * data=_main_data;main_vasink(data, data);}
void _main_sink(char * data){{char src[100];_snprintf(data, 100, "%s", src);printLine(data);}}static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;_main_sink(data);}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
static void main_sink(wchar_t * password){{HANDLE pHandle;wchar_t * username=L"User";wchar_t * domain=L"Domain";if (LogonUserW( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}static void main(){wchar_t * password;void (*func_ptr) (wchar_t *)=main_sink;wchar_t password_buf[100]=L"";password=password_buf;wcscpy(password, L"Password1234!");func_ptr(password);}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t dest[100];memmove(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){{char dst[DST_SZ];int x=5;sprintf(dst, "%d", x);printLine(dst);}}
void _main_sink(wchar_t * data){{wchar_t dest[50]=L"";memcpy(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);}}static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;_main_sink(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){printf(data);}
static void main(){int * data;struct_type my_struct;data=NULL;data=new int;delete data;my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){int * data=my_struct.a;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, L"%s", data);printWLine(dest);}}
static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}data_array[2]=data;b_main_sink(data_array);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, L"%s", args);va_end(args);}}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];main_vasink(data, data);}
static void main(){struct _twoints * data;struct _twoints * data_array[5];data=NULL;struct _twoints data_good;data=&data_good;data->a=0;data->b=0;printStructLine((twoints *)data);data_array[2]=data;main_sink(data_array);}void main_sink(struct _twoints * data_array[]){struct _twoints * data=data_array[2];}
static void main(){long long * data;data=NULL;data=(long long *)malloc(sizeof(*data));{long long * data_copy=data;long long * data=data_copy;printLongLongLine(*data);free(data);}}
static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]=FULL_COMMAND;data=data_buf;{char * data=*data_ptr1;strcat(data, "*.*");}{char * data=*data_ptr2;{FILE *pipe;pipe=POPEN(data, "wb");if (pipe!=NULL) PCLOSE(pipe);}}}
void _main_sink(char * password){{HANDLE pHandle;char * username="User";char * domain="Domain";if (LogonUserA( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}static void main(){char * password;char password_buf[100]="";password=password_buf;strcpy(password, "Password1234!");_main_sink(password);}
static void main(){int * data;data=NULL;data=new int;printIntLine(*data);main_sink(&data);}void main_sink(void * void_data_ptr){int * * data_ptr=(int * *)void_data_ptr;int * data=(*data_ptr);delete data;}
static void main_sink(){long long * data=_main_data;}static void main(){long long * data;data=NULL;{long long data_goodbuf[100];data=data_goodbuf;data[0]=5L;printLongLongLine(data[0]);}_main_data=data;main_sink();}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]="";data=data_buf;{char * data=*data_ptr1;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}}{char * data=*data_ptr2;fprintf(stdout, "%s\n", data);}}
void main_sink(twointsclass * data);static void main(){twointsclass * data;void (*func_ptr) (twointsclass *)=main_sink;data=NULL;{twointsclass * tmp=new twointsclass;tmp->a=0;tmp->b=0;data=tmp;}func_ptr(data);}void main_sink(twointsclass * data){printIntLine(data[0].a);}
static void main(){unsigned int data;data=0;fscanf (stdin, "%u", &data);b_main_sink(&data);}void b_main_sink(unsigned int * data_ptr){unsigned int data=*data_ptr;{unsigned int result=-1;if (data < UINT_MAX){result=data+1;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){{if (RpcImpersonateClient(0)!=RPC_S_OK){exit(1);}}}
static void main(){{char src[]=SRC_STR;char dst[DST_SZ];memcpy(dst, src, sizeof(src));printLine(dst);}}
static void main_sink(wchar_t * data){{size_t i;for (i=0;i < wcslen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));data[0]=L'\0';{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}main_sink(data);}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void b_main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnvp(_P_WAIT, COMMAND_INT, args);}}
static void main(){char * data;_union_type my_union;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");my_union.a=data;{char * data=my_union.b;{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}}
static void main_sink(char * data){{HMODULE hModule;hModule=LoadLibraryA(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;strcpy(data, "C:\\Windows\\System32\\winsrv.dll");func_ptr(data);}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;data=(char *)malloc(100*sizeof(char));func_ptr(data);}void b_main_sink(char * data){{char dest[50]="";size_t i, data_len;data_len=strlen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printLine(data);free(data);}}
static void main(){twoints * data;data=NULL;data=NULL;data=(twoints *)realloc(data, 100*sizeof(twoints));main_sink(&data);}void main_sink(twoints * * data_ptr){twoints * data=*data_ptr;free(data);}
static void main(){int data;_union_type my_union;data=-1;data=100-1;my_union.a=data;{int data=my_union.b;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}}
static wchar_t * main_source(wchar_t * data){wcscat(data, L"file.txt");return data;}static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;data=main_source(data);{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[250]=L"PATH=";data=data_buf;wcscat(data, NEW_PATH);func_ptr(data);}void b_main_sink(wchar_t * data){PUTENV(data);}
static void main(){FILE * data;data=NULL;data=freopen("BadSource_freopen.txt","w+",stdin);if (data!=NULL){fclose(data);}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));{wchar_t * data=*data_ptr1;data=data_goodbuf;}{wchar_t * data=*data_ptr2;{wchar_t src[100];wcscpy(data, src);printWLine(data);}}}
static void main(){long long * data;_union_type my_union;{long long * data_buf=(long long *)malloc(100*sizeof(long long));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5L;}}data=data_buf;}my_union.a=data;{long long * data=my_union.b;printLongLongLine(data[0]);free(data);}}
static void main(){char data;data=' ';fscanf (stdin, "%c", &data);b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * data_ptr=(char *)void_data_ptr;char data=(*data_ptr);{char result=-1;if (data < CHAR_MAX){result=data+1;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t;main_sink_b(data);}void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_d(wchar_t * data){delete data;}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;func_ptr(data);}void b_main_sink(wchar_t * data){if (wcsncmp(PASSWORD, data, wcslen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){twointsclass * data;twointsclass * &data_ref=data;{twointsclass * data_buf=new twointsclass[100];{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}{twointsclass * data=data_ref;printIntLine(data[0].a);delete [] data;}}
static void main(){char * data;data=(char *)malloc(100*sizeof(char));data[0]='\0';strcpy(data, BAD_SRC_FIXED);{char * data_copy=data;char * data=data_copy;{size_t i;for (i=0;i < strlen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}{wchar_t * data_copy=data;wchar_t * data=data_copy;if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}}
static void main(){double * data;data=(double *)ALLOCA(10*sizeof(double));{int i;for(i=0;i<(10/2);i++){data[i]=(double)i;}}{int i;for(i=0;i<10;i++){data[i]=(double)i;}}{int i;for(i=0;i<10;i++){printDoubleLine(data[i]);}}}
static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];if(global_returns_t_or_f()){data=data_goodbuf;}else{data=data_goodbuf;}{wchar_t src[100];_snwprintf(data, 100, L"%s", src);printWLine(data);}}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");my_union.a=data;{wchar_t * data=my_union.b;{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, data);printWLine(dest);}}}
static void main_sink(char * data){{char src[100];strncat(data, src, 100);printLine(data);delete [] data;}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;data=new char[100];func_ptr(data);}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;if(global_returns_t_or_f()){wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");}else{wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");}{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
static void main(){int count;count=-1;count=20;{size_t i=0;for (i=0;i < (size_t)count;i++){printLine("Hello");}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);{int i, n, v;if (swscanf(data, L"%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}wchar_t * b_main_source(wchar_t * data){{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}return data;}
static int main_source(int count){count=20;return count;}static void main(){int count;count=-1;count=main_source(count);{size_t i=0;for (i=0;i < (size_t)count;i++){printLine("Hello");}}}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[250]=L"PATH=";data=data_buf;wcscat(data, NEW_PATH);_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;PUTENV(data);}
static void main(){short data;data=0;if(global_returns_t_or_f()){data=100-1;}else{data=100-1;}{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{wchar_t src[100];wcscat(data, src);printWLine(data);}}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char src[100];memmove(data, src, 100*sizeof(char));printLine(data);}}
static void main(){char * data;_union_type my_union;{char * data_buf=(char *)malloc(100*sizeof(char));data=data_buf;}my_union.a=data;{char * data=my_union.b;printLine(data);free(data);}}
static void main_vasinkg(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, "%s", args);va_end(args);}}static void main_vasinkb(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");main_vasinkb(data, data);}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];data=(char *)malloc(100*sizeof(char));data[0]='\0';{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{size_t i;for (i=0;i < strlen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}
void b_main_sink();static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{char src[100];strcpy(data, src);printLine(data);}}
static void main(){int data;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");my_union.a=data;{wchar_t * data=my_union.b;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}}
static void main_sink(wchar_t * data){{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");func_ptr(data);}
static void main_sink(wchar_t * data){}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=NULL;{wchar_t data_goodbuf[100];data=data_goodbuf;wcscpy(data, L"A String");printWLine(data);}func_ptr(data);}
static void main_sink(char data){{char result=-1;if (data < CHAR_MAX){result=data+1;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}static void main(){char data;data=' ';fscanf (stdin, "%c", &data);main_sink(data);}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char data_buf[100]="";data=data_buf;strcat(data, "*.*");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;data=new char;func_ptr(data);}void main_sink(char * data){delete data;}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
static void main(){unsigned int data;data=0;data=5;b_main_sink(data);}void b_main_sink(unsigned int data){c_main_sink(data);}void c_main_sink(unsigned int data){d_main_sink(data);}void d_main_sink(unsigned int data){e_main_sink(data);}void e_main_sink(unsigned int data){{unsigned int result=data+1;printUnsignedLine(result);}}
static int main_source(int data){data=5;return data;}static void main(){int data;data=-1;data=main_source(data);{int result=data * data;printIntLine(result);}}
static void main(){short data;short *data_ptr1=&data;short *data_ptr2=&data;data=-1;{short data=*data_ptr1;data=CHAR_MAX-5;}{short data=*data_ptr2;{char c=(char)data;printHexCharLine(c);}}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;data->a=1;data->b=2;delete data;main_sink_b(data);}void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_c(twointsclass * data){main_sink_d(data);}void main_sink_d(twointsclass * data){}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");func_ptr(data);}void b_main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
static void main_sink(twoints * data){delete data;}static void main(){twoints * data;void (*func_ptr) (twoints *)=main_sink;data=NULL;data=new twoints;func_ptr(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{int i, n, v;if (swscanf(data, L"%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static char * main_source(char * data){strcpy(data, "fixedstringtest");return data;}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);main_vasink(data, data);}
static void main(){unsigned char data;_union_type my_union;data=' ';fscanf (stdin, "%hc", &data);my_union.a=data;{unsigned char data=my_union.b;{unsigned char result=-1;if (data <=(unsigned char)sqrt((unsigned char)UCHAR_MAX)){result=data * data;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
static void main(){int data;data=-1;data=20;main_sink(&data);}void main_sink(int * data_ptr){int data=*data_ptr;{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}
void b_main_sink();static void main(){float data;data=0.0F;data=7.0F;_main_data=data;b_main_sink();}void b_main_sink(){float data=_main_data;printDoubleLine((double)(100.0/data));}
static void main(){int data;data=-1;data=5;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){{int result=data * data;printIntLine(result);}}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));data=data_buf;}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;printWLine(data);free(data);}
static void main(){char * data;struct_type my_struct;data=NULL;data=(char *)calloc(100, sizeof(char));my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){char * data=my_struct.a;free(data);}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=NULL;{char * data=*data_ptr1;data=new char[100];}{char * data=*data_ptr2;{char src[100];memmove(data, src, 100*sizeof(char));printLine(data);delete [] data;}}}
static void main(){int data;data=-1;data=10000;{int data_copy=data;int data=data_copy;{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t src[100];wcscpy(data, src);printWLine(data);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, GOOD_OS_COMMAND);b_main_sink(data);}void b_main_sink(wchar_t * data){{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}
static void main(){int data;data=-1;if(global_returns_t_or_f()){data=ASSERT_VALUE+1;}else{data=ASSERT_VALUE+1;}assert(data > ASSERT_VALUE);}
void b_main_sink();static void main(){FILE * data;data=NULL;data=fopen("BadSource_fopen.txt", "w+");_bad_data_for_good_sink=data;b_main_sink();}void b_main_sink(){FILE * data=_bad_data_for_good_sink;if (data!=NULL){fclose(data);}}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, "%s", args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);main_vasink(data, data);}char * b_main_source(char * data){{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}return data;}
static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;strcat(data, "*.*");my_union.a=data;{char * data=my_union.b;_spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}}
static void main(){short data;short *data_ptr1=&data;short *data_ptr2=&data;data=0;{short data=*data_ptr1;data=100-1;}{short data=*data_ptr2;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}}
void b_main_sink(_struct_type my_struct);static void main(){short data;_struct_type my_struct;data=0;data=100-1;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){short data=my_struct.a;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
void _main_sink(wchar_t * data){{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}static void main(){wchar_t * data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;_main_sink(data);}
static void main(){twoints * data;data=NULL;data=new twoints[100];{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}{twoints * data_copy=data;twoints * data=data_copy;printStructLine(&data[0]);}}
void main_sink();static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}_main_data=data;main_sink();}void main_sink(){wchar_t * data=_main_data;{wchar_t dest[100];memmove(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main_sink(){twointsclass * data=main_data;free(data);}static void main(){twointsclass * data;data=NULL;data=(twointsclass *)malloc(100*sizeof(twointsclass));main_data=data;main_sink();}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t src[100];_snwprintf(data, 100, L"%s", src);printWLine(data);}}
static void main_sink(wchar_t * data){printWLine(data);}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=NULL;data=new wchar_t[100];wmemset(data, L'A', 100-1);data[100-1]=L'\0';func_ptr(data);}
static void main_vasinkg(char * data, ...){{va_list args;va_start(args, data);vprintf("%s", args);va_end(args);}}static void main_vasinkb(char * data, ...){{va_list args;va_start(args, data);vprintf(data, args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");main_vasinkb(data, data);}
static wchar_t * main_source(wchar_t * data){{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, L"%s", data);printWLine(dest);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}{int i, n, v;if (sscanf(data, "%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static void main(){wchar_t * data;_union_type my_union;data=NULL;{wchar_t data_goodbuf[100];data=data_goodbuf;wcscpy(data, L"A String");printWLine(data);}my_union.a=data;{wchar_t * data=my_union.b;}}
static void main(){int data;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0 && data < 10){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnvp(_P_WAIT, COMMAND_INT, args);}}
static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){{wchar_t data_buf[100]=L"";wchar_t * data=data_buf;if (swscanf(SRC, L"%99s\0", data)==EOF){printLine("swscanf failed!");exit(1);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnvp(_P_WAIT, COMMAND_INT, args);}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];delete [] data;}
static void main(){int data;data=-1;data=20;main_sink(data);}void main_sink(int data){{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "C:\\Windows\\System32\\winsrv.dll");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{HMODULE hModule;hModule=LoadLibraryA(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
static void main(){int * data;data=(int *)malloc(10*sizeof(int));if(global_returns_t_or_f()){{int i;for(i=0;i<10;i++){data[i]=i;}}}else{{int i;for(i=0;i<10;i++){data[i]=i;}}}if(global_returns_t_or_f()){{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}}else{{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}}}
static void main(){wchar_t * data;data=NULL;main_source(data);delete [] data;}void main_source(wchar_t * &data){data=new wchar_t[100];}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t dest[50]=L"";wcscat(dest, data);printWLine(data);}}
static void main(){int * data;int * data_array[5];data=NULL;data=(int *)malloc(100*sizeof(int));{size_t i;for(i=0;i < 100;i++){data[i]=5;}}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int * data_array[]){int * data=data_array[2];printIntLine(data[0]);}
static void main_sink(int data){{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=RAND32();func_ptr(data);}
static void main(){int count;count=-1;count=b_main_source(count);{size_t i=0;FILE *file=NULL;const char *filename="output_bad.txt";file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}int b_main_source(int count){count=20;return count;}
static void main(){int data;data=-1;data=20;{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}
static void main_source(int * &data){{int i;for(i=0;i<(10/2);i++){data[i]=i;}}}static void main(){int * data;data=new int[10];main_source(data);{int i;for(i=0;i<10;i++){data[i]=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}delete [] data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}fwprintf(stdout, L"%s\n", data);}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnv(_P_WAIT, COMMAND_INT_PATH, args);}}wchar_t * b_main_source(wchar_t * data){wcscat(data, L"*.*");return data;}
static void main(){int data;data=-1;data=20;main_sink_b(data);}void main_sink_b(int data){main_sink_c(data);}void main_sink_c(int data){main_sink_d(data);}void main_sink_d(int data){main_sink_e(data);}void main_sink_e(int data){{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}
static void * main_source(void * data){data=CHAR_STRING;return data;}static void main(){void * data;data=NULL;data=main_source(data);{size_t data_len=strlen((char *)data);void * data_dest=(void *)calloc(data_len+1, 1);memcpy(data_dest, data, (data_len+1));printLine((char *)data_dest);free(data_dest);}}
static void main_sink(int * data){{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printIntLine(data[0]);}}}static void main(){int * data;void (*func_ptr) (int *)=main_sink;int data_badbuf[50];int data_goodbuf[100];data=data_goodbuf;func_ptr(data);}
static void main(){int * data;data=NULL;data=new int;printIntLine(*data);main_sink(data);}void main_sink(int * data){delete data;}
static void main(){long long * data;long long * &data_ref=data;data=NULL;data=new long long[100];{size_t i;for(i=0;i < 100;i++){data[i]=5L;}}delete [] data;{long long * data=data_ref;}}
static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t dest[50]=L"";memmove(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);free(data);}}}
static void main(){int * data;int * &data_ref=data;data=NULL;data=new int[100];{size_t i;for(i=0;i < 100;i++){data[i]=5;}}delete [] data;{int * data=data_ref;}}
void b_main_sink(short data);static void main(){short data;data=0;data=100-1;b_main_sink(data);}void c_main_sink(short data);void b_main_sink(short data){c_main_sink(data);}void d_main_sink(short data);void c_main_sink(short data){d_main_sink(data);}void e_main_sink(short data);void d_main_sink(short data){e_main_sink(data);}void e_main_sink(short data){{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
static void main(){struct _twoints * data;data=NULL;data=(struct _twoints *)calloc(100, sizeof(struct _twoints));data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);b_main_sink(data);}void b_main_sink(struct _twoints * data){c_main_sink(data);}void c_main_sink(struct _twoints * data){free(data);}
static wchar_t * main_source(wchar_t * data){return data;}static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));data=main_source(data);{wchar_t dest[50]=L"";size_t i, data_len;data_len=wcslen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printWLine(data);free(data);}}
static void main_sink(wchar_t * data){wprintf(L"%s\n", data);}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}func_ptr(data);}
static void main_sink(){int * data=_main_data;{memmove(data, src, 100*sizeof(int));printIntLine(data[0]);free(data);}}static void main(){int * data;data=NULL;data=(int *)malloc(100*sizeof(int));_main_data=data;main_sink();}
void b_main_sink(_struct_type my_struct);static void main(){int * data;_struct_type my_struct;data=(int *)calloc(100, sizeof(int));my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int * data=my_struct.a;if (data!=NULL){data[0]=5;printIntLine(data[0]);free(data);}}
void b_main_sink(void * void_data_ptr);static void main(){short data;data=0;data=100-1;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){short * data_ptr=(short *)void_data_ptr;short data=(*data_ptr);{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
static void main(){twoints * data;data=NULL;main_source(data);printStructLine(&data[0]);}void main_source(twoints * &data){data=new twoints[100];{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}}
static void main(){char * data;char * &data_ref=data;data=NULL;data=(char *)malloc(100*sizeof(char));{char * data=data_ref;free(data);}}
static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t dest[100];wmemset(dest, L'C', 100-1);memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}}
static void main(){char * data;data=NULL;data=new char;delete data;}
static void main_sink(){char * data=_main_data;{int i, n, v;if (sscanf(data, "%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}_main_data=data;main_sink();}
static void main(){char * data;char * data_array[5];char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{char dest[100]="";SNPRINTF(dest, 100-1, "%s", data);printLine(dest);}}
void main_source(char * &data);static void main(){char * data;data=NULL;main_source(data);{char dest[100];memmove(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}void main_source(char * &data){{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=CHAR_MAX-5;}{int data=*data_ptr2;{char c=(char)data;printHexCharLine(c);}}}
static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");func_ptr(data);}void b_main_sink(char * data){fprintf(stdout, data);}
void main_sink(int * data);static void main(){int data;data=-1;data=20;main_sink(&data);}void main_sink(int * data_ptr){int data=*data_ptr;{size_t a,i;int *b;b=(int*)new char[a];for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);delete [] b;}}
static void main_sink(twoints * data){delete data;}static void main(){twoints * data;void (*func_ptr) (twoints *)=main_sink;data=NULL;data=new twoints;func_ptr(data);}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{size_t i;char dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}fprintf(stdout, "%s\n", data);}
static void main(){long long * data;long long * *data_ptr1=&data;long long * *data_ptr2=&data;data=NULL;{long long * data=*data_ptr1;data=new long long[100];}{long long * data=*data_ptr2;{memmove(data, src, 100*sizeof(long long));printLongLongLine(data[0]);delete [] data;}}}
static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=-1;data=5;func_ptr(data);}void b_main_sink(int data){{int result=data+1;printIntLine(result);}}
void main_sink(char * data);static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}main_sink(data);}void main_sink(char * data){{char dest[100];strncpy(dest, data, strlen(dest));dest[100-1]='\0';printLine(dest);}}
void b_main_sink(_struct_type my_struct);static void main(){int data;_struct_type my_struct;data=-1;data=7;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;printIntLine(100 % data);}
static void main(){int data;_struct_type my_struct;data=-1;data=RAND32();my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{int result=-1;if (data <=(int)sqrt((int)INT_MAX)){result=data * data;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main_source(long long * &data){data=new long long[100];}static void main(){long long * data;data=NULL;main_source(data);{memcpy(data, src, 100*sizeof(long long));printLongLongLine(data[0]);delete [] data;}}
static void main(){twoints * data;data=NULL;data=new twoints[100];delete [] data;}
static void main(){char data;data=' ';data=b_main_source(data);{char result=0;if (data > CHAR_MIN){result=data-1;printHexCharLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}char b_main_source(char data){fscanf (stdin, "%c", &data);return data;}
static void main_sink(){short data=_main_data;{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}static void main(){short data;data=0;data=100-1;_main_data=data;main_sink();}
static void main(){int data;data=-1;data=100-1;{int data_copy=data;int data=data_copy;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}}
static void main_sink(char * data){printf("%s\n", data);}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{wchar_t src[100];wcscpy(data, src);printWLine(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;{wchar_t dest[100];wcsncpy(dest, data, wcslen(dest));dest[100-1]=L'\0';printWLine(dest);}}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
static void main(){wchar_t * data;data=NULL;if(global_returns_t_or_f()){data=new wchar_t;printHexCharLine((char)*data);}else{data=new wchar_t;printHexCharLine((char)*data);}if(global_returns_t_or_f()){delete data;}else{delete data;}}
static void main_sink(){char * data=_main_data;{FILE *pipe;pipe=POPEN(data, "wb");if (pipe!=NULL) PCLOSE(pipe);}}static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");_main_data=data;main_sink();}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t src[100];wcsncpy(data, src, 100);data[100-1]=L'\0';printWLine(data);}}
static void main_sink(){int data=_main_data;}static void main(){int data;data=OPEN("BadSource_open.txt", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);CLOSE(data);_main_data=data;main_sink();}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;_wsystem(data);}
void main_sink(char * data){{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}printLine(data);delete [] data;}}static void main(){char * data;data=NULL;data=new char[100];main_sink(data);}
static void main(){twoints * data;data=NULL;data=new twoints;data->a=1;data->b=2;printStructLine(data);}
void b_main_sink(int data);static void main(){int data;data=-1;data=CHAR_MAX-5;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void d_main_sink(int data);void c_main_sink(int data){d_main_sink(data);}void e_main_sink(int data);void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{short s=(short)data;printf("%hd\n", s);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnvp(_P_WAIT, COMMAND_INT, args);}}
void b_main_sink();static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{wchar_t src[100];_snwprintf(data, 100, L"%s", src);printWLine(data);free(data);}}
static void main(){wchar_t * data;_union_type my_union;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}my_union.a=data;{wchar_t * data=my_union.b;{wchar_t src[100];wcsncpy(data, src, 100);data[100-1]=L'\0';printWLine(data);}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");b_main_sink(data);}void b_main_sink(char * data){{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){twoints * data;data=NULL;{twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine(&data[0]);}}
static void main(){char data;char data_array[5];data=' ';data=CHAR_MAX;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char data_array[]){char data=data_array[2];{char result=-1;if (data <=(char)sqrt((char)CHAR_MAX)){result=data * data;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static wchar_t * main_source(wchar_t * data){{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);{int i, n, v;if (swscanf(data, L"%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static void main_source(wchar_t * &data){data=new wchar_t[100];}static void main(){wchar_t * data;data=NULL;main_source(data);{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}printWLine(data);delete [] data;}}
static void main_source(twoints * &data){data=new twoints[100];}static void main(){twoints * data;data=NULL;main_source(data);delete [] data;}
static void main(){twoints * data;struct_type my_struct;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){twoints * data=my_struct.a;free(data);}
static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{int i, n, v;if (sscanf(data, "%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static void main(){HANDLE data;HANDLE data_array[5];data=CreateFile("GoodSource_w32CreateFile.txt", (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);data_array[2]=data;b_main_sink(data_array);}void b_main_sink(HANDLE data_array[]){HANDLE data=data_array[2];CloseHandle(data);}
static void main_source(wchar_t * &data){{wchar_t * data_buf=new wchar_t[100];data=data_buf;}}static void main(){wchar_t * data;main_source(data);printWLine(data);delete [] data;}
static void main(){int count;count=-1;count=20;{size_t i=0;for (i=0;i < (size_t)count;i++){printLine("Hello");}}}
void b_main_sink(long long * data);static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));b_main_sink(data);}void b_main_sink(long long * data){{memcpy(data, src, 100*sizeof(long long));printLongLongLine(data[0]);free(data);}}
void main_sink_b(twointsclass * data);static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];main_sink_b(data);}void main_sink_c(twointsclass * data);void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_c(twointsclass * data){{twointsclass src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memcpy(data, src, 100*sizeof(twointsclass));printIntLine(data[0].a);delete [] data;}}
static void main(){char * data;char * data_array[5];data=NULL;data=new char[100];data_array[2]=data;main_sink(data_array);}void main_sink(char * data_array[]){char * data=data_array[2];delete [] data;}
static void main(){int data;_union_type my_union;data=7;my_union.a=data;{int data=my_union.b;{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}}
static void main(){int data;_union_type my_union;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}my_union.a=data;{int data=my_union.b;{int result=-1;if (data <=(INT_MAX/2)){result=data * 2;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
static void main(){wchar_t * data;wchar_t data_buf[250]=L"PATH=";data=data_buf;wcscat(data, NEW_PATH);PUTENV(data);}
static void main(){double * data;data=new double[10];main_sink(&data);}void main_sink(void * void_data_ptr){double * * data_ptr=(double * *)void_data_ptr;double * data=(*data_ptr);{int i;for(i=0;i<10;i++){data[i]=(double)i;}}{int i;for(i=0;i<10;i++){printDoubleLine(data[i]);}}delete [] data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnvp(_P_WAIT, COMMAND_INT, args);}}
void main_sink();static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}_main_data=data;main_sink();}void main_sink(){char * data=_main_data;{size_t i;char dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);}}
static void main(){char * data;data=NULL;data=new char[100];{char dest[100];memset(dest, 'C', 100-1);memcpy(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);delete [] data;}}
static void main(){char * data;data=NULL;if(global_returns_t_or_f()){data=new char[100];}else{data=new char[100];}{char src[100];_snprintf(data, 100, "%s", src);printLine(data);delete [] data;}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;data=(wchar_t *)malloc(100*sizeof(wchar_t));{wchar_t * data=*data_ptr1;}{wchar_t * data=*data_ptr2;{wchar_t dest[50]=L"";size_t i, data_len;data_len=wcslen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printWLine(data);free(data);}}}
static void main(){int data;if(global_returns_t_or_f()){data=10;}else{data=10;}if(global_returns_t_or_f()){{char data_buf[10]="AAAAAAAAA";{printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}else{{char data_buf[10]="AAAAAAAAA";{printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");{char * data_copy=data;char * data=data_copy;{char dest[100]="";SNPRINTF(dest, 100-1, data);printLine(dest);}}}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, GOOD_OS_COMMAND);data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];_wsystem(data);}
static void main_sink(){twointsclass * data=main_data;printIntLine(data[0].a);delete [] data;}static void main(){twointsclass * data;{twointsclass * data_buf=new twointsclass[100];{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}main_data=data;main_sink();}
static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;if(global_returns_t_or_f()){strcat(data, "*.*");}else{strcat(data, "*.*");}{FILE *pipe;pipe=POPEN(data, "wb");if (pipe!=NULL) PCLOSE(pipe);}}
void b_main_sink(_struct_type my_struct);static void main(){FILE * data;_struct_type my_struct;data=NULL;data=fopen("BadSource_fopen.txt", "w+");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){FILE * data=my_struct.a;if (data!=NULL){fclose(data);}}
void b_main_sink(char * data);static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{char src[100];memmove(data, src, 100*sizeof(char));printLine(data);}}
static void main(){int * data;struct_type my_struct;data=NULL;data=new int[100];data[0]=5;printIntLine(data[0]);my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){int * data=my_struct.a;delete[] data;}
static void main(){wchar_t * data;data=NULL;data=new wchar_t;printHexCharLine((char)*data);main_sink_b(data);}void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_d(wchar_t * data){main_sink_e(data);}void main_sink_e(wchar_t * data){delete data;}
static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));printWLine(data);}}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{char src[100];strcpy(data, src);printLine(data);}}
static void main(){short data;data=-1;data=CHAR_MAX-5;{char c=(char)data;printHexCharLine(c);}}
static void main_sink(int data){{int result=data * 2;printIntLine(result);}}static void main(){int data;data=-1;data=5;main_sink(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(data);}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf(data, args);va_end(args);}}void b_main_sink(char * data){main_vasink(data, data);}
void b_main_sink(_struct_type my_struct);static void main(){int * data;_struct_type my_struct;data=NULL;data=(int *)malloc(100*sizeof(int));my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int * data=my_struct.a;{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printIntLine(data[0]);free(data);}}}
static void main_sink(twoints * data){free(data);}static void main(){twoints * data;void (*func_ptr) (twoints *)=main_sink;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));func_ptr(data);}
static void main(){char * data;data=NULL;char data_good;data=&data_good;printHexCharLine(*data);main_sink(&data);}void main_sink(char * * data_ptr){char * data=*data_ptr;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;wprintf(data);}
void b_main_sink(char * data);static void main(){char * data;data=(char *)malloc(100*sizeof(char));data[0]='\0';strcpy(data, BAD_SRC_FIXED);b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{size_t i;for (i=0;i < strlen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}
static void main_sink(){wchar_t * data=main_data;free(data);}static void main(){wchar_t * data;data=NULL;{wchar_t mystring[]=L"mystring";data=wcsdup(mystring);}main_data=data;main_sink();}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);{char dest[100]="";SNPRINTF(dest, 100-1, "%s", data);printLine(dest);}}char * b_main_source(char * data){{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}return data;}
static void main(){char * data;data=(char *)malloc(100*sizeof(char));data[0]='\0';strcpy(data, BAD_SRC_FIXED);{size_t i;for (i=0;i < strlen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}
static void main(){twoints * data;void (*func_ptr) (twoints *)=main_sink;data=NULL;data=new twoints[100];delete [] data;func_ptr(data);}void main_sink(twoints * data){}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));main_data=data;main_sink();}void main_sink(){twoints * data=main_data;free(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){twoints * data;data=NULL;data=main_source(data);free(data);}twoints * main_source(twoints * data){data=NULL;data=(twoints *)realloc(data, 100*sizeof(twoints));return data;}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(L"%s", args);va_end(args);}}static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}my_union.a=data;{wchar_t * data=my_union.b;main_vasink(data, data);}}
static void main(){wchar_t * data;data=NULL;data=NULL;data=(wchar_t *)realloc(data, 100*sizeof(wchar_t));main_sink(&data);}void main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;free(data);}
static void main(){HANDLE data;HANDLE *data_ptr1=&data;HANDLE *data_ptr2=&data;{HANDLE data=*data_ptr1;data=CreateFile("GoodSource_w32CreateFile.txt", (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);}{HANDLE data=*data_ptr2;CloseHandle(data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;fprintf(stdout, data);}
static unsigned int main_source(unsigned int data){data=5;return data;}static void main(){unsigned int data;data=0;data=main_source(data);{unsigned int result=data-1;printUnsignedLine(result);}}
static void main(){twoints * data;data=NULL;data=new twoints;main_sink(data);}void main_sink(twoints * data){delete data;}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;func_ptr(data);}void b_main_sink(wchar_t * data){if (wcsstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
static void main(){{int i=0;i=5;printIntLine(i);}}
static void main(){int data;_union_type my_union;data=-1;data=7;my_union.a=data;{int data=my_union.b;printIntLine(100/data);}}
static void main_sink(char * data){{char dest[50]="";strcat(dest, data);printLine(data);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;func_ptr(data);}
static void main(){char * data;data=NULL;data=new char;delete data;main_sink(&data);}void main_sink(char * * data_ptr){char * data=*data_ptr;}
static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;{char * data_copy=data;char * data=data_copy;{char src[100];strcpy(data, src);printLine(data);}}}
static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}{char dest[100];strcpy(dest, data);printLine(dest);}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=NULL;{char * data=*data_ptr1;data=(char *)calloc(100, sizeof(char));}{char * data=*data_ptr2;free(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");{wchar_t * data_copy=data;wchar_t * data=data_copy;{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");{char * data_copy=data;char * data=data_copy;{char dest[100]="";SNPRINTF(dest, 100-1, data);printLine(dest);}}}
static void main(){if(global_returns_t_or_f()){{HANDLE hMutex=NULL;hMutex=CreateMutexW(NULL, FALSE, NULL);if (hMutex==NULL){exit(1);}if (GetLastError()==ERROR_ALREADY_EXISTS){exit(1);}CloseHandle(hMutex);}}else{{HANDLE hMutex=NULL;hMutex=CreateMutexW(NULL, FALSE, NULL);if (hMutex==NULL){exit(1);}if (GetLastError()==ERROR_ALREADY_EXISTS){exit(1);}CloseHandle(hMutex);}}}
static void main_sink(int count){{size_t i=0;if (count > 0 && count <=20){for (i=0;i < (size_t)count;i++){printLine("Hello");}}}}static void main(){int count;void (*func_ptr) (int)=main_sink;count=-1;fscanf (stdin, "%d", &count);func_ptr(count);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}wchar_t * b_main_source(wchar_t * data){wcscpy(data, L"15");return data;}
static void main(){int data;data=10;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0 && data < 10){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data="P";if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(void * void_data_ptr);static void main(){long long * data;{long long * data_buf=(long long *)malloc(100*sizeof(long long));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5L;}}data=data_buf;}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){long long * * data_ptr=(long long * *)void_data_ptr;long long * data=(*data_ptr);printLongLongLine(data[0]);free(data);}
static void main_sink(int * data){{memmove(data, src, 100*sizeof(int));printIntLine(data[0]);}}static void main(){int * data;void (*func_ptr) (int *)=main_sink;int data_badbuf[50];int data_goodbuf[100];data=data_goodbuf;func_ptr(data);}
static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;if(global_returns_t_or_f()){strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");}else{strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");}{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
int * main_source(int * data);static void main(){int * data;data=main_source(data);printIntLine(data[0]);delete [] data;}int * main_source(int * data){{int * data_buf=new int[100];{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}return data;}
static void main(){int data;data=-1;data=5;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{int result=data-1;printIntLine(result);}}
static void main(){long long * data;data=NULL;main_source(data);delete data;}void main_source(long long * &data){data=new long long;}
static void main(){unsigned int data;data=0;if(global_returns_t_or_f()){fscanf (stdin, "%u", &data);}else{fscanf (stdin, "%u", &data);}if(global_returns_t_or_f()){{unsigned int result=-1;if (data <=(UINT_MAX/2)){result=data * 2;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}else{{unsigned int result=-1;if (data <=(UINT_MAX/2)){result=data * 2;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[250]=L"PATH=";data=data_buf;wcscat(data, NEW_PATH);b_main_sink(data);}void b_main_sink(wchar_t * data){PUTENV(data);}
static void main_sink(char * data){{FILE *pipe;pipe=POPEN(data, "wb");if (pipe!=NULL) PCLOSE(pipe);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");func_ptr(data);}
static void main(){int data;data=RAND32();b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void b_main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnvp(_P_WAIT, COMMAND_INT, args);}}
static void main(){{long long data;data=5L;long long * pointer=new long long;{long long data=*pointer;printLongLongLine(data);}delete pointer;}}
static void main(){char * data;struct_type my_struct;data=NULL;data=new char;my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){char * data=my_struct.a;delete data;}
void b_main_sink(int * data);static void main(){int data;data=-1;data=CHAR_MAX-5;b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{short s=(short)data;printf("%hd\n", s);}}
static void main(){twoints * data;void (*func_ptr) (twoints *)=main_sink;data=NULL;data=new twoints;func_ptr(data);}void main_sink(twoints * data){delete data;}
void _main_sink(wchar_t * data){{size_t i;wchar_t dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);}}static void main(){wchar_t * data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;_main_sink(data);}
static void main(){{char data[150], dest[100];memset(data, 'A', 149);data[149]='\0';memcpy(dest, data, 100*sizeof(char));printLine(dest);}}
void b_main_sink(_struct_type my_struct);static void main(){int data;_struct_type my_struct;data=-1;data=7;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;printIntLine(100/data);}
static wchar_t * main_source(wchar_t * data){data=(wchar_t *)malloc(100*sizeof(wchar_t));free(data);return data;}static void main(){wchar_t * data;data=NULL;data=main_source(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, data);printWLine(dest);}}}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));{wchar_t data_src[10+1]=SRC_STRING;wcsncpy(data, data_src, wcslen(data_src));printWLine(data);free(data);}}
static void main_sink(){char * data=main_data;{char dest[50]="";memmove(dest, data, strlen(data)*sizeof(char));printLine(data);delete [] data;}}static void main(){char * data;data=new char[100];main_data=data;main_sink();}
static void main(){long long * data;_union_type my_union;data=(long long *)malloc(100);my_union.a=data;{long long * data=my_union.b;if (data!=NULL){data[0]=5L;printLongLongLine(data[0]);free(data);}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");func_ptr(data);}void b_main_sink(wchar_t * data){{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char data_buf[100];data=data_buf;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{char dest[50]="";memmove(dest, data, strlen(data)*sizeof(char));printLine(data);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
static void main(){int data;data=7;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main(){int * data;int * &data_ref=data;data=NULL;data=new int;{int * data=data_ref;delete data;}}
static void main(){FILE * data;_union_type my_union;data=fopen("BadSource_fopen.txt", "w+");fclose(data);my_union.a=data;{FILE * data=my_union.b;}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "15");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{int i, n, v;if (sscanf(data, "%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
void b_main_sink();static void main(){char * password;char password_buf[100]="";password=password_buf;{size_t password_len=0;fgets(password, 100, stdin);password_len=strlen(password);if (password_len > 0){password[password_len-1]='\0';}}_main_data=password;b_main_sink();}void b_main_sink(){char * password=_main_data;{HANDLE pHandle;char * username="User";char * domain="Domain";if (LogonUserA( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"15");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main_sink(char * data){_spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;strcat(data, "*.*");func_ptr(data);}
static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_data=data;main_sink();}void main_sink(){wchar_t * data=main_data;delete [] data;}
void b_main_sink(bad_struct data);static void main(){bad_struct data;linked_list head={&head, &head};data.list.next=head.next;data.list.prev=&head;head.next=&data.list;head.next->prev=&data.list;b_main_sink(data);}void b_main_sink(bad_struct data){* */prev=data.list.prev;next=data.list.next;prev->next=next;next->prev=prev;}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, L"%s", args);va_end(args);}}static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}my_union.a=data;{wchar_t * data=my_union.b;main_vasink(data, data);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){double * data;double data_uninit_array[10];data=data_uninit_array;{int i;for(i=0;i<10;i++){data[i]=(double)i;}}{int i;for(i=0;i<10;i++){printDoubleLine(data[i]);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{int i, n, v;if (swscanf(data, L"%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static void main(){long long * data;void (*func_ptr) (long long *)=main_sink;data=NULL;long long data_good;data=&data_good;printLongLongLine(*data);func_ptr(data);}void main_sink(long long * data){}
static void main(){long long * data;data=NULL;data=(long long *)calloc(100, sizeof(long long));data[0]=5L;printLongLongLine(data[0]);b_main_sink(data);}void b_main_sink(long long * data){c_main_sink(data);}void c_main_sink(long long * data){d_main_sink(data);}void d_main_sink(long long * data){free(data);}
static void main(){int data;data=7;{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main(){wchar_t * data;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));data=data_buf;}printWLine(data);free(data);}
static void main(){int data;int data_array[5];data=7;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main_sink(twoints * data){}static void main(){twoints * data;data=NULL;data=new twoints[100];delete [] data;main_sink(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, GOOD_OS_COMMAND);b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;data=(wchar_t *)malloc(100*sizeof(wchar_t));{wchar_t * data=*data_ptr1;}{wchar_t * data=*data_ptr2;{wchar_t dest[50]=L"";wcscpy(dest, data);printWLine(data);free(data);}}}
static void main(){twoints * data;_union_type my_union;twoints data_badbuf[50];twoints data_goodbuf[100];data=data_goodbuf;my_union.a=data;{twoints * data=my_union.b;{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printStructLine(&data[0]);}}}}
static void main(){wchar_t * data;data=NULL;main_source(data);free(data);}void main_source(wchar_t * &data){data=(wchar_t *)malloc(100*sizeof(wchar_t));}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}char * b_main_source(char * data){data=PASSWORD;return data;}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}printWLine(data);free(data);}}
static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}{wchar_t src[100];wcsncpy(data, src, 100);data[100-1]=L'\0';printWLine(data);}}
static twointsclass * main_source(twointsclass * data){data=(twointsclass *)calloc(100, sizeof(twointsclass));return data;}static void main(){twointsclass * data;data=NULL;data=main_source(data);free(data);}
void b_main_sink(short data);static void main(){short data;void (*func_ptr) (short)=b_main_sink;data=0;data=100-1;func_ptr(data);}void b_main_sink(short data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
static void main(){char * data;data=(char *)malloc(100*sizeof(char));{char * data_copy=data;char * data=data_copy;{char dest[50]="";_snprintf(dest, strlen(data), "%s", data);printLine(data);free(data);}}}
void b_main_sink(_struct_type my_struct);static void main(){FILE * data;_struct_type my_struct;data=NULL;data=freopen("BadSource_freopen.txt","w+",stdin);my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){FILE * data=my_struct.a;if (data!=NULL){fclose(data);}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
void b_main_sink(char * cryptokey);static void main(){char * cryptokey;char cryptokey_buf[100]="";cryptokey=cryptokey_buf;{size_t cryptokey_len=strlen(cryptokey);if(100-cryptokey_len > 1){fgets(cryptokey+cryptokey_len, (int)(100-cryptokey_len), stdin);cryptokey_len=strlen(cryptokey);if (cryptokey_len > 0){cryptokey[cryptokey_len-1]='\0';}}}b_main_sink(cryptokey);}void c_main_sink(char * cryptokey);void b_main_sink(char * cryptokey){c_main_sink(cryptokey);}void d_main_sink(char * cryptokey);void c_main_sink(char * cryptokey){d_main_sink(cryptokey);}void e_main_sink(char * cryptokey);void d_main_sink(char * cryptokey){e_main_sink(cryptokey);}void e_main_sink(char * cryptokey){{HCRYPTPROV cryptoprov;HCRYPTKEY key;HCRYPTHASH hash;DWORD toBeEncryptedLen=strlen(toBeEncrypted)*sizeof(char);if(!CryptAcquireContext(&cryptoprov, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, 0)){if(!CryptAcquireContext(&cryptoprov, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET)){printLine("Error in acquiring cryptographic context");exit(1);}}if(!CryptCreateHash(cryptoprov, CALG_SHA1, 0, 0, &hash)){printLine("Error in creating hash");exit(1);}if(!CryptHashData(hash, (BYTE *) cryptokey, strlen(cryptokey)*sizeof(char), 0)){printLine("Error in hashing cryptokey");exit(1);}if(!CryptDeriveKey(cryptoprov, CALG_3DES, hash, 0, &key)){printLine("Error in CryptDeriveKey");exit(1);}if(!CryptEncrypt(key, (HCRYPTHASH)NULL, 1, 0, (BYTE *)toBeEncrypted, &toBeEncryptedLen, sizeof(toBeEncrypted))){printLine("Error in CryptEncryptData");exit(1);}printLine(toBeEncrypted);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){int * data;data=NULL;main_source(data);}void main_source(int * &data){data=new int[100];{size_t i;for(i=0;i < 100;i++){data[i]=5;}}delete [] data;}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];{twointsclass * data_copy=data;twointsclass * data=data_copy;{twointsclass src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printIntLine(data[0].a);delete [] data;}}}}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));printWLine(data);free(data);}}
static wchar_t * main_source(wchar_t * data){{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}return data;}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, L"%s", args);va_end(args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);main_vasink(data, data);}
void b_main_sink(int data);static void main(){int data;data=-1;data=100-1;b_main_sink(data);}void b_main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
static void main(){int * data;data=(int *)ALLOCA(10*sizeof(int));{int i;for(i=0;i<(10/2);i++){data[i]=i;}}{int i;for(i=0;i<10;i++){data[i]=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}}
static void main(){int * data;data=NULL;data=new int;main_data=data;main_sink();}void main_sink(){int * data=main_data;delete data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}{wchar_t * data_copy=data;wchar_t * data=data_copy;fwprintf(stdout, L"%s\n", data);}}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");my_union.a=data;{wchar_t * data=my_union.b;{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}}
void b_main_sink(twoints * data_array[]);static void main(){twoints * data;twoints * data_array[5];{twoints * data_buf=(twoints *)malloc(100*sizeof(twoints));{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(twoints * data_array[]){twoints * data=data_array[2];printStructLine(&data[0]);free(data);}
static void main(){wchar_t * data;data=NULL;main_source(data);free(data);}void main_source(wchar_t * &data){{wchar_t mystring[]=L"mystring";data=wcsdup(mystring);}}
static char * main_source(char * data){{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}return data;}static void main(){char * data;data=(char *)malloc(100*sizeof(char));data[0]='\0';data=main_source(data);{size_t i;for (i=0;i < strlen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}
static void main(){twointsclass * data;data=NULL;data=main_source(data);}twointsclass * main_source(twointsclass * data){data=new twointsclass;delete data;return data;}
static void main(){char data;data=' ';fscanf (stdin, "%c", &data);{char data_copy=data;char data=data_copy;{char result=0;if (data > CHAR_MIN){result=data-1;printHexCharLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{wchar_t src[100];wcsncat(data, src, 100);printWLine(data);}}
static void main(){int data;data=OPEN("BadSource_open.txt", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);CLOSE(data);b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;}
static void main(){short data;data=0;data=100-1;{short data_copy=data;short data=data_copy;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}}
void main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}func_ptr(data);}void main_sink(char * data){{char dest[100];memmove(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}printLine(data);}}
static void main(){int count;count=-1;fscanf (stdin, "%d", &count);b_main_sink(count);}void b_main_sink(int count){{size_t i=0;if (count > 0 && count <=20){for (i=0;i < (size_t)count;i++){printLine("Hello");}}}}
void _main_sink(char * data){{char dest[100];strcpy(dest, data);printLine(dest);}}static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;_main_sink(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){printf("%s\n", data);}
static void main(){twointsclass * data;data=(twointsclass *)ALLOCA(10*sizeof(twointsclass));for(int i=0;i<10;i++){data[i].a=i;data[i].b=i;}for(int i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}
static void main(){char * data;if(global_returns_t_or_f()){{char * data_buf=(char *)malloc(100*sizeof(char));data=data_buf;}}else{{char * data_buf=(char *)malloc(100*sizeof(char));data=data_buf;}}printLine(data);free(data);}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;data=NULL;{wchar_t * data=*data_ptr1;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}}{wchar_t * data=*data_ptr2;{wchar_t dest[100];memcpy(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}}
void b_main_sink(short * data);static void main(){short data;data=0;data=100-1;b_main_sink(&data);}void b_main_sink(short * data_ptr){short data=*data_ptr;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
static void main_sink(char * data){{char src[100];memcpy(data, src, 100*sizeof(char));printLine(data);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;func_ptr(data);}
void main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=NULL;data=new wchar_t[100];func_ptr(data);}void main_sink(wchar_t * data){{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));printWLine(data);delete [] data;}}
void b_main_sink(int data);static void main(){int data;data=-1;data=7;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){printIntLine(100/data);}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]=L'\0';printWLine(data);}}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];data=NULL;data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t data_src[10+1]=SRC_STRING;wcscpy(data, data_src);printWLine(data);free(data);}}
static void main(){unsigned char data;data=' ';data=5;b_main_sink(data);}void b_main_sink(unsigned char data){c_main_sink(data);}void c_main_sink(unsigned char data){d_main_sink(data);}void d_main_sink(unsigned char data){{unsigned char result=data+1;printHexUnsignedCharLine(result);}}
char * main_source(char * data);static void main(){char * data;data=NULL;data=main_source(data);{size_t i;char dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);}}char * main_source(char * data){{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}return data;}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(int data){{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){twoints * data;data=NULL;data=new twoints[100];delete [] data;}
static void main_sink(){char * data=main_data;delete [] data;}static void main(){char * data;data=NULL;data=new char[100];main_data=data;main_sink();}
static void main(){long long * data;long long * *data_ptr1=&data;long long * *data_ptr2=&data;long long data_badbuf[50];long long data_goodbuf[100];{long long * data=*data_ptr1;data=data_goodbuf;}{long long * data=*data_ptr2;{memmove(data, src, 100*sizeof(long long));printLongLongLine(data[0]);}}}
void main_sink(long long * data);static void main(){long long * data;void (*func_ptr) (long long *)=main_sink;data=NULL;data=new long long[100];func_ptr(data);}void main_sink(long long * data){{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printLongLongLine(data[0]);delete [] data;}}}
static void main(){{wchar_t data[150], dest[100];wmemset(data, L'A', 149);data[149]=L'\0';wcsncpy(dest, data, 100);printWLine(dest);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t src[100];wcsncpy(data, src, 100);printWLine(data);free(data);}}
static void main_vasinkb(char * data, ...){{va_list args;va_start(args, data);vprintf(data, args);va_end(args);}}static void main_vasinkg(char * data, ...){{va_list args;va_start(args, data);vprintf("%s", args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}main_vasinkg(data, data);}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, "%s", args);va_end(args);}}static void main_sink(char * data){main_vasink(data, data);}static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}main_sink(data);}
void b_main_sink();static void main(){bad_struct data;linked_list head={&head, &head};data.list.next=head.next;data.list.prev=&head;head.next=&data.list;head.next->prev=&data.list;_main_data=data;b_main_sink();}void b_main_sink(){bad_struct data=_main_data;* */prev=data.list.prev;next=data.list.next;prev->next=next;next->prev=prev;}
static int * main_source(int * data){data=NULL;data=(int *)realloc(data, 100*sizeof(int));return data;}static void main(){int * data;data=NULL;data=main_source(data);free(data);}
static void main(){int * data;data=NULL;if(global_returns_t_or_f()){data=new int[100];}else{data=new int[100];}if(global_returns_t_or_f()){delete [] data;}else{delete [] data;}}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));main_sink(data);}void main_sink(wchar_t * data){free(data);}
static void main(){{if (fwprintf(stdout, L"%s\n", L"string") < 0){printLine("fwprintf failed!");}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
static void main(){int * data;data=(int *)ALLOCA(10*sizeof(int));b_main_sink(&data);}void b_main_sink(int * * data_ptr){int * data=*data_ptr;{int i;for(i=0;i<10;i++){data[i]=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}}
static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;if(global_returns_t_or_f()){strcat(data, "file.txt");}else{strcat(data, "file.txt");}{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");func_ptr(data);}void b_main_sink(char * data){fprintf(stdout, data);}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=NULL;{char * data=*data_ptr1;data=new char[100];memset(data, 'A', 100-1);data[100-1]='\0';}{char * data=*data_ptr2;printLine(data);}}
static void main(){wchar_t * data;wchar_t data_buf[250]=L"PATH=";data=data_buf;wcscat(data, NEW_PATH);PUTENV(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;if(global_returns_t_or_f()){{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}}else{{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}}if(global_returns_t_or_f()){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}else{if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}}
static void main(){if(global_returns_t_or_f()){{wchar_t data_buf[100]=L"";wchar_t * data=data_buf;if (swscanf(SRC, L"%99s\0", data)==EOF){printLine("swscanf failed!");}}}else{{wchar_t data_buf[100]=L"";wchar_t * data=data_buf;if (swscanf(SRC, L"%99s\0", data)==EOF){printLine("swscanf failed!");}}}}
static void main(){char * data;data=NULL;data=new char;delete data;main_sink_b(data);}void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){main_sink_d(data);}void main_sink_d(char * data){main_sink_e(data);}void main_sink_e(char * data){}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];main_sink(&data);}void main_sink(void * void_data_ptr){twointsclass * * data_ptr=(twointsclass * *)void_data_ptr;twointsclass * data=(*data_ptr);delete [] data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]=L'\0';printWLine(data);}}
void b_main_sink(_struct_type my_struct);static void main(){int * data;_struct_type my_struct;int data_badbuf[50];int data_goodbuf[100];data=data_goodbuf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int * data=my_struct.a;{memmove(data, src, 100*sizeof(int));printIntLine(data[0]);}}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
static wchar_t * main_source(wchar_t * data){wcscpy(data, L"fixedstringtest");return data;}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);main_vasink(data, data);}
static long long * main_source(long long * data){data=new long long;return data;}static void main(){long long * data;data=NULL;data=main_source(data);delete data;}
static void main(){struct _twoints * data;data=NULL;main_source(data);}void main_source(struct _twoints * &data){struct _twoints data_good;data=&data_good;data->a=0;data->b=0;printStructLine((twoints *)data);}
static void main(){wchar_t * data;data=NULL;if(global_returns_t_or_f()){data=(wchar_t *)malloc(100*sizeof(wchar_t));}else{data=(wchar_t *)malloc(100*sizeof(wchar_t));}{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}printWLine(data);free(data);}}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
void b_main_sink(short data);static void main(){short data;data=0;data=100-1;b_main_sink(data);}void c_main_sink(short data);void b_main_sink(short data){c_main_sink(data);}void d_main_sink(short data);void c_main_sink(short data){d_main_sink(data);}void e_main_sink(short data);void d_main_sink(short data){e_main_sink(data);}void e_main_sink(short data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");func_ptr(data);}void b_main_sink(char * data){{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
void b_main_sink(_struct_type my_struct);static void main(){float data;_struct_type my_struct;data=0.0F;data=7.0F;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){float data=my_struct.a;printDoubleLine((double)(100.0/data));}
void b_main_sink(char * data);static void main(){char * data;{char * data_buf=(char *)malloc(100*sizeof(char));data=data_buf;}b_main_sink(data);}void b_main_sink(char * data){printLine(data);free(data);}
static void main_sink(float data){printDoubleLine((double)(100.0/data));}static void main(){float data;void (*func_ptr) (float)=main_sink;data=0.0F;data=7.0F;func_ptr(data);}
void main_sink(void * void_data_ptr);static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}main_sink(&data);}void main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}
static void main(){{HDESK hDesk;wchar_t * dtName=L"DesktopExample";hDesk=CreateDesktopW( dtName, NULL, NULL, 0, GENERIC_READ, NULL);if (hDesk==NULL){printLine("Desktop could not be created");}else{printLine("Desktop created successfully");CloseDesktop(hDesk);}}}
static void main(){twointsclass * data;union_type my_union;{twointsclass * data_buf=new twointsclass[100];{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}my_union.a=data;{twointsclass * data=my_union.b;printIntLine(data[0].a);delete [] data;}}
static void main(){int * data;data=NULL;{int data_goodbuf[100];data=data_goodbuf;data[0]=5;printIntLine(data[0]);}b_main_sink(&data);}void b_main_sink(int * * data_ptr){int * data=*data_ptr;}
static void main(){twoints * data;twoints * data_array[5];data=NULL;twoints data_good;data=&data_good;data->a=0;data->b=0;printStructLine(data);data_array[2]=data;main_sink(data_array);}void main_sink(twoints * data_array[]){twoints * data=data_array[2];}
static void main_sink(int data){{int result=data+1;printIntLine(result);}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=5;func_ptr(data);}
static void main(){int count;count=-1;count=20;b_main_sink(&count);}void b_main_sink(int * count_ptr){int count=*count_ptr;{size_t i=0;for (i=0;i < (size_t)count;i++){printLine("Hello");}}}
static void main_sink(){int data=_main_data;{char c=(char)data;printHexCharLine(c);}}static void main(){int data;data=-1;data=CHAR_MAX-5;_main_data=data;main_sink();}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{char dest[100];memmove(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
static void main(){int data;data=-1;data=5;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);{int result=data-1;printIntLine(result);}}
static void main(){twoints * data;data=NULL;data=(twoints *)malloc(sizeof(*data));data->a=1;data->b=2;printStructLine(data);free(data);}
static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;data=L"P";data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(float data);static void main(){float data;data=0.0F;data=7.0F;b_main_sink(data);}void c_main_sink(float data);void b_main_sink(float data){c_main_sink(data);}void c_main_sink(float data){printDoubleLine((double)(100.0/data));}
void _main_sink(char * data){{char dest[100];strcpy(dest, data);printLine(dest);}}static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;_main_sink(data);}
static void main(){wchar_t * data;data=NULL;data=NULL;data=(wchar_t *)realloc(data, 100*sizeof(wchar_t));{wchar_t * data_copy=data;wchar_t * data=data_copy;free(data);}}
int b_main_source(int data);static void main(){int data;data=-1;data=b_main_source(data);{size_t i;int *b;b=(int*)malloc(data * sizeof(int));for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);free(b);}}int b_main_source(int data){data=20;return data;}
void b_main_sink(short data_array[]);static void main(){short data;short data_array[5];data=0;data=100-1;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(short data_array[]){short data=data_array[2];{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main_sink(twointsclass * data){delete data;}static void main(){twointsclass * data;data=NULL;data=new twointsclass;main_sink(data);}
static void main(){int data;data=-1;data=5;b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{int result=data+1;printIntLine(result);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));data[0]=L'\0';wcscpy(data, BAD_SRC_FIXED);b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{size_t i;for (i=0;i < wcslen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}
static void main_sink(char * data){{char src[100];_snprintf(data, 100, "%s", src);printLine(data);delete [] data;}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;data=new char[100];func_ptr(data);}
static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;{char src[100];memcpy(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;strcat(data, "*.*");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
void main_sink(char * data);static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}main_sink(data);}void main_sink(char * data){{char src[100];memmove(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}
static void main(){char data;data=' ';fscanf (stdin, "%c", &data);{char result=-1;if (data <=(CHAR_MAX/2)){result=data * 2;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;fprintf(stdout, "%s\n", data);}
static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));main_data=data;main_sink();}void main_sink(){long long * data=main_data;free(data);}
static void main(){int data;int data_array[5];data=-1;data=5;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{int result=data+1;printIntLine(result);}}
void main_sink(char * data);static void main(){char * data;data=new char[100];main_sink(data);}void main_sink(char * data){{char dest[50]="";size_t i, data_len;data_len=strlen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printLine(data);delete [] data;}}
static void main_sink(char * data){{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");func_ptr(data);}
static void main_sink(twointsclass * data){delete [] data;}static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];main_sink(data);}
void b_main_sink(int data);static void main(){int data;data=-1;data=7;b_main_sink(data);}void b_main_sink(int data){printIntLine(100/data);}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;_wsystem(data);}
static void main(){int data;data=-1;data=20;{size_t i;int *b;b=(int*)malloc(data * sizeof(int));for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);free(b);}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;data=NULL;data=(char *)malloc(100*sizeof(char));my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{size_t i, dest_sz;char dest[100];memset(dest, 'C', 100-1);dest_sz=strlen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);free(data);}}
static void main(){char * data;_union_type my_union;data=(char *)malloc(100*sizeof(char));my_union.a=data;{char * data=my_union.b;{char dest[50]="";strncat(dest, data, strlen(data));printLine(data);free(data);}}}
static void main(){char data;data=' ';fscanf (stdin, "%c", &data);_main_data=data;b_main_sink();}void b_main_sink(){char data=_main_data;{char result=-1;if (data < CHAR_MAX){result=data+1;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main_source(char * &data){{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}}static void main(){char * data;data=NULL;main_source(data);{char dest[100];memmove(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
static void main(){int data;data=7;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){{wchar_t data_buf[10]=L"AAAAAAAAA";if (data >=0){printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
void b_main_sink();static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]=L'\0';printWLine(data);}}
static void main(){int * data;int data_uninit_array[10];data=data_uninit_array;{int i;for(i=0;i<(10/2);i++){data[i]=i;}}{int i;for(i=0;i<10;i++){data[i]=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}}
static void main(){{char data_buf[100]="";char * data=data_buf;if (scanf("%99s\0", data)==EOF){printLine("scanf failed!");exit(1);}}}
static void main_sink(){char * data=_main_data;{char dest[50]="";strncpy(dest, data, strlen(data));printLine(data);}}static void main(){char * data;char data_buf[100];data=data_buf;_main_data=data;main_sink();}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"15");func_ptr(data);}void b_main_sink(wchar_t * data){{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
void _main_sink(twoints * data){{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memcpy(data, src, 100*sizeof(twoints));printStructLine(&data[0]);}}static void main(){twoints * data;twoints data_badbuf[50];twoints data_goodbuf[100];data=data_goodbuf;_main_sink(data);}
static void main(){wchar_t * data;union_type my_union;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}my_union.a=data;{wchar_t * data=my_union.b;{wchar_t dest[100];memmove(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}}
static void main(){int data;data=-1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}{int result=-1;if (data <=(INT_MAX/2)){result=data * 2;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)calloc(100, sizeof(wchar_t));main_sink_b(data);}void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_d(wchar_t * data){free(data);}
static wchar_t * main_source(wchar_t * data){{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}return data;}static void main(){wchar_t * data;data=NULL;data=main_source(data);{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnvp(_P_WAIT, COMMAND_INT, args);}}
static void main(){int * data;data=(int *)malloc(10*sizeof(int));{int i;for(i=0;i<10;i++){data[i]=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}}
static void main(){int data;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main_sink(wchar_t * data){delete data;}static void main(){wchar_t * data;data=NULL;data=new wchar_t;main_sink(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}char * b_main_source(char * data){data="P";return data;}
static void main_sink(){twointsclass * data=main_data;}static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}delete [] data;main_data=data;main_sink();}
static void main_sink(){wchar_t * data=_main_data;if (data!=NULL){wcscpy(data, L"Initialize");printWLine(data);free(data);}}static void main(){wchar_t * data;data=(wchar_t *)malloc(100);_main_data=data;main_sink();}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;main_sink(&data);}void main_sink(twointsclass * * data_ptr){twointsclass * data=*data_ptr;delete data;}
static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t src[100];wcscpy(data, src);printWLine(data);}}}
static void main_sink(char * data){fprintf(stdout, data);}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");func_ptr(data);}
static void main_sink(){wchar_t * data=main_data;{wchar_t dest[50]=L"";memmove(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);delete [] data;}}static void main(){wchar_t * data;data=new wchar_t[100];main_data=data;main_sink();}
static void main(){int data;data=-1;data=10000;{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf("%s", args);va_end(args);}}static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}my_union.a=data;{char * data=my_union.b;main_vasink(data, data);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=ASSERT_VALUE+1;}{int data=*data_ptr2;assert(data > ASSERT_VALUE);}}
char * main_source(char * data);static void main(){char * data;data=new char[100];data=main_source(data);{char dest[50]="";size_t i, data_len;data_len=strlen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printLine(data);delete [] data;}}char * main_source(char * data){return data;}
void _main_sink(char * data){PUTENV(data);}static void main(){char * data;char data_buf[250]="PATH=";data=data_buf;strcat(data, NEW_PATH);_main_sink(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);{char dest[100]="";SNPRINTF(dest, 100-1, data);printLine(dest);}}char * b_main_source(char * data){strcpy(data, "fixedstringtest");return data;}
static void main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}
static void main(){twoints * data;data=NULL;data=new twoints;main_sink_b(data);}void main_sink_b(twoints * data){main_sink_c(data);}void main_sink_c(twoints * data){main_sink_d(data);}void main_sink_d(twoints * data){main_sink_e(data);}void main_sink_e(twoints * data){delete data;}
static void main(){long long * data;union_type my_union;data=NULL;data=new long long;my_union.a=data;{long long * data=my_union.b;delete data;}}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];data=NULL;data=(char *)malloc((10+1)*sizeof(char));data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{char data_src[10+1]=SRC_STRING;strncpy(data, data_src, strlen(data_src));printLine(data);free(data);}}
void b_main_sink(twoints * data);static void main(){twoints * data;data=NULL;{twoints tmp;tmp.a=0;tmp.b=0;data=&tmp;}b_main_sink(data);}void c_main_sink(twoints * data);void b_main_sink(twoints * data){c_main_sink(data);}void d_main_sink(twoints * data);void c_main_sink(twoints * data){d_main_sink(data);}void d_main_sink(twoints * data){printStructLine(data);}
static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}{char dest[100];strcpy(dest, data);printLine(dest);}}
static wchar_t * main_source(wchar_t * data){wcscat(data, L"file.txt");return data;}static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;data=main_source(data);{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
static void main(){long long * data;data=NULL;main_source(data);free(data);}void main_source(long long * &data){data=(long long *)malloc(100*sizeof(long long));}
static void main(){twoints * data;twoints data_badbuf[50];twoints data_goodbuf[100];data=data_goodbuf;{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memcpy(data, src, 100*sizeof(twoints));printStructLine(&data[0]);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "C:\\Windows\\System32\\winsrv.dll");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{HMODULE hModule;hModule=LoadLibraryA(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
static void main(){int data;data=7;b_main_sink(data);}void b_main_sink(int data){{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main(){unsigned char data;data=' ';data=5;_main_data=data;b_main_sink();}void b_main_sink(){unsigned char data=_main_data;{unsigned char result=data-1;printHexUnsignedCharLine(result);}}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){int data;data=7;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main(){twointsclass * data;data=NULL;data=(twointsclass *)calloc(100, sizeof(twointsclass));free(data);}
static void main_sink(){wchar_t * data=_main_data;if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}_main_data=data;main_sink();}
static void main(){int data;data=-1;data=20;{int data_copy=data;int data=data_copy;{char * char_string;if (data > 0){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than 0");}}}}
static void main(){twoints * data;_struct_type my_struct;data=NULL;data=(twoints *)calloc(100, sizeof(twoints));data[0].a=0;data[0].b=0;printStructLine(&data[0]);my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){twoints * data=my_struct.a;free(data);}
static void main(){int count;count=-1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);count=atoi(input_buf);}b_main_sink(count);}void b_main_sink(int count){c_main_sink(count);}void c_main_sink(int count){d_main_sink(count);}void d_main_sink(int count){e_main_sink(count);}void e_main_sink(int count){{size_t i=0;if (count > 0 && count <=20){for (i=0;i < (size_t)count;i++){printLine("Hello");}}}}
static void main_sink(wchar_t * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");func_ptr(data);}
static void main_sink(twoints * data){delete data;}static void main(){twoints * data;void (*func_ptr) (twoints *)=main_sink;data=NULL;data=new twoints;func_ptr(data);}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;if(global_returns_t_or_f()){wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");}else{wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");}{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
static void main(){int data;data=7;{wchar_t data_buf[10]=L"AAAAAAAAA";if (data >=0){printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");my_struct.a=data;b_main_sink(my_struct);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, data, args);va_end(args);}}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;main_vasink(data, data);}
void main_sink();static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}_main_data=data;main_sink();}void main_sink(){wchar_t * data=_main_data;{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]=L'\0';printWLine(data);}}
static void main(){if(global_returns_t_or_f()){{if (fwrite((char *)"string", sizeof(char), strlen("string"), stdout)!=strlen("string")){printLine("fwrite failed!");}}}else{{if (fwrite((char *)"string", sizeof(char), strlen("string"), stdout)!=strlen("string")){printLine("fwrite failed!");}}}}
static void main(){twoints * data;twoints * &data_ref=data;data=new twoints[10];{int i;for(i=0;i<10;i++){data[i].a=i;data[i].b=i;}}{twoints * data=data_ref;{int i;for(i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}delete [] data;}}
static wchar_t * main_source(wchar_t * data){data=new wchar_t[100];return data;}static void main(){wchar_t * data;data=NULL;data=main_source(data);{wchar_t src[100];wcscat(data, src);printWLine(data);delete [] data;}}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}main_sink(&data);}void main_sink(int * data_ptr){int data=*data_ptr;{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){twoints * data;data=NULL;if(global_returns_t_or_f()){data=(twoints *)malloc(100*sizeof(twoints));free(data);}else{data=(twoints *)malloc(100*sizeof(twoints));free(data);}if(global_returns_t_or_f()){}else{}}
static void main(){long long * data;data=NULL;data=new long long[100];delete [] data;main_sink_b(data);}void main_sink_b(long long * data){main_sink_c(data);}void main_sink_c(long long * data){main_sink_d(data);}void main_sink_d(long long * data){main_sink_e(data);}void main_sink_e(long long * data){}
static char * main_source(char * data){{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}return data;}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);{int i, n, v;if (sscanf(data, "%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static void main(){wchar_t * password;_union_type my_union;password=L"";password=(wchar_t *)malloc(100*sizeof(wchar_t));if(!VirtualLock(password, 100*sizeof(wchar_t))){printLine("Memory could not be locked");exit(1);}wcscpy(password, L"Password1234!");my_union.a=password;{wchar_t * password=my_union.b;{HANDLE pHandle;wchar_t * username=L"User";wchar_t * domain=L"Domain";if (LogonUserW( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}}
static void main(){long long * data;data=NULL;data=new long long[100];main_sink_b(data);}void main_sink_b(long long * data){main_sink_c(data);}void main_sink_c(long long * data){delete [] data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(char * data);static void main(){char * data;data=(char *)malloc(100*sizeof(char));data[0]='\0';{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{size_t i;for (i=0;i < strlen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}
void b_main_sink(short data);static void main(){short data;data=0;data=100-1;b_main_sink(data);}void b_main_sink(short data){{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
static void main(){int data;data=-1;data=20;main_sink_b(data);}void main_sink_b(int data){main_sink_c(data);}void main_sink_c(int data){main_sink_d(data);}void main_sink_d(int data){main_sink_e(data);}void main_sink_e(int data){{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}
void _main_sink(int data){printIntLine(100/data);}static void main(){int data;data=-1;data=7;_main_sink(data);}
static void main(){{char dst[DST_SZ];char *result;result=fgets(dst, DST_SZ, stdin);if( NULL==result ){printLine("Error Condition: alter control flow to indicate action taken");exit(1);}dst[DST_SZ-1]='\0';printLine(dst);}}
static void main(){struct _twoints * data;data=NULL;struct _twoints data_good;data=&data_good;data->a=0;data->b=0;printStructLine((twoints *)data);main_sink(&data);}void main_sink(struct _twoints * * data_ptr){struct _twoints * data=*data_ptr;}
static void main(){int * data;data=(int *)ALLOCA(10*sizeof(int));if(global_returns_t_or_f()){}else{}if(global_returns_t_or_f()){{int i;for(i=0;i<10;i++){data[i]=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}}else{{int i;for(i=0;i<10;i++){data[i]=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}}}
static void main(){twoints * data;data=NULL;data=new twoints;main_sink(&data);}void main_sink(twoints * * data_ptr){twoints * data=*data_ptr;delete data;}
static void main(){twoints * data;data=NULL;data=(twoints *)calloc(100, sizeof(twoints));main_sink(&data);}void main_sink(twoints * * data_ptr){twoints * data=*data_ptr;free(data);}
static void main_sink(wchar_t * data){_wsystem(data);}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");func_ptr(data);}
void b_main_sink();static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{char dest[100];memset(dest, 'C', 100-1);memmove(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);free(data);}}
static void main(){char * data;data=NULL;data=new char[100];{char src[100];strcpy(data, src);printLine(data);delete [] data;}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}{int i, n, v;if (swscanf(data, L"%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(L"%s", args);va_end(args);}}static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}my_union.a=data;{wchar_t * data=my_union.b;main_vasink(data, data);}}
int b_main_source(int data);static void main(){int data;data=-1;data=b_main_source(data);{char c=(char)data;printHexCharLine(c);}}int b_main_source(int data){data=CHAR_MAX-5;return data;}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';{wchar_t * data=*data_ptr1;data=data_buf;}{wchar_t * data=*data_ptr2;{wchar_t dest[100];memcpy(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}}
static void main(){int data;data=-1;data=b_main_source(data);{int result=data * 2;printIntLine(result);}}int b_main_source(int data){data=5;return data;}
static void main(){wchar_t * data;data=NULL;data=new wchar_t;main_sink_b(data);}void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_d(wchar_t * data){delete data;}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[100];data=data_buf;b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char dest[50]="";size_t i, data_len;data_len=strlen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printLine(data);}}
static void main_sink(char * data){{char dest[100];memmove(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;func_ptr(data);}
void main_sink(char * * data);static void main(){char * data;data=new char[100];main_sink(&data);}void main_sink(char * * data_ptr){char * data=*data_ptr;{char dest[50]="";strncat(dest, data, strlen(data));printLine(data);delete [] data;}}
static void main(){char data;data=' ';if(global_returns_t_or_f()){data=(char)rand();}else{data=(char)rand();}if(global_returns_t_or_f()){{char result=0;if (data > CHAR_MIN){result=data-1;printHexCharLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}else{{char result=0;if (data > CHAR_MIN){result=data-1;printHexCharLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}}
static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");{char * data_copy=data;char * data=data_copy;{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, L"%s", args);va_end(args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}{wchar_t * data_copy=data;wchar_t * data=data_copy;main_vasink(data, data);}}
static void main_sink(twointsclass * data){delete [] data;}static void main(){twointsclass * data;void (*func_ptr) (twointsclass *)=main_sink;data=NULL;data=new twointsclass[100];func_ptr(data);}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;wcscpy(data, L"15");}{wchar_t * data=*data_ptr2;{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static void main(){char * data;data=NULL;data=new char;printHexCharLine(*data);main_sink(&data);}void main_sink(char * * data_ptr){char * data=*data_ptr;delete data;}
static void main(){if(global_returns_t_or_f()){{int * data=(int *)malloc(100*sizeof(int));int * tmp;data[0]=5;printIntLine(data[0]);tmp=(int *)realloc(data, (130000)*sizeof(int));if (tmp!=NULL){data=tmp;data[0]=10;printIntLine(data[0]);}free(data);}}else{{int * data=(int *)malloc(100*sizeof(int));int * tmp;data[0]=5;printIntLine(data[0]);tmp=(int *)realloc(data, (130000)*sizeof(int));if (tmp!=NULL){data=tmp;data[0]=10;printIntLine(data[0]);}free(data);}}}
void b_main_sink(int data);static void main(){int data;data=-1;data=100-1;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main(){twoints * data;{twoints * data_buf=(twoints *)malloc(100*sizeof(twoints));{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}printStructLine(&data[0]);free(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "15");{int i, n, v;if (sscanf(data, "%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");{wchar_t * data_copy=data;wchar_t * data=data_copy;{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}}
static wchar_t * main_source(wchar_t * data){return data;}static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));data=main_source(data);{wchar_t dest[50]=L"";memcpy(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);free(data);}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]="";data=data_buf;{char * data=*data_ptr1;strcpy(data, "fixedstringtest");}{char * data=*data_ptr2;fprintf(stdout, data);}}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char dest[100];memcpy(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;strcat(data, "*.*");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
static void main(){struct _twoints * data;data=NULL;data=(struct _twoints *)malloc(100*sizeof(struct _twoints));data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);free(data);}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];main_sink_b(data);}void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_c(twointsclass * data){delete [] data;}
static void main(){int data;data=-1;data=20;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);{char * char_string;if (data > 0){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than 0");}}}
static char * main_source(char * data){data=(char *)malloc(100*sizeof(char));return data;}static void main(){char * data;data=NULL;data=main_source(data);free(data);}
static void main_sink(){unsigned char data=_main_data;{unsigned char result=-1;if (data <=(UCHAR_MAX/2)){result=data * 2;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}static void main(){unsigned char data;data=' ';data=(unsigned char)rand();_main_data=data;main_sink();}
static void main(){twoints * data;struct_type my_struct;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){twoints * data=my_struct.a;free(data);}
static void main_sink(wchar_t * data){_wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");func_ptr(data);}
static void main(){int * data;data=NULL;main_source(data);delete data;}void main_source(int * &data){data=new int;}
static void main(){twoints * data;if(global_returns_t_or_f()){}else{}if(global_returns_t_or_f()){data=(twoints *)malloc(sizeof(twoints));data->a=5;data->b=6;printIntLine(data->a);printIntLine(data->b);}else{data=(twoints *)malloc(sizeof(twoints));data->a=5;data->b=6;printIntLine(data->a);printIntLine(data->b);}}
char * b_main_source(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}char * b_main_source(char * data){strcat(data, "*.*");return data;}
static void main_sink(){int data=main_data;{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}main_data=data;main_sink();}
short b_main_source(short data);static void main(){short data;data=0;data=b_main_source(data);{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}short b_main_source(short data){data=100-1;return data;}
static void main(){unsigned int data;_union_type my_union;data=0;fscanf (stdin, "%u", &data);my_union.a=data;{unsigned int data=my_union.b;{unsigned int result=-1;if (data <=(unsigned int)sqrt((unsigned int)UINT_MAX)){result=data * data;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}printf("%s\n", data);}
void b_main_sink(char * * data);static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char src[100];memcpy(data, src, 100*sizeof(char));printLine(data);}}
static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{int i, n, v;if (sscanf(data, "%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static void main(){int data;data=-1;data=RAND32();b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){int count;count=-1;count=RAND32();{size_t i=0;FILE *file=NULL;const char *filename="output_good.txt";if (count > 0 && count <=20){file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}}
static void main_sink(wchar_t * data){{wchar_t src[100];wcscat(data, src);printWLine(data);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;func_ptr(data);}
static void main_sink(){FILE * data=_main_data;if (data!=NULL){fclose(data);}}static void main(){FILE * data;data=NULL;data=fopen("file.txt", "w+");_main_data=data;main_sink();}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=NULL;{char * data=*data_ptr1;{char data_goodbuf[100];data=data_goodbuf;strcpy(data, "A String");printLine(data);}}{char * data=*data_ptr2;}}
static void main(){{if (puts("string")==EOF){printLine("puts failed!");exit(1);}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100];data=data_buf;b_main_sink(data);}void b_main_sink(char * data){{char dest[50]="";strcpy(dest, data);printLine(data);}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_sink_b(data);}void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_d(wchar_t * data){delete [] data;}
static void main(){twoints * data;twoints * data_array[5];data=NULL;data=new twoints[100];data_array[2]=data;main_sink(data_array);}void main_sink(twoints * data_array[]){twoints * data=data_array[2];delete [] data;}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"15");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100];data=data_buf;func_ptr(data);}void b_main_sink(wchar_t * data){{wchar_t dest[50]=L"";wcscpy(dest, data);printWLine(data);}}
static void main(){long long * data;long long * data_array[5];data=NULL;data=new long long;data_array[2]=data;main_sink(data_array);}void main_sink(long long * data_array[]){long long * data=data_array[2];delete data;}
static void main(){wchar_t * data;_union_type my_union;data=(wchar_t *)malloc(100*sizeof(wchar_t));data[0]=L'\0';{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}my_union.a=data;{wchar_t * data=my_union.b;{size_t i;for (i=0;i < wcslen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{wchar_t dest[100];wcsncpy(dest, data, wcslen(dest));dest[100-1]=L'\0';printWLine(dest);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
static void main_sink(wchar_t * data){{size_t i, dest_sz;wchar_t dest[100];wmemset(dest, L'C', 100-1);dest_sz=wcslen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);free(data);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));func_ptr(data);}
static void main(){char * data;data=NULL;data=main_source(data);delete data;}char * main_source(char * data){data=new char;return data;}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;{int data=*data_ptr1;data=7;}{int data=*data_ptr2;{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}}
void _main_sink(char * data){{char dest[100];memset(dest, 'C', 100-1);memcpy(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);free(data);}}static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));_main_sink(data);}
static void main(){long long * data;data=NULL;data=new long long;main_sink_b(data);}void main_sink_b(long long * data){main_sink_c(data);}void main_sink_c(long long * data){delete data;}
void b_main_sink(long long * * data);static void main(){long long * data;{long long * data_buf=(long long *)malloc(100*sizeof(long long));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5L;}}data=data_buf;}b_main_sink(&data);}void b_main_sink(long long * * data_ptr){long long * data=*data_ptr;printLongLongLine(data[0]);free(data);}
static void main(){char * data;struct_type my_struct;data=NULL;{char mystring[]="mystring";data=strdup(mystring);}my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){char * data=my_struct.a;free(data);}
static void main(){int data;data=-1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{int result=-1;if (data < INT_MAX){result=data+1;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){long long * data;data=NULL;data=new long long;{long long * data_copy=data;long long * data=data_copy;delete data;}}
static void main(){char * data;void (*func_ptr) (char *, ...)=b_main_vasink;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}func_ptr(data);}void b_main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, "%s", args);va_end(args);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
static void main(){char * data;_union_type my_union;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");my_union.a=data;{char * data=my_union.b;{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];{twointsclass src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memmove(data, src, 100*sizeof(twointsclass));printIntLine(data[0].a);delete [] data;}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}my_union.a=data;{wchar_t * data=my_union.b;if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;b_main_sink(data);}void b_main_sink(wchar_t * data){{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}printWLine(data);}}
static void main(){int data;data=-1;data=100-1;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;wprintf(L"%s\n", data);}
void b_main_sink();static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{char dest[100];memcpy(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
static void main(){int count;count=-1;count=RAND32();b_main_sink(count);}void b_main_sink(int count){{size_t i=0;FILE *file=NULL;const char *filename="output_good.txt";if (count > 0 && count <=20){file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}}
static void main(){int * data;data=NULL;data=new int[100];main_sink_b(data);}void main_sink_b(int * data){main_sink_c(data);}void main_sink_c(int * data){main_sink_d(data);}void main_sink_d(int * data){main_sink_e(data);}void main_sink_e(int * data){delete [] data;}
static void main(){char data;data=' ';data=CHAR_MIN;{char result=0;if (data > CHAR_MIN){result=data-1;printHexCharLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
void b_main_sink(int * data);static void main(){int data;data=-1;data=100-1;b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, "%s", args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}{char * data_copy=data;char * data=data_copy;main_vasink(data, data);}}
static void main(){char * data;char data_buf[100];data=data_buf;if(global_returns_t_or_f()){}else{}{char dest[50]="";strncpy(dest, data, strlen(data));printLine(data);}}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf("%s", args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}{char * data_copy=data;char * data=data_copy;main_vasink(data, data);}}
static void main(){struct _twoints * data;data=NULL;struct _twoints data_good;data=&data_good;data->a=0;data->b=0;printStructLine((twoints *)data);main_data=data;main_sink();}void main_sink(){struct _twoints * data=main_data;}
static void main(){int data;_union_type my_union;data=-1;data=5;my_union.a=data;{int data=my_union.b;{int result=data * data;printIntLine(result);}}}
static void main(){char * data;data=NULL;data=(char *)malloc((10+1)*sizeof(char));{char data_src[10+1]=SRC_STRING;strcpy(data, data_src);printLine(data);free(data);}}
static void main_sink(){char * data=main_data;delete data;}static void main(){char * data;data=NULL;data=new char;main_data=data;main_sink();}
static void main_sink(int * data){delete data;}static void main(){int * data;data=NULL;data=new int;main_sink(data);}
static void main(){{if (putwchar((wchar_t)L'A')==WEOF){printLine("putwchar failed!");exit(1);}}}
static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));free(data);}
void main_sink_b(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_sink_b(data);}void main_sink_c(wchar_t * data);void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_d(wchar_t * data);void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_e(wchar_t * data);void main_sink_d(wchar_t * data){main_sink_e(data);}void main_sink_e(wchar_t * data){{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}printWLine(data);delete [] data;}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, L"%s", data);printWLine(dest);}}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;if (wcsncmp(PASSWORD, data, wcslen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, L"%s", data);printWLine(dest);}}
static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}my_struct.a=data;b_main_sink(my_struct);}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, "%s", args);va_end(args);}}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;main_vasink(data, data);}
static void main(){int data;data=-1;data=100-1;{int data_copy=data;int data=data_copy;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}}
void b_main_sink(int data);static void main(){int data;data=-1;data=7;b_main_sink(data);}void b_main_sink(int data){printIntLine(100/data);}
static void main(){int data;data=-1;fscanf (stdin, "%d", &data);main_sink_b(data);}void main_sink_b(int data){main_sink_c(data);}void main_sink_c(int data){main_sink_d(data);}void main_sink_d(int data){main_sink_e(data);}void main_sink_e(int data){{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{int i, n, v;if (sscanf(data, "%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static void main_sink(wchar_t * data){free(data);}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=NULL;data=(wchar_t *)calloc(100, sizeof(wchar_t));func_ptr(data);}
static void main(){unsigned char data;data=' ';data=5;b_main_sink(data);}void b_main_sink(unsigned char data){c_main_sink(data);}void c_main_sink(unsigned char data){d_main_sink(data);}void d_main_sink(unsigned char data){e_main_sink(data);}void e_main_sink(unsigned char data){{unsigned char result=data * data;printHexUnsignedCharLine(result);}}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
void b_main_sink(char * data);static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{char src[100];strcat(data, src);printLine(data);free(data);}}
static void main(){wchar_t * data;data=NULL;data=b_main_source(data);free(data);}wchar_t * b_main_source(wchar_t * data){{wchar_t mystring[]=L"mystring";data=wcsdup(mystring);printWLine(data);}return data;}
static void main(){char data;data=' ';data=5;b_main_sink(data);}void b_main_sink(char data){c_main_sink(data);}void c_main_sink(char data){d_main_sink(data);}void d_main_sink(char data){e_main_sink(data);}void e_main_sink(char data){{char result=data+1;printHexCharLine(result);}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=NULL;{char * data=*data_ptr1;data=new char[100];}{char * data=*data_ptr2;delete [] data;}}
static void main(){int data;data=-1;data=5;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){{int result=data * 2;printIntLine(result);}}
void b_main_sink(int * data);static void main(){int data;data=-1;data=CHAR_MAX-5;b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{short s=(short)data;printf("%hd\n", s);}}
static void main(){FILE * data;FILE * *data_ptr1=&data;FILE * *data_ptr2=&data;data=NULL;{FILE * data=*data_ptr1;data=WFOPEN(L"file.txt", L"w+");}{FILE * data=*data_ptr2;if (data!=NULL){fclose(data);}}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char src[100];memmove(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{wchar_t src[100];_snwprintf(data, 100, L"%s", src);printWLine(data);free(data);}}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;data=b_main_source(data);{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}wchar_t * b_main_source(wchar_t * data){wcscat(data, L"file.txt");return data;}
static void main(){struct _twoints * data;data=NULL;if(global_returns_t_or_f()){{struct _twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);}}else{{struct _twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);}}if(global_returns_t_or_f()){}else{}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(wchar_t * data){if (wcsstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink();static void main(){char * data;data=(char *)calloc(100, sizeof(char));_bad_data_for_good_sink=data;b_main_sink();}void b_main_sink(){char * data=_bad_data_for_good_sink;if (data!=NULL){strcpy(data, "Initialize");printLine(data);free(data);}}
static void main(){if(global_returns_t_or_f()){{if (fprintf(stdout, "%s\n", "string") < 0){printLine("fprintf failed!");}}}else{{if (fprintf(stdout, "%s\n", "string") < 0){printLine("fprintf failed!");}}}}
static void main(){twoints * data;data=NULL;main_source(data);free(data);}void main_source(twoints * &data){data=(twoints *)calloc(100, sizeof(twoints));}
void b_main_sink(FILE * data);static void main(){FILE * data;data=NULL;data=freopen("BadSource_freopen.txt","w+",stdin);b_main_sink(data);}void c_main_sink(FILE * data);void b_main_sink(FILE * data){c_main_sink(data);}void d_main_sink(FILE * data);void c_main_sink(FILE * data){d_main_sink(data);}void e_main_sink(FILE * data);void d_main_sink(FILE * data){e_main_sink(data);}void e_main_sink(FILE * data){if (data!=NULL){fclose(data);}}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}{int result=-1;if (data < INT_MAX){result=data+1;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}fprintf(stdout, "%s\n", data);}
static void main_sink(){wchar_t * data=_main_data;EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_data=data;main_sink();}
void _main_sink(wchar_t * data){{wchar_t src[100];wcscpy(data, src);printWLine(data);}}static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}_main_sink(data);}
static void main_sink(){int data=_main_data;{int result=-1;if (data <=(int)sqrt((int)INT_MAX)){result=data * data;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}_main_data=data;main_sink();}
static wchar_t * main_source(wchar_t * data){wcscat(data, L"file.txt");return data;}static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;data=main_source(data);{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink();static void main(){short data;data=0;data=100-1;_main_data=data;b_main_sink();}void b_main_sink(){short data=_main_data;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main_sink(short data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}static void main(){short data;void (*func_ptr) (short)=main_sink;data=0;data=100-1;func_ptr(data);}
void b_main_sink(char data);static void main(){char data;void (*func_ptr) (char)=b_main_sink;data=' ';data='a';func_ptr(data);}void b_main_sink(char data){{char char_array[4];char_array[0]='x';char_array[1]=data;char_array[2]='z';char_array[3]='\0';printLine(char_array);}}
static void main(){int * data;data=new int[10];main_sink(&data);}void main_sink(void * void_data_ptr){int * * data_ptr=(int * *)void_data_ptr;int * data=(*data_ptr);{int i;for(i=0;i<10;i++){data[i]=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}delete [] data;}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnvp(_P_WAIT, COMMAND_INT, args);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");func_ptr(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){unsigned int data;data=0;fscanf (stdin, "%u", &data);{unsigned int result=-1;if (data < UINT_MAX){result=data+1;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){twointsclass * data;void (*func_ptr) (twointsclass *)=main_sink;data=NULL;data=new twointsclass[100];func_ptr(data);}void main_sink(twointsclass * data){delete [] data;}
void b_main_sink(char * * data);static void main(){char * data;data=(char *)malloc(100*sizeof(char));b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char dest[50]="";strncat(dest, data, strlen(data));printLine(data);free(data);}}
void b_main_sink(bad_struct data);static void main(){bad_struct data;linked_list head={&head, &head};data.list.next=head.next;data.list.prev=&head;head.next=&data.list;head.next->prev=&data.list;b_main_sink(data);}void c_main_sink(bad_struct data);void b_main_sink(bad_struct data){c_main_sink(data);}void d_main_sink(bad_struct data);void c_main_sink(bad_struct data){d_main_sink(data);}void e_main_sink(bad_struct data);void d_main_sink(bad_struct data){e_main_sink(data);}void e_main_sink(bad_struct data){* */prev=data.list.prev;next=data.list.next;prev->next=next;next->prev=prev;}
static void main(){if(global_returns_t_or_f()){{wchar_t data_buf[100]=L"";wchar_t * data=data_buf;if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin)!=100-1){printLine("fread failed!");}}}else{{wchar_t data_buf[100]=L"";wchar_t * data=data_buf;if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin)!=100-1){printLine("fread failed!");}}}}
void b_main_sink(float data);static void main(){float data;data=0.0F;data=7.0F;b_main_sink(data);}void c_main_sink(float data);void b_main_sink(float data){c_main_sink(data);}void d_main_sink(float data);void c_main_sink(float data){d_main_sink(data);}void e_main_sink(float data);void d_main_sink(float data){e_main_sink(data);}void e_main_sink(float data){printDoubleLine((double)(100.0/data));}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{size_t i, dest_sz;wchar_t dest[100];wmemset(dest, L'C', 100-1);dest_sz=wcslen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);free(data);}}
void b_main_sink();static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
static void main(){int * data;data=NULL;if(global_returns_t_or_f()){data=(int *)malloc(100*sizeof(int));}else{data=(int *)malloc(100*sizeof(int));}{memcpy(data, src, 100*sizeof(int));printIntLine(data[0]);free(data);}}
static void main_sink(){int data=main_data;{size_t a,i;int *b;b=(int*)new char[a];for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);delete [] b;}}static void main(){int data;data=-1;data=20;main_data=data;main_sink();}
static void main(){char * data;data=NULL;if(global_returns_t_or_f()){{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}}else{{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}}{char dest[100];strncpy(dest, data, strlen(dest));dest[100-1]='\0';printLine(dest);}}
static void main(){char * data;void (*func_ptr) (char *, ...)=b_main_vasink;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");func_ptr(data);}void b_main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}
static long long * main_source(long long * data){data=NULL;data=(long long *)realloc(data, 100*sizeof(long long));return data;}static void main(){long long * data;data=NULL;data=main_source(data);free(data);}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, L"%s", args);va_end(args);}}static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}}{wchar_t * data=*data_ptr2;main_vasink(data, data);}}
static void main(){int * data;data=NULL;data=new int[100];main_sink(&data);}void main_sink(void * void_data_ptr){int * * data_ptr=(int * *)void_data_ptr;int * data=(*data_ptr);delete [] data;}
static void main(){wchar_t * data;wchar_t * &data_ref=data;data=NULL;data=new wchar_t[100];{wchar_t * data=data_ref;delete [] data;}}
static void main_sink(){wchar_t * data=_main_data;{wchar_t dest[100];wmemset(dest, L'C', 100-1);memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;_main_data=data;main_sink();}
void b_main_sink(int data);static void main(){int data;data=-1;data=CHAR_MAX-5;b_main_sink(data);}void b_main_sink(int data){{short s=(short)data;printf("%hd\n", s);}}
static void main(){char data;data=' ';data=5;b_main_sink(data);}void b_main_sink(char data){c_main_sink(data);}void c_main_sink(char data){d_main_sink(data);}void d_main_sink(char data){e_main_sink(data);}void e_main_sink(char data){{char result=data * data;printHexCharLine(result);}}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *, ...)=b_main_vasink;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");func_ptr(data);}void b_main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, data, args);va_end(args);}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;fscanf (stdin, "%d", &data);}{int data=*data_ptr2;{int result=-1;if (data <=(int)sqrt((int)INT_MAX)){result=data * data;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
void main_sink(twointsclass * data);static void main(){twointsclass * data;{twointsclass * data_buf=new twointsclass[100];{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}main_sink(data);}void main_sink(twointsclass * data){printIntLine(data[0].a);delete [] data;}
static void main(){char data;char data_array[5];data=' ';data=5;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char data_array[]){char data=data_array[2];{char result=data * 2;printHexCharLine(result);}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];{twointsclass * data_copy=data;twointsclass * data=data_copy;{twointsclass src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memmove(data, src, 100*sizeof(twointsclass));printIntLine(data[0].a);delete [] data;}}}
static void main(){long long * data;_union_type my_union;data=NULL;{long long data_goodbuf[100];data=data_goodbuf;data[0]=5L;printLongLongLine(data[0]);}my_union.a=data;{long long * data=my_union.b;}}
static void main(){int data;int data_array[5];data=-1;fscanf (stdin, "%d", &data);data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than the length of the source string or too large");}}}
static void main_sink(twointsclass * data){delete data;}static void main(){twointsclass * data;data=NULL;data=new twointsclass;main_sink(data);}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t dest[100];wcscpy(dest, data);printWLine(dest);}}
static void main(){void * data;twoints data_goodbuf;int data_badbuf=100;data_goodbuf.a=0;data_goodbuf.b=0;if(global_returns_t_or_f()){data=&data_goodbuf;}else{data=&data_goodbuf;}printStructLine((twoints *)data);}
static void main(){int data;data=-1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}main_data=data;main_sink();}void main_sink(){int data=main_data;{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){char * data;char data_buf[250]="PATH=";data=data_buf;strcat(data, NEW_PATH);{char * data_copy=data;char * data=data_copy;PUTENV(data);}}
static void main_sink(){char * data=_main_data;{char dest[100];strncpy(dest, data, strlen(dest));dest[100-1]='\0';printLine(dest);}}static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;_main_data=data;main_sink();}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t dest[50]=L"";_snwprintf(dest, wcslen(data), L"%s", data);printWLine(data);}}
void main_sink(struct_type my_struct);static void main(){wchar_t * data;struct_type my_struct;data=NULL;data=new wchar_t[100];my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){wchar_t * data=my_struct.a;{size_t i, dest_sz;wchar_t dest[100];wmemset(dest, L'C', 100-1);dest_sz=wcslen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);delete [] data;}}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnvp(_P_WAIT, COMMAND_INT, args);}}wchar_t * b_main_source(wchar_t * data){wcscat(data, L"*.*");return data;}
static void main(){char * data;data=NULL;if(global_returns_t_or_f()){data=new char[100];}else{data=new char[100];}{char src[100];strcpy(data, src);printLine(data);delete [] data;}}
static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';if(global_returns_t_or_f()){data=data_buf;}else{data=data_buf;}{char src[100];strncpy(data, src, 100);data[100-1]='\0';printLine(data);}}
static wchar_t * main_source(wchar_t * data){wcscpy(data, BAD_SRC_FIXED);return data;}static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));data[0]=L'\0';data=main_source(data);{size_t i;for (i=0;i < wcslen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);if (wcsncmp(PASSWORD, data, wcslen(data))==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
void b_main_sink(int data_array[]);static void main(){int data;int data_array[5];data=-1;data=ASSERT_VALUE+1;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];assert(data > ASSERT_VALUE);}
static void main(){char * data;data=NULL;data=new char[100];delete [] data;}
static void main_sink(){int count=_main_data;{size_t i=0;FILE *file=NULL;const char *filename="output_bad.txt";file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}static void main(){int count;count=-1;count=20;_main_data=count;main_sink();}
void b_main_sink(short data);static void main(){short data;data=0;data=100-1;b_main_sink(data);}void c_main_sink(short data);void b_main_sink(short data){c_main_sink(data);}void d_main_sink(short data);void c_main_sink(short data){d_main_sink(data);}void d_main_sink(short data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
void b_main_sink(char * data);static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));b_main_sink(data);}void b_main_sink(char * data){{char src[100];strncat(data, src, 100);printLine(data);free(data);}}
static void main(){long long * data;void (*func_ptr) (long long *)=main_sink;data=NULL;data=new long long[100];func_ptr(data);}void main_sink(long long * data){delete [] data;}
static void main(){{char filename[100]="";int fd=-1;fgets(filename, 100, stdin);fd=OPEN(filename, O_CREAT | O_RDWR, S_IREAD|S_IWRITE);if (fd==-1) exit(1);if (WRITE(fd, "Good Sink...", 25)==-1) exit(1);if (fd!=-1) CLOSE(fd);}}
static void main(){int data;int data_array[5];data=-1;data=10000;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){unsigned char data;data=' ';fscanf (stdin, "%hc", &data);b_main_sink(data);}void b_main_sink(unsigned char data){{unsigned char result=-1;if (data < UCHAR_MAX){result=data+1;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){twoints * data;data=NULL;data=new twoints[100];main_data=data;main_sink();}void main_sink(){twoints * data=main_data;delete [] data;}
short b_main_source(short data);static void main(){short data;data=-1;data=b_main_source(data);{char c=(char)data;printHexCharLine(c);}}short b_main_source(short data){data=CHAR_MAX-5;return data;}
static void main_source(wchar_t * &data){data=new wchar_t[100];}static void main(){wchar_t * data;data=NULL;main_source(data);{wchar_t src[100];wcscat(data, src);printWLine(data);delete [] data;}}
static void main_sink(long long * data){delete data;}static void main(){long long * data;void (*func_ptr) (long long *)=main_sink;data=NULL;data=new long long;func_ptr(data);}
static void main(){char * data;_union_type my_union;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;my_union.a=data;{char * data=my_union.b;{char dest[50]="";_snprintf(dest, strlen(data), "%s", data);printLine(data);}}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char dest[50]="";memcpy(dest, data, strlen(data)*sizeof(char));printLine(data);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){wchar_t * data;_union_type my_union;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));my_union.a=data;{wchar_t * data=my_union.b;{wchar_t src[100];wcsncpy(data, src, 100);printWLine(data);free(data);}}}
void b_main_sink(wchar_t * * password);static void main(){wchar_t * password;wchar_t password_buf[100]=L"";password=password_buf;wcscpy(password, L"Password1234!");b_main_sink(&password);}void b_main_sink(wchar_t * * password_ptr){wchar_t * password=*password_ptr;{HANDLE pHandle;wchar_t * username=L"User";wchar_t * domain=L"Domain";if (LogonUserW( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}
void b_main_sink();static void main(){int data;data=-1;data=CHAR_MAX-5;_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{char c=(char)data;printHexCharLine(c);}}
static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));main_sink(data);}void main_sink(twoints * data){free(data);}
static void main_sink(char * data){{char dest[100];memmove(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}func_ptr(data);}
static void main(){twoints * data;data=NULL;{twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine(&data[0]);}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){twoints * * data_ptr=(twoints * *)void_data_ptr;twoints * data=(*data_ptr);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(L"%s", args);va_end(args);}}void c_main_sink(wchar_t * data){main_vasink(data, data);}
static void main(){void * data;void * *data_ptr1=&data;void * *data_ptr2=&data;data=NULL;{void * data=*data_ptr1;data=WIDE_STRING;}{void * data=*data_ptr2;{size_t data_len=wcslen((wchar_t *)data);void * data_dest=(void *)calloc(data_len+1, sizeof(wchar_t));memcpy(data_dest, data, (data_len+1)*sizeof(wchar_t));printWLine((wchar_t *)data_dest);free(data_dest);}}}
void _main_sink(float data){printDoubleLine((double)(100.0/data));}static void main(){float data;data=0.0F;data=7.0F;_main_sink(data);}
void b_main_sink(char * data);static void main(){char * data;char data_buf[250]="PATH=";data=data_buf;strcat(data, NEW_PATH);b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){PUTENV(data);}
static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));data[0]=L'\0';{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}{wchar_t * data_copy=data;wchar_t * data=data_copy;{size_t i;for (i=0;i < wcslen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "C:\\Windows\\System32\\winsrv.dll");b_main_sink(data);}void b_main_sink(char * data){{HMODULE hModule;hModule=LoadLibraryA(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;{char dest[100];memcpy(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
void b_main_sink(twoints * * data);static void main(){twoints * data;data=(twoints *)malloc(100);b_main_sink(&data);}void b_main_sink(twoints * * data_ptr){twoints * data=*data_ptr;if (data!=NULL){data[0].a=1;data[0].b=1;printStructLine(&data[0]);free(data);}}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){char data;data=' ';fscanf (stdin, "%c", &data);{char result=0;if (data > CHAR_MIN){result=data-1;printHexCharLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static void main_sink(int data){if (data!=-1){CLOSE(data);}}static void main(){int data;data=-1;data=OPEN("BadSource_open.txt", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);main_sink(data);}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static wchar_t * main_source(wchar_t * data){{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, L"%s", data);printWLine(dest);}}
static void main(){unsigned int data;data=0;data=5;b_main_sink(&data);}void b_main_sink(unsigned int * data_ptr){unsigned int data=*data_ptr;{unsigned int result=data * 2;printUnsignedLine(result);}}
static void main(){int count;int count_array[5];count=-1;count=20;count_array[2]=count;b_main_sink(count_array);}void b_main_sink(int count_array[]){int count=count_array[2];{size_t i=0;FILE *file=NULL;const char *filename="output_bad.txt";file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){twoints * data;data=NULL;if(global_returns_t_or_f()){data=new twoints[100];data[0].a=0;data[0].b=0;printStructLine(&data[0]);}else{data=new twoints[100];data[0].a=0;data[0].b=0;printStructLine(&data[0]);}if(global_returns_t_or_f()){delete[] data;}else{delete[] data;}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;{int data=*data_ptr1;data=10;}{int data=*data_ptr2;{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}}
static void main_sink(int count){{size_t i=0;if (count > 0 && count <=20){for (i=0;i < (size_t)count;i++){printLine("Hello");}}}}static void main(){int count;count=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;count=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}main_sink(count);}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);_spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){unsigned char data;data=' ';if(global_returns_t_or_f()){data=5;}else{data=5;}if(global_returns_t_or_f()){{unsigned char result=data * 2;printHexUnsignedCharLine(result);}}else{{unsigned char result=data * 2;printHexUnsignedCharLine(result);}}}
void b_main_sink();static void main(){FILE * data;data=NULL;data=fopen("file.txt", "w+");_bad_data_for_good_sink=data;b_main_sink();}void b_main_sink(){FILE * data=_bad_data_for_good_sink;if (data!=NULL){fclose(data);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
void b_main_sink(int * data);static void main(){int * data;data=(int *)realloc(data, 100);b_main_sink(data);}void c_main_sink(int * data);void b_main_sink(int * data){c_main_sink(data);}void c_main_sink(int * data){if (data!=NULL){data[0]=5;printIntLine(data[0]);free(data);}}
static void main(){twointsclass * data;twointsclass * &data_ref=data;data=NULL;data=new twointsclass;{twointsclass * data=data_ref;delete data;}}
static void main(){twointsclass * data;data=NULL;data=(twointsclass *)malloc(100*sizeof(twointsclass));main_sink_b(data);}void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_c(twointsclass * data){main_sink_d(data);}void main_sink_d(twointsclass * data){main_sink_e(data);}void main_sink_e(twointsclass * data){free(data);}
static wchar_t * main_source(wchar_t * data){data=PASSWORD;return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);if (wcsncmp(PASSWORD, data, wcslen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));printWLine(data);delete [] data;}}
static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}func_ptr(data);}void b_main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main_sink(){wchar_t * data=main_data;{wchar_t src[100];wcscat(data, src);printWLine(data);delete [] data;}}static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_data=data;main_sink();}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;func_ptr(data);}void b_main_sink(char * data){{char src[100];memmove(data, src, 100*sizeof(char));printLine(data);}}
static int main_source(int data){data=20;return data;}static void main(){int data;data=-1;data=main_source(data);{size_t i;int *b;b=(int*)malloc(data * sizeof(int));for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);free(b);}}
static void main(){wchar_t * data;data=NULL;main_source(data);delete data;}void main_source(wchar_t * &data){data=new wchar_t;}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t dest[100];wmemset(dest, L'C', 100-1);memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){unsigned int data;void (*func_ptr) (unsigned int)=b_main_sink;data=0;data=5;func_ptr(data);}void b_main_sink(unsigned int data){{unsigned int result=data * data;printUnsignedLine(result);}}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t data_buf[250]=L"PATH=";data=data_buf;wcscat(data, NEW_PATH);b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;PUTENV(data);}
void b_main_sink(int * data_array[]);static void main(){int * data;int * data_array[5];data=NULL;data=(int *)malloc(100*sizeof(int));data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int * data_array[]){int * data=data_array[2];{memcpy(data, src, 100*sizeof(int));printIntLine(data[0]);free(data);}}
void main_sink(void * void_data_ptr);static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}main_sink(&data);}void main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{char src[100];memcpy(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}
static void main_vasinkg(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, L"%s", args);va_end(args);printWLine(dest);}}static void main_vasinkb(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_f()){wcscpy(data, L"fixedstringtest");}else{wcscpy(data, L"fixedstringtest");}if(global_returns_t()){main_vasinkb(data, data);}else{main_vasinkb(data, data);}}
static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, "%s", args);va_end(args);printLine(dest);}}static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}main_vasink(data, data);}
static void main(){char * data;data=NULL;data=(char *)calloc(100, sizeof(char));main_sink(data);}void main_sink(char * data){free(data);}
static void main(){int data;data=-1;data=5;_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{int result=data * data;printIntLine(result);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){fprintf(stdout, data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;b_main_sink(data);}void b_main_sink(wchar_t * data){{size_t i;wchar_t dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);}}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){int data;data=-1;data=20;{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t;main_sink(&data);}void main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);delete data;}
static void main(){float data;data=0.0F;data=7.0F;printDoubleLine((double)(100.0/data));}
static void main_sink(){long long * data=main_data;}static void main(){long long * data;data=NULL;data=new long long[100];{size_t i;for(i=0;i < 100;i++){data[i]=5L;}}delete [] data;main_data=data;main_sink();}
void main_sink_b(char * data);static void main(){char * data;data=NULL;data=new char[100];main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){{char src[100];strcpy(data, src);printLine(data);delete [] data;}}
static void main(){int data;data=-1;data=5;{int result=data * 2;printIntLine(result);}}
static void main(){char * data;char data_buf[250]="PATH=";data=data_buf;strcat(data, NEW_PATH);PUTENV(data);}
void b_main_sink(char * * data);static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{size_t i, dest_sz;char dest[100];memset(dest, 'C', 100-1);dest_sz=strlen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;{int data=*data_ptr1;data=OPEN("GoodSource_open.txt", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);}{int data=*data_ptr2;CLOSE(data);}}
static void main(){int * data;data=(int *)ALLOCA(10*sizeof(int));{int i;for(i=0;i<10;i++){data[i]=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];data=NULL;data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t data_src[10+1]=SRC_STRING;wcsncpy(data, data_src, wcslen(data_src));printWLine(data);free(data);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}{int i, n, v;if (swscanf(data, L"%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static void main_sink(){char * data=main_data;{size_t i, dest_sz;char dest[100];memset(dest, 'C', 100-1);dest_sz=strlen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);delete [] data;}}static void main(){char * data;data=NULL;data=new char[100];main_data=data;main_sink();}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;wcscat(data, L"*.*");}{wchar_t * data=*data_ptr2;EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}}
static void main_sink(char * data){if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;main_sink(data);}
static void main(){int data;data=OPEN("BadSource_open.txt", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);CLOSE(data);b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){}
static void main_sink(int data){{char data_buf[10]="AAAAAAAAA";{printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}static void main(){int data;data=10;main_sink(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}
static void main(){wchar_t * data;data=NULL;main_source(data);delete data;}void main_source(wchar_t * &data){data=new wchar_t;}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];{twointsclass * data_copy=data;twointsclass * data=data_copy;delete [] data;}}
static void main(){twoints * data;data=NULL;main_source(data);delete [] data;}void main_source(twoints * &data){data=new twoints[100];}
static void main(){long long * data;data=NULL;data=new long long[100];delete [] data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main_source(char * &data){data=new char[100];}static void main(){char * data;data=NULL;main_source(data);delete [] data;}
void main_sink_b(char * data);static void main(){char * data;data=NULL;data=new char[100];main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_d(char * data);void main_sink_c(char * data){main_sink_d(data);}void main_sink_d(char * data){{char src[100];strncpy(data, src, 100);printLine(data);delete [] data;}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t dest[100];wmemset(dest, L'C', 100-1);memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){unsigned char data;data=' ';data=0;b_main_sink(data);}void b_main_sink(unsigned char data){c_main_sink(data);}void c_main_sink(unsigned char data){{unsigned char result=0;if (data > 0){result=data-1;printHexUnsignedCharLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
void main_sink(char * data);static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}main_sink(data);}void main_sink(char * data){{size_t i;char dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}void c_main_sink(char * data){main_vasink(data, data);}
void main_sink_b(int * data);static void main(){int * data;data=NULL;data=new int[100];main_sink_b(data);}void main_sink_c(int * data);void main_sink_b(int * data){main_sink_c(data);}void main_sink_c(int * data){{memmove(data, src, 100*sizeof(int));printIntLine(data[0]);delete [] data;}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);{char dest[100]="";SNPRINTF(dest, 100-1, data);printLine(dest);}}char * b_main_source(char * data){strcpy(data, "fixedstringtest");return data;}
static void main(){long long * data;data=NULL;data=new long long[100];{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printLongLongLine(data[0]);delete [] data;}}}
static void main(){twoints * data;data=NULL;data=new twoints[100];main_sink_b(data);}void main_sink_b(twoints * data){main_sink_c(data);}void main_sink_c(twoints * data){delete [] data;}
static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t dest[100];memmove(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;wcscat(data, L"*.*");}{wchar_t * data=*data_ptr2;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}}
static char * main_source(char * data){data=(char *)calloc(100, sizeof(char));strcpy(data, "A String");printLine(data);return data;}static void main(){char * data;data=NULL;data=main_source(data);free(data);}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100];data=data_buf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{wchar_t dest[50]=L"";memcpy(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);}}
void b_main_sink(_struct_type my_struct);static void main(){int data;_struct_type my_struct;data=-1;data=7;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;printIntLine(100/data);}
void _main_sink(int data){printIntLine(100 % data);}static void main(){int data;data=-1;data=7;_main_sink(data);}
static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, data);printWLine(dest);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
void b_main_sink(_struct_type my_struct);static void main(){int data;_struct_type my_struct;data=-1;data=CHAR_MAX-5;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{short s=(short)data;printf("%hd\n", s);}}
static void main(){{try{string a="hello";string b=a.substr(rand(), rand());printLine(b.c_str());}catch (out_of_range &){printLine("Range specified was invalid");}}}
static void main(){int data;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}{int data_copy=data;int data=data_copy;{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0 && data < 10){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_t_or_f()){data=PASSWORD;}else{data=PASSWORD;}if(global_returns_t_or_f()){if (wcsncmp(PASSWORD, data, wcslen(data))==0) printLine("Access granted");else printLine("Access denied!");}else{if (wcsncmp(PASSWORD, data, wcslen(data))==0) printLine("Access granted");else printLine("Access denied!");}}
void b_main_sink(int data);static void main(){int data;data=-1;data=100-1;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void d_main_sink(int data);void c_main_sink(int data){d_main_sink(data);}void e_main_sink(int data);void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main_sink(){int data=_main_data;{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than the length of the source string or too large");}}}static void main(){int data;data=-1;data=RAND32();_main_data=data;main_sink();}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;{int data=*data_ptr1;data=RAND32();}{int data=*data_ptr2;{char data_buf[10]="AAAAAAAAA";{printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");b_main_sink(data);}void b_main_sink(char * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){long long * data;long long * data_array[5];data=NULL;data=new long long;data_array[2]=data;main_sink(data_array);}void main_sink(long long * data_array[]){long long * data=data_array[2];printLongLongLine(*data);}
static void main(){int count;count=-1;count=20;b_main_sink(count);}void b_main_sink(int count){c_main_sink(count);}void c_main_sink(int count){{size_t i=0;for (i=0;i < (size_t)count;i++){printLine("Hello");}}}
static void main(){char * data;data=NULL;data=new char[100];memset(data, 'A', 100-1);data[100-1]='\0';printLine(data);}
static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));b_main_sink(data);}void b_main_sink(char * data){free(data);}
static void main_sink(){wchar_t * data=_main_data;EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_data=data;main_sink();}
void main_sink_b(char * data);static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){{char dest[100];strcpy(dest, data);printLine(dest);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){e_main_sink(data);}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, "%s", args);va_end(args);}}void e_main_sink(char * data){main_vasink(data, data);}
void _main_sink(char * data){{char dest[100];strcpy(dest, data);printLine(dest);}}static void main(){char * data;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}_main_sink(data);}
static void main(){char * data;char * data_array[5];data=NULL;data=(char *)malloc(100*sizeof(char));free(data);data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}{wchar_t * data_copy=data;wchar_t * data=data_copy;if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}}
static void main_sink(int data){{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0 && data < 10){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=10;func_ptr(data);}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];_wsystem(data);}
static void main(){unsigned int data;data=0;if(global_returns_t_or_f()){fscanf (stdin, "%u", &data);}else{fscanf (stdin, "%u", &data);}if(global_returns_t_or_f()){{unsigned int result=-1;if (data <=(unsigned int)sqrt((unsigned int)UINT_MAX)){result=data * data;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}else{{unsigned int result=-1;if (data <=(unsigned int)sqrt((unsigned int)UINT_MAX)){result=data * data;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
static void main_source(wchar_t * &data){data=NULL;data=(wchar_t *)realloc(data, 100*sizeof(wchar_t));}static void main(){wchar_t * data;data=NULL;main_source(data);free(data);}
static void main(){int data;data=-1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
void b_main_sink(_struct_type my_struct);static void main(){long long * data;_struct_type my_struct;data=NULL;{long long tmp=5L;data=&tmp;}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){long long * data=my_struct.a;printLongLongLine(*data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, data);printWLine(dest);}}
static void main(){int * data;data=NULL;data=new int[100];{size_t i;for(i=0;i < 100;i++){data[i]=5;}}delete [] data;}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]="";data=data_buf;{char * data=*data_ptr1;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}}{char * data=*data_ptr2;if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}}
static void main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");func_ptr(data);}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, GOOD_OS_COMMAND);b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){system(data);}
static void main(){char * data;data=NULL;data=main_source(data);delete [] data;}char * main_source(char * data){data=new char[100];return data;}
static void main(){int data;data=7;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){wchar_t data;data=L'W';printf("%02lx\n", data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(data, args);va_end(args);}}void d_main_sink(wchar_t * data){main_vasink(data, data);}
static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;{wchar_t dest[100];wcscpy(dest, data);printWLine(dest);}}
static void main(){int data;data=-1;data=100-1;{int data_copy=data;int data=data_copy;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}}
static void main(){twoints * data;struct_type my_struct;data=NULL;data=NULL;data=(twoints *)realloc(data, 100*sizeof(twoints));my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){twoints * data=my_struct.a;free(data);}
static void main_source(int &data){data=20;}static void main(){int data;data=-1;main_source(data);{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}
static void main(){twoints * data;data=NULL;data=(twoints *)calloc(100, sizeof(twoints));data[0].a=0;data[0].b=0;printStructLine(&data[0]);b_main_sink(data);}void b_main_sink(twoints * data){c_main_sink(data);}void c_main_sink(twoints * data){d_main_sink(data);}void d_main_sink(twoints * data){e_main_sink(data);}void e_main_sink(twoints * data){free(data);}
static void main(){twointsclass * data;twointsclass * &data_ref=data;twointsclass data_uninit_array[10];data=data_uninit_array;for(int i=0;i<(10/2);i++){data[i].a=i;data[i].b=i;}{twointsclass * data=data_ref;for(int i=0;i<10;i++){data[i].a=i;data[i].b=i;}for(int i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}}
static void main(){{char dst[DST_SZ];memcpy(dst, COPY_STR, (DST_SZ-1)*sizeof(char));dst[DST_SZ-1]='\0';printLine(dst);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){fprintf(stdout, "%s\n", data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;if(global_returns_t_or_f()){strcat(data, "*.*");}else{strcat(data, "*.*");}_spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main_sink(wchar_t * data){free(data);}static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));main_sink(data);}
void b_main_sink(int data);static void main(){int data;data=-1;data=20;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void d_main_sink(int data);void c_main_sink(int data){d_main_sink(data);}void e_main_sink(int data);void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{size_t i;int *b;b=(int*)malloc(data * sizeof(int));for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);free(b);}}
static void main(){unsigned int data;unsigned int data_array[5];data=0;data=5;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(unsigned int data_array[]){unsigned int data=data_array[2];{unsigned int result=data * data;printUnsignedLine(result);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=20;func_ptr(data);}void main_sink(int data){{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, L"%s", args);va_end(args);}}static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}my_union.a=data;{wchar_t * data=my_union.b;main_vasink(data, data);}}
static void main_sink(wchar_t * data){if (wcsncmp(PASSWORD, data, wcslen(data))==0) printLine("Access granted");else printLine("Access denied!");}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;func_ptr(data);}
void main_sink_b(wchar_t * data);static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}main_sink_b(data);}void main_sink_c(wchar_t * data);void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_d(wchar_t * data);void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_e(wchar_t * data);void main_sink_d(wchar_t * data){main_sink_e(data);}void main_sink_e(wchar_t * data){{size_t i;wchar_t dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);}}
static void main(){int data;int data_array[5];data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}data_array[2]=data;main_sink(data_array);}void main_sink(int data_array[]){int data=data_array[2];{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){void * data;data=NULL;data=CHAR_STRING;b_main_sink(data);}void b_main_sink(void * data){c_main_sink(data);}void c_main_sink(void * data){d_main_sink(data);}void d_main_sink(void * data){e_main_sink(data);}void e_main_sink(void * data){{size_t data_len=strlen((char *)data);void * data_dest=(void *)calloc(data_len+1, 1);memcpy(data_dest, data, (data_len+1));printLine((char *)data_dest);free(data_dest);}}
static void main(){{wchar_t * data=SRC_STR;wchar_t dst[100]=L"";wchar_t * end=wcschr(data, L'/');ptrdiff_t i;for (i=0;i < (end-data);i++){dst[i]=data[i];}printWLine(dst);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);wprintf(data);}
void b_main_sink(short data);static void main(){short data;data=0;data=100-1;b_main_sink(data);}void c_main_sink(short data);void b_main_sink(short data){c_main_sink(data);}void d_main_sink(short data);void c_main_sink(short data){d_main_sink(data);}void d_main_sink(short data){{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));data=b_main_source(data);{wchar_t dest[50]=L"";_snwprintf(dest, wcslen(data), L"%s", data);printWLine(data);free(data);}}wchar_t * b_main_source(wchar_t * data){return data;}
static void main(){unsigned int data;unsigned int *data_ptr1=&data;unsigned int *data_ptr2=&data;data=0;{unsigned int data=*data_ptr1;data=5;}{unsigned int data=*data_ptr2;{unsigned int result=data * data;printUnsignedLine(result);}}}
void b_main_sink(float * data);static void main(){float data;data=0.0F;data=7.0F;b_main_sink(&data);}void b_main_sink(float * data_ptr){float data=*data_ptr;printDoubleLine((double)(100.0/data));}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnvp(_P_WAIT, COMMAND_INT, args);}}
static void main(){long long * data;data=NULL;if(global_returns_t_or_f()){data=new long long;}else{data=new long long;}if(global_returns_t_or_f()){delete data;}else{delete data;}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "15");b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{int i, n, v;if (sscanf(data, "%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main(){float data;_union_type my_union;data=0.0F;data=7.0F;my_union.a=data;{float data=my_union.b;printDoubleLine((double)(100.0/data));}}
static void main(){int data;_union_type my_union;data=-1;data=7;my_union.a=data;{int data=my_union.b;printIntLine(100/data);}}
static void main(){int data;data=-1;data=20;main_sink_b(data);}void main_sink_b(int data){main_sink_c(data);}void main_sink_c(int data){{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);if (wcsstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_t_or_f()){wcscat(data, L"*.*");}else{wcscat(data, L"*.*");}EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){int data;_struct_type my_struct;data=-1;data=RAND32();my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
void main_sink(int * data){printIntLine(data[0]);delete [] data;}static void main(){int * data;{int * data_buf=new int[100];{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}main_sink(data);}
static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=-1;data=5;func_ptr(data);}void b_main_sink(int data){{int result=data-1;printIntLine(result);}}
static void main(){char * data;_struct_type my_struct;data=NULL;data=(char *)malloc(100*sizeof(char));memset(data, 'A', 100-1);data[100-1]='\0';free(data);my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;}
static void main(){FILE * data;data=freopen("BadSource_freopen.txt","w+",stdin);fclose(data);b_main_sink(data);}void b_main_sink(FILE * data){c_main_sink(data);}void c_main_sink(FILE * data){d_main_sink(data);}void d_main_sink(FILE * data){}
static void main(){unsigned char data;data=' ';if(global_returns_t_or_f()){data=(unsigned char)rand();}else{data=(unsigned char)rand();}if(global_returns_t_or_f()){{unsigned char result=-1;if (data <=(unsigned char)sqrt((unsigned char)UCHAR_MAX)){result=data * data;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}else{{unsigned char result=-1;if (data <=(unsigned char)sqrt((unsigned char)UCHAR_MAX)){result=data * data;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
static void main(){char * data;data=NULL;{char data_goodbuf[100];data=data_goodbuf;strcpy(data, "A String");printLine(data);}}
static void main(){twoints * data;struct_type my_struct;data=NULL;data=new twoints[100];my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){twoints * data=my_struct.a;delete [] data;}
static wchar_t * main_source(wchar_t * data){wcscpy(data, L"fixedstringtest");return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);fwprintf(stdout, data);}
static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");{FILE *pipe;pipe=POPEN(data, "wb");if (pipe!=NULL) PCLOSE(pipe);}}
void b_main_sink(FILE * data);static void main(){FILE * data;data=NULL;data=fopen("BadSource_fopen.txt", "w+");b_main_sink(data);}void b_main_sink(FILE * data){if (data!=NULL){fclose(data);}}
static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;{wchar_t dest[100];wcsncpy(dest, data, wcslen(dest));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){unsigned int data;unsigned int *data_ptr1=&data;unsigned int *data_ptr2=&data;data=0;{unsigned int data=*data_ptr1;data=5;}{unsigned int data=*data_ptr2;{unsigned int result=data-1;printUnsignedLine(result);}}}
static void main(){{errno_t err_code=-1;long l=strtol("0xfffffffff", NULL, 0);if (_get_errno(&err_code)){printLine("_get_errno failed");exit(1);}if (err_code==ERANGE){printLine("strtol() failed");exit(1);}printf("%li\n", l);}}
static void main(){int count;count=-1;count=20;{int count_copy=count;int count=count_copy;{size_t i=0;for (i=0;i < (size_t)count;i++){printLine("Hello");}}}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t;main_data=data;main_sink();}void main_sink(){wchar_t * data=main_data;delete data;}
static void main_sink(FILE * data){if (data!=NULL){fclose(data);}}static void main(){FILE * data;data=NULL;data=freopen("BadSource_freopen.txt","w+",stdin);main_sink(data);}
static void main_sink(long long * data){{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printLongLongLine(data[0]);free(data);}}}static void main(){long long * data;void (*func_ptr) (long long *)=main_sink;data=NULL;data=(long long *)malloc(100*sizeof(long long));func_ptr(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t data_src[10+1]=SRC_STRING;memmove(data, data_src, wcslen(data_src)*sizeof(wchar_t));printWLine(data);free(data);}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;strcat(data, "*.*");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}my_union.a=data;{wchar_t * data=my_union.b;fwprintf(stdout, L"%s\n", data);}}
static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));memset(data, 'A', 100-1);data[100-1]='\0';free(data);{char * data_copy=data;char * data=data_copy;}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}{wchar_t * data_copy=data;wchar_t * data=data_copy;{int i, n, v;if (swscanf(data, L"%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}}
static int main_source(int data){data=100-1;return data;}static void main(){int data;data=-1;data=main_source(data);{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
static void main_sink(){wchar_t * data=main_data;{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}main_data=data;main_sink();}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];data=NULL;data=(char *)malloc(100*sizeof(char));data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{char src[100];strncpy(data, src, 100);printLine(data);free(data);}}
void b_main_sink(void * void_data_ptr);static void main(){short data;data=0;data=100-1;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){short * data_ptr=(short *)void_data_ptr;short data=(*data_ptr);{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main_source(char * &data){data=new char;}static void main(){char * data;data=NULL;main_source(data);printf("%c\n", *data);}
static void main(){int data;data=-1;data=main_source(data);{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}int main_source(int data){data=20;return data;}
static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;{char * data_copy=data;char * data=data_copy;{char src[100];strcpy(data, src);printLine(data);}}}
void b_main_sink(int data);static void main(){int data;data=-1;data=20;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void d_main_sink(int data);void c_main_sink(int data){d_main_sink(data);}void e_main_sink(int data);void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{size_t i;int *b;b=(int*)malloc(data * sizeof(int));for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);free(b);}}
void _main_sink(wchar_t * data){PUTENV(data);}static void main(){wchar_t * data;wchar_t data_buf[250]=L"PATH=";data=data_buf;wcscat(data, NEW_PATH);_main_sink(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;if (strstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
static void main_sink(wchar_t * data){{wchar_t dest[50]=L"";wcscpy(dest, data);printWLine(data);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100];data=data_buf;func_ptr(data);}
static void main(){unsigned char data;data=' ';fscanf (stdin, "%hc", &data);_main_data=data;b_main_sink();}void b_main_sink(){unsigned char data=_main_data;{unsigned char result=-1;if (data <=(unsigned char)sqrt((unsigned char)UCHAR_MAX)){result=data * data;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
void main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}func_ptr(data);}void main_sink(wchar_t * data){{wchar_t dest[100];wcscpy(dest, data);printWLine(dest);}}
static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];if(global_returns_t_or_f()){data=data_goodbuf;}else{data=data_goodbuf;}{char src[100];strncat(data, src, 100);printLine(data);}}
void b_main_sink(int * data);static void main(){int * data;data=NULL;data=(int *)malloc(100*sizeof(int));b_main_sink(data);}void c_main_sink(int * data);void b_main_sink(int * data){c_main_sink(data);}void c_main_sink(int * data){{memmove(data, src, 100*sizeof(int));printIntLine(data[0]);free(data);}}
static void main(){wchar_t * password;wchar_t password_buf[100]=L"";password=password_buf;{size_t password_len=0;fgetws(password, 100, stdin);password_len=wcslen(password);if (password_len > 0){password[password_len-1]=L'\0';}}{HANDLE pHandle;wchar_t * username=L"User";wchar_t * domain=L"Domain";if (LogonUserW( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}
static void main(){twoints * data;data=NULL;data=new twoints;delete data;}
static void main(){int data;data=7;{wchar_t data_buf[10]=L"AAAAAAAAA";if (data >=0){printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main(){twoints * data;struct_type my_struct;data=NULL;data=new twoints;my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){twoints * data=my_struct.a;delete data;}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;data=NULL;data=(char *)malloc(100*sizeof(char));func_ptr(data);}void b_main_sink(char * data){{char dest[100];memset(dest, 'C', 100-1);memmove(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);free(data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;if (strstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
static void main(){int * data;data=NULL;data=new int[100];delete [] data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[250]=L"PATH=";data=data_buf;wcscat(data, NEW_PATH);b_main_sink(data);}void b_main_sink(wchar_t * data){PUTENV(data);}
static int main_source(int data){data=20;return data;}static void main(){int data;data=-1;data=main_source(data);{size_t i;int *b;b=(int*)malloc(data * sizeof(int));for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);free(b);}}
static void main(){{if (fprintf(stdout, "%s\n", "string") < 0){printLine("fprintf failed!");}}}
void b_main_sink(twoints * * data);static void main(){twoints * data;twoints data_badbuf[50];twoints data_goodbuf[100];data=data_goodbuf;b_main_sink(&data);}void b_main_sink(twoints * * data_ptr){twoints * data=*data_ptr;{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memcpy(data, src, 100*sizeof(twoints));printStructLine(&data[0]);}}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){twoints * data;data=NULL;data=new twoints[100];data[0].a=0;data[0].b=0;printStructLine(&data[0]);delete[] data;}
static void main_sink(int * data){if (data!=NULL){data[0]=5;printIntLine(data[0]);free(data);}}static void main(){int * data;void (*func_ptr) (int *)=main_sink;data=(int *)malloc(100);func_ptr(data);}
static void main(){int * data;data=(int *)ALLOCA(10*sizeof(int));{int i;for(i=0;i<10;i++){data[i]=i;}}b_main_sink(&data);}void b_main_sink(int * * data_ptr){int * data=*data_ptr;{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}}
static void main_sink(char * data){}static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));memset(data, 'A', 100-1);data[100-1]='\0';free(data);main_sink(data);}
static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;strcat(data, "*.*");my_union.a=data;{char * data=my_union.b;EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}}
static void main_sink(){wchar_t * data=_main_data;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_data=data;main_sink();}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}main_sink(data);}void main_sink(int data){{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){char * data;char * data_array[5];char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{int i, n, v;if (sscanf(data, "%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static void main_sink(twoints * data){printStructLine(&data[0]);}static void main(){twoints * data;data=NULL;data=new twoints[100];{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}main_sink(data);}
static void main(){unsigned char data;data=' ';data=(unsigned char)rand();_main_data=data;b_main_sink();}void b_main_sink(){unsigned char data=_main_data;{unsigned char result=-1;if (data < UCHAR_MAX){result=data+1;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
void _main_sink(char * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");_main_sink(data);}
static void main(){int data;data=-1;data=RAND32();b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{int result=-1;if (data <=(int)sqrt((int)INT_MAX)){result=data * data;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;{wchar_t dest[50]=L"";memcpy(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);}}
static void main(){wchar_t * data;data=NULL;if(global_returns_t_or_f()){{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}}else{{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}}{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}
static void main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}main_sink(data);}
static void main(){twoints * data;union_type my_union;data=NULL;data=new twoints;my_union.a=data;{twoints * data=my_union.b;delete data;}}
static void main(){wchar_t * data;data=NULL;if(global_returns_t_or_f()){data=new wchar_t[100];}else{data=new wchar_t[100];}{wchar_t src[100];wcscpy(data, src);printWLine(data);delete [] data;}}
void b_main_sink(void * void_data_ptr);static void main(){char * data;{char * data_buf=(char *)malloc(100*sizeof(char));data=data_buf;}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);printLine(data);free(data);}
static void main(){short data;short *data_ptr1=&data;short *data_ptr2=&data;data=0;{short data=*data_ptr1;data=100-1;}{short data=*data_ptr2;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}}
static void main(){if(global_returns_t_or_f()){{char filename[MAX_PATH]="";int fd;if (GetTempFileNameA(".", NULL, 0, filename)==0){exit(1);}printLine(filename);fd=OPEN(filename, O_CREAT|O_EXCL, S_IREAD|S_IWRITE);if (fd!=-1){printLine("Temporary file opened successfully");CLOSE(fd);}}}else{{char filename[MAX_PATH]="";int fd;if (GetTempFileNameA(".", NULL, 0, filename)==0){exit(1);}printLine(filename);fd=OPEN(filename, O_CREAT|O_EXCL, S_IREAD|S_IWRITE);if (fd!=-1){printLine("Temporary file opened successfully");CLOSE(fd);}}}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;{int data=*data_ptr1;data=OPEN("BadSource_open.txt", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);CLOSE(data);}{int data=*data_ptr2;}}
static void main(){twointsclass * data;data=(twointsclass *)ALLOCA(10*sizeof(twointsclass));for(int i=0;i<10;i++){data[i].a=i;data[i].b=i;}for(int i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}
static void main(){long long * data;data=NULL;if(global_returns_t_or_f()){data=(long long *)calloc(100, sizeof(long long));}else{data=(long long *)calloc(100, sizeof(long long));}if(global_returns_t_or_f()){free(data);}else{free(data);}}
static void main(){unsigned int data;void (*func_ptr) (unsigned int)=b_main_sink;data=0;fscanf (stdin, "%u", &data);func_ptr(data);}void b_main_sink(unsigned int data){{unsigned int result=-1;if (data <=(UINT_MAX/2)){result=data * 2;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static wchar_t * main_source(wchar_t * data){wcscat(data, L"*.*");return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);_wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
static void main(){char * password;password="";password=(char *)malloc(100*sizeof(char));if(!VirtualLock(password, 100*sizeof(char))){printLine("Memory could not be locked");exit(1);}strcpy(password, "Password1234!");{char * password_copy=password;char * password=password_copy;{HANDLE pHandle;char * username="User";char * domain="Domain";if (LogonUserA( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}}
void b_main_sink();static void main(){short data;data=0;data=100-1;_main_data=data;b_main_sink();}void b_main_sink(){short data=_main_data;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
static void main(){twointsclass * data;data=(twointsclass *)malloc(10*sizeof(twointsclass));for(int i=0;i<10;i++){data[i].a=i;data[i].b=i;}for(int i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}
static void main(){int data;data=-1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){{int result=-1;if (data <=(int)sqrt((int)INT_MAX)){result=data * data;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){if(global_returns_t_or_f()){{if (fputs("string", stdout)==EOF){printLine("fputs failed!");exit(1);}}}else{{if (fputs("string", stdout)==EOF){printLine("fputs failed!");exit(1);}}}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];main_sink_b(data);}void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_c(twointsclass * data){main_sink_d(data);}void main_sink_d(twointsclass * data){delete [] data;}
static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;if(global_returns_t_or_f()){}else{}{char dest[50]="";memcpy(dest, data, strlen(data)*sizeof(char));printLine(data);}}
static void main(){char * data;_union_type my_union;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");my_union.a=data;{char * data=my_union.b;system(data);}}
void b_main_sink();static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{char dest[50]="";memmove(dest, data, strlen(data)*sizeof(char));printLine(data);}}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;func_ptr(data);}void b_main_sink(wchar_t * data){if (wcsstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
static void main_sink(int data){{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=7;func_ptr(data);}
static void main_sink(){long long * data=_main_data;free(data);}static void main(){long long * data;data=NULL;data=(long long *)calloc(100, sizeof(long long));data[0]=5L;printLongLongLine(data[0]);_main_data=data;main_sink();}
static void main(){char * data;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}{char * data_copy=data;char * data=data_copy;{char src[100];strcpy(data, src);printLine(data);}}}
static void main(){char data;_union_type my_union;data=' ';data=5;my_union.a=data;{char data=my_union.b;{char result=data-1;printHexCharLine(result);}}}
static wchar_t * main_source(wchar_t * data){{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}return data;}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(L"%s", args);va_end(args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);main_vasink(data, data);}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");b_main_sink(data);}void b_main_sink(char * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
void b_main_sink();static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{char src[100];strncpy(data, src, 100);printLine(data);free(data);}}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
void b_main_sink(short data);static void main(){short data;data=0;data=100-1;b_main_sink(data);}void c_main_sink(short data);void b_main_sink(short data){c_main_sink(data);}void d_main_sink(short data);void c_main_sink(short data){d_main_sink(data);}void d_main_sink(short data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(L"%s", args);va_end(args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);main_vasink(data, data);}wchar_t * b_main_source(wchar_t * data){{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}return data;}
void main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];{wchar_t * data_buf=new wchar_t[100];data=data_buf;}data_array[2]=data;main_sink(data_array);}void main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];printWLine(data);delete [] data;}
void _main_sink(wchar_t * data){{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}printWLine(data);free(data);}}static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));_main_sink(data);}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");func_ptr(data);}void b_main_sink(char * data){system(data);}
char * b_main_source(char * data);static void main(){char * data;data=NULL;data=b_main_source(data);{char src[100];strncpy(data, src, 100);printLine(data);free(data);}}char * b_main_source(char * data){data=(char *)malloc(100*sizeof(char));return data;}
static void main(){int data;data=-1;data=b_main_source(data);{int result=data * data;printIntLine(result);}}int b_main_source(int data){data=5;return data;}
static void main(){int * data;union_type my_union;data=NULL;data=new int[100];{size_t i;for(i=0;i < 100;i++){data[i]=5;}}my_union.a=data;{int * data=my_union.b;printIntLine(data[0]);}}
static int main_source(int data){data=CHAR_MAX-5;return data;}static void main(){int data;data=-1;data=main_source(data);{char c=(char)data;printHexCharLine(c);}}
static void main(){int data;data=-1;data=100-1;{int data_copy=data;int data=data_copy;{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{wchar_t src[100];_snwprintf(data, 100, L"%s", src);printWLine(data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(data);}static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, "%s", args);va_end(args);printLine(dest);}}void b_main_sink(char * data){main_vasink(data, data);}
static void main(){{WSADATA wsadata;BOOL wsa_init=FALSE;SOCKET listener=INVALID_SOCKET;SOCKET client=INVALID_SOCKET;struct sockaddr_in s_in;char hostname[HOSTNAME_SZ+1];char password[PASSWORD_SZ+1];do{if (0!=WSAStartup(MAKEWORD(2, 2), &wsadata)) break;wsa_init=TRUE;listener=socket(PF_INET, SOCK_STREAM, 0);if (listener==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(LISTEN_PORT);if (SOCKET_ERROR==bind(listener, (struct sockaddr*)&s_in, sizeof(s_in))) break;if (SOCKET_ERROR==listen(listener, LISTEN_BACKLOG)) break;client=accept(listener, NULL, NULL);if (client==INVALID_SOCKET) break;* */*/if (sizeof(password)-sizeof(char)!=recv(client, password, sizeof(password)-sizeof(char), 0)) break;if (memcmp(password, PASSWORD, sizeof(password)-sizeof(char))!=0){printLine("Access denied");break;}if (sizeof(hostname)-sizeof(char)!=recv(client, hostname, sizeof(hostname)-sizeof(char), 0)) break;hostname[HOSTNAME_SZ]='\0';SetComputerNameA(hostname);}while (0);if (client!=INVALID_SOCKET) CLOSESOCKET(client);if (listener!=INVALID_SOCKET) CLOSESOCKET(listener);if (wsa_init) WSACleanup();}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_t_or_f()){wcscpy(data, L"fixedstringtest");}else{wcscpy(data, L"fixedstringtest");}if(global_returns_t_or_f()){wprintf(data);}else{wprintf(data);}}
static void main_sink(){char * data=_main_data;EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_main_data=data;main_sink();}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;main_sink_b(data);}void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_c(twointsclass * data){main_sink_d(data);}void main_sink_d(twointsclass * data){main_sink_e(data);}void main_sink_e(twointsclass * data){delete data;}
static void main(){int * data;data=NULL;data=new int;delete data;}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));{wchar_t data_src[10+1]=SRC_STRING;wcscpy(data, data_src);printWLine(data);free(data);}}
static void main_source(int * &data){data=new int;}static void main(){int * data;data=NULL;main_source(data);delete data;}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{wchar_t dest[50]=L"";memmove(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);}}
static char * main_source(char * data){{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}return data;}static void main(){char * data;data=(char *)malloc(100*sizeof(char));data[0]='\0';data=main_source(data);{size_t i;for (i=0;i < strlen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}
static void main_sink(){wchar_t * data=_main_data;fwprintf(stdout, data);}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");_main_data=data;main_sink();}
static void main(){wchar_t * data;union_type my_union;data=NULL;data=(wchar_t *)calloc(100, sizeof(wchar_t));my_union.a=data;{wchar_t * data=my_union.b;free(data);}}
static void main(){int data;fscanf (stdin, "%d", &data);b_main_sink(data);}void b_main_sink(int data){{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0 && data < 10){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
void main_sink_b(int * data);static void main(){int * data;{int * data_buf=new int[100];{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}main_sink_b(data);}void main_sink_c(int * data);void main_sink_b(int * data){main_sink_c(data);}void main_sink_c(int * data){printIntLine(data[0]);delete [] data;}
static void main_sink(wchar_t * password){{HANDLE pHandle;wchar_t * username=L"User";wchar_t * domain=L"Domain";if (LogonUserW( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}static void main(){wchar_t * password;void (*func_ptr) (wchar_t *)=main_sink;password=L"";password=(wchar_t *)malloc(100*sizeof(wchar_t));if(!VirtualLock(password, 100*sizeof(wchar_t))){printLine("Memory could not be locked");exit(1);}wcscpy(password, L"Password1234!");func_ptr(password);}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(char * data){if (strncmp(PASSWORD, data, strlen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(&data);}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;main_vasink(data, data);}
static void main(){wchar_t * data;data=NULL;if(global_returns_t_or_f()){data=new wchar_t;}else{data=new wchar_t;}if(global_returns_t_or_f()){delete data;}else{delete data;}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t dest[100];wcsncpy(dest, data, wcslen(dest));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){wchar_t * data;wchar_t * data_array[5];data=NULL;{wchar_t data_goodbuf[100];data=data_goodbuf;wcscpy(data, L"a string");printWLine(data);}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;my_union.a=data;{wchar_t * data=my_union.b;if (wcsncmp(PASSWORD, data, wcslen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}}
static void main(){int * data;int * &data_ref=data;data=NULL;data=new int;{int * data=data_ref;delete data;}}
void main_sink();static void main(){wchar_t * data;{wchar_t * data_buf=new wchar_t[100];data=data_buf;}_main_data=data;main_sink();}void main_sink(){wchar_t * data=_main_data;printWLine(data);delete [] data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");func_ptr(data);}void b_main_sink(wchar_t * data){_wsystem(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}_main_data=data;b_main_sink();}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(L"%s", args);va_end(args);}}void b_main_sink(){wchar_t * data=_main_data;main_vasink(data, data);}
char * b_main_source(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;data=b_main_source(data);{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}char * b_main_source(char * data){strcat(data, "file.txt");return data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(L"%s", args);va_end(args);}}void c_main_sink(wchar_t * data){main_vasink(data, data);}
static void main(){wchar_t * data;_struct_type my_struct;data=NULL;{wchar_t data_goodbuf[100];data=data_goodbuf;wcscpy(data, L"a string");printWLine(data);}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;}
static void main(){long long * data;data=NULL;data=NULL;data=(long long *)realloc(data, 100*sizeof(long long));data[0]=5L;printLongLongLine(data[0]);b_main_sink(data);}void b_main_sink(long long * data){c_main_sink(data);}void c_main_sink(long long * data){d_main_sink(data);}void d_main_sink(long long * data){free(data);}
char * main_source(char * data);static void main(){char * data;data=NULL;data=main_source(data);{char dest[100];strncpy(dest, data, strlen(dest));dest[100-1]='\0';printLine(dest);}}char * main_source(char * data){{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}return data;}
static void main_sink(){char * data=_main_data;{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");_main_data=data;main_sink();}
static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
void _main_sink(char * data){{char dest[50]="";strcpy(dest, data);printLine(data);}}static void main(){char * data;char data_buf[100];data=data_buf;_main_sink(data);}
static void main(){wchar_t * data;data=NULL;data=new wchar_t;delete data;}
static void main(){int count;_union_type my_union;count=-1;count=20;my_union.a=count;{int count=my_union.b;{size_t i=0;FILE *file=NULL;const char *filename="output_bad.txt";file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}}
void main_sink(twointsclass * data);static void main(){twointsclass * data;{twointsclass * data_buf=new twointsclass[100];{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}main_sink(data);}void main_sink(twointsclass * data){printIntLine(data[0].a);delete [] data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");_main_data=data;b_main_sink();}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(data, args);va_end(args);}}void b_main_sink(){wchar_t * data=_main_data;main_vasink(data, data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");{char dest[100]="";SNPRINTF(dest, 100-1, data);printLine(dest);}}
static void main_sink(){int data=_main_data;{int result=data+1;printIntLine(result);}}static void main(){int data;data=-1;data=5;_main_data=data;main_sink();}
void main_sink(int * data_array[]);static void main(){int * data;int * data_array[5];data=NULL;data=new int[100];data_array[2]=data;main_sink(data_array);}void main_sink(int * data_array[]){int * data=data_array[2];{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printIntLine(data[0]);delete [] data;}}}
static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");data_array[2]=data;b_main_sink(data_array);}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];main_vasink(data, data);}
static void main(){{char * key="TEST\\TestKey";HUSKEY hKey=HKEY_CURRENT_USER;HUSKEY outKey;if (SHRegOpenUSKeyA( key, KEY_WRITE, &hKey, &outKey, 0)!=ERROR_SUCCESS){printLine("Registry key could not be opened");}else{printLine("Registry key opened successfully");}}}
static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));printWLine(data);}}
static void main_sink(wchar_t * data){{size_t i;for (i=0;i < wcslen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));data[0]=L'\0';{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}main_sink(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){fprintf(stdout, "%s\n", data);}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");my_union.a=data;{wchar_t * data=my_union.b;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnvp(_P_WAIT, COMMAND_INT, args);}}}
static wchar_t * main_source(wchar_t * data){{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}return data;}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, L"%s", args);va_end(args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);main_vasink(data, data);}
static void main(){short data;_union_type my_union;data=0;data=100-1;my_union.a=data;{short data=my_union.b;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}}
static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;{char src[100];memmove(data, src, 100*sizeof(char));printLine(data);}}
static void main(){int data;data=-1;data=20;main_sink(data);}void main_sink(int data){{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}
static void main(){char * data;data=NULL;data=new char[100];main_sink(&data);}void main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);delete [] data;}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnvp(_P_WAIT, COMMAND_INT, args);}}
static void main_sink(int data){{char * char_string;if (data > 0){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than 0");}}}static void main(){int data;data=-1;data=20;main_sink(data);}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");func_ptr(data);}void b_main_sink(wchar_t * data){wprintf(data);}
void b_main_sink(_struct_type my_struct);static void main(){int data;_struct_type my_struct;data=-1;data=OPEN("BadSource_open.txt", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;if (data!=-1){CLOSE(data);}}
static void main(){if(global_returns_t_or_f()){{if (fputws(L"string", stdout)==WEOF){printLine("fputws failed!");exit(1);}}}else{{if (fputws(L"string", stdout)==WEOF){printLine("fputws failed!");exit(1);}}}}
static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;if(global_returns_t_or_f()){}else{}{size_t src_len;wchar_t src[100];src_len=wcslen(src);wcsncat(data, src, src_len);printWLine(data);}}
static void main(){int * data;data=(int *)malloc(10*sizeof(int));{int i;for(i=0;i<(10/2);i++){data[i]=i;}}{int i;for(i=0;i<10;i++){data[i]=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}}
static void main(){long long * data;long long * &data_ref=data;data=NULL;data=new long long;delete data;{long long * data=data_ref;}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_sink_b(data);}void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_d(wchar_t * data){delete [] data;}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;data=PASSWORD;}{wchar_t * data=*data_ptr2;if (wcsstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}}
static void main(){{wchar_t oldpassword[256];wchar_t newpassword[256];NET_API_STATUS status;printWLine(L"Enter old password: ");fwscanf(stdin, L"%255s", oldpassword);printWLine(L"Enter new password: ");fwscanf(stdin, L"%255s", newpassword);status=NetUserChangePassword(NULL, USERNAME, oldpassword, newpassword);if(status==NERR_Success){printWLine(L"Success!");}else{wprintf(L"NetUserChangePassword failed. Status=%d=0x%x\n", status, status);}}}
static void main(){char * data;char * &data_ref=data;data=NULL;data=(char *)calloc(100, sizeof(char));{char * data=data_ref;free(data);}}
static void main(){wchar_t * data;data=NULL;if(global_returns_t_or_f()){data=new wchar_t[100];}else{data=new wchar_t[100];}if(global_returns_t_or_f()){delete [] data;}else{delete [] data;}}
static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}func_ptr(data);}void b_main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){int data;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{char data_buf[10]="AAAAAAAAA";{printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;printf(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){fwprintf(stdout, L"%s\n", data);}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;wprintf(L"%s\n", data);}
static void main(){unsigned char data;data=' ';data=5;{unsigned char data_copy=data;unsigned char data=data_copy;{unsigned char result=data * data;printHexUnsignedCharLine(result);}}}
static void main_sink(){int * data=main_data;printIntLine(*data);}static void main(){int * data;data=NULL;data=new int;main_data=data;main_sink();}
void main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];data=NULL;data=new wchar_t[100];data_array[2]=data;main_sink(data_array);}void main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t src[100];_snwprintf(data, 100, L"%s", src);printWLine(data);delete [] data;}}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{char src[100];strcat(data, src);printLine(data);}}
static void main(){int data;data=-1;data=20;b_main_sink(data);}void b_main_sink(int data){{char * char_string;if (data > 0){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than 0");}}}
void b_main_sink(void * void_data_ptr);static void main(){int data;data=-1;data=100-1;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
void b_main_sink();static void main(){bad_struct data;linked_list head={&head, &head};data.list.next=head.next;data.list.prev=&head;head.next=&data.list;head.next->prev=&data.list;_main_data=data;b_main_sink();}void b_main_sink(){bad_struct data=_main_data;* */prev=data.list.prev;next=data.list.next;prev->next=next;next->prev=prev;}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{int i, n, v;if (sscanf(data, "%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static void main(){char * data;union_type my_union;data=new char[100];my_union.a=data;{char * data=my_union.b;{char dest[50]="";_snprintf(dest, strlen(data), "%s", data);printLine(data);delete [] data;}}}
static void main(){wchar_t * data;struct_type my_struct;data=NULL;{wchar_t data_goodbuf[100];data=data_goodbuf;wcscpy(data, L"A String");printWLine(data);}my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){wchar_t * data=my_struct.a;}
static void main_source(wchar_t * &data){{wchar_t mystring[]=L"mystring";data=wcsdup(mystring);}}static void main(){wchar_t * data;data=NULL;main_source(data);free(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnvp(_P_WAIT, COMMAND_INT, args);}}
void main_source(int * &data);static void main(){int * data;main_source(data);printIntLine(data[0]);delete [] data;}void main_source(int * &data){{int * data_buf=new int[100];{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}}
int b_main_source(int data);static void main(){int data;data=-1;data=b_main_source(data);{char c=(char)data;printHexCharLine(c);}}int b_main_source(int data){data=CHAR_MAX-5;return data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main_sink(){wchar_t * data=_main_data;{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");_main_data=data;main_sink();}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(int data){{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than the length of the source string or too large");}}}
static void main_sink(int data){{wchar_t data_buf[10]=L"AAAAAAAAA";if (data >=0){printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=7;func_ptr(data);}
static void main_sink(int data){{int result=-1;if (data <=(int)sqrt((int)INT_MAX)){result=data * data;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}main_sink(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
static void main(){{wchar_t * key=L"TEST\\TestKey";HUSKEY hKey=HKEY_CURRENT_USER;HUSKEY outKey;if (SHRegOpenUSKeyW( key, KEY_WRITE, &hKey, &outKey, 0)!=ERROR_SUCCESS){printLine("Registry key could not be opened");}else{printLine("Registry key opened successfully");}}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_buf[100];data=data_buf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char dest[50]="";strcpy(dest, data);printLine(data);}}
static void main(){int data;data=-1;if(global_returns_t_or_f()){data=7;}else{data=7;}printIntLine(100/data);}
static void main(){unsigned int data;data=0;data=b_main_source(data);{unsigned int result=0;if (data > 0){result=data-1;printUnsignedLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}unsigned int b_main_source(unsigned int data){data=0;return data;}
void main_sink(struct_type my_struct);static void main(){char * data;struct_type my_struct;data=new char[100];my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){char * data=my_struct.a;{char dest[50]="";strncpy(dest, data, strlen(data));printLine(data);delete [] data;}}
static void main(){char * data;char data_buf[250]="PATH=";data=data_buf;if(global_returns_t_or_f()){strcat(data, NEW_PATH);}else{strcat(data, NEW_PATH);}PUTENV(data);}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main_sink(char * data){{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]='\0';printLine(data);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}func_ptr(data);}
void b_main_sink(short * data);static void main(){short data;data=-1;data=CHAR_MAX-5;b_main_sink(&data);}void b_main_sink(short * data_ptr){short data=*data_ptr;{char c=(char)data;printHexCharLine(c);}}
static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));data[0]=5L;printLongLongLine(data[0]);b_main_sink(data);}void b_main_sink(long long * data){free(data);}
static void main(){int data;data=7;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{wchar_t data_buf[10]=L"AAAAAAAAA";if (data >=0){printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main(){twointsclass * data;struct_type my_struct;data=NULL;data=NULL;data=(twointsclass *)realloc(data, 100*sizeof(twointsclass));my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){twointsclass * data=my_struct.a;free(data);}
void main_sink(void * void_data_ptr);static void main(){twointsclass * data;{twointsclass * data_buf=new twointsclass[100];{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}main_sink(&data);}void main_sink(void * void_data_ptr){twointsclass * * data_ptr=(twointsclass * *)void_data_ptr;twointsclass * data=(*data_ptr);printIntLine(data[0].a);delete [] data;}
static void main_sink(char * data){free(data);}static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;data=(char *)malloc(100*sizeof(char));func_ptr(data);}
static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=7;func_ptr(data);}void b_main_sink(int data){{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static int main_source(int data){{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}return data;}static void main(){int data;data=-1;data=main_source(data);{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static void main_sink(){twoints * data=_main_data;free(data);}static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));data[0].a=0;data[0].b=0;printStructLine(&data[0]);_main_data=data;main_sink();}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "15");{char * data_copy=data;char * data=data_copy;{int i, n, v;if (sscanf(data, "%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static void main(){int * data;int data_badbuf[50];int data_goodbuf[100];data=data_goodbuf;{memmove(data, src, 100*sizeof(int));printIntLine(data[0]);}}
static void main(){unsigned char data;data=' ';data=5;b_main_sink(data);}void b_main_sink(unsigned char data){c_main_sink(data);}void c_main_sink(unsigned char data){{unsigned char result=data+1;printHexUnsignedCharLine(result);}}
static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");data_array[2]=data;b_main_sink(data_array);}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];main_vasink(data, data);}
static void main(){int data;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main_sink(){twointsclass * data=main_data;delete [] data;}static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];main_data=data;main_sink();}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");{wchar_t * data_copy=data;wchar_t * data=data_copy;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_buf[100];data=data_buf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char dest[50]="";memcpy(dest, data, strlen(data)*sizeof(char));printLine(data);}}
void b_main_sink(twoints * data_array[]);static void main(){twoints * data;twoints * data_array[5];data=NULL;{twoints tmp;tmp.a=0;tmp.b=0;data=&tmp;}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(twoints * data_array[]){twoints * data=data_array[2];printStructLine(data);}
static void main(){twointsclass * data;twointsclass * &data_ref=data;data=NULL;data=new twointsclass;{twointsclass * data=data_ref;delete data;}}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));printWLine(data);}}
static wchar_t * main_source(wchar_t * data){wcscat(data, L"*.*");return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=b_main_source(data);{size_t i;wchar_t dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);}}wchar_t * b_main_source(wchar_t * data){{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}return data;}
static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));if(global_returns_t_or_f()){data=data_goodbuf;}else{data=data_goodbuf;}{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}printWLine(data);}}
wchar_t * main_source(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=main_source(data);{size_t i, dest_sz;wchar_t dest[100];wmemset(dest, L'C', 100-1);dest_sz=wcslen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);delete [] data;}}wchar_t * main_source(wchar_t * data){data=new wchar_t[100];return data;}
void b_main_sink(FILE * data_array[]);static void main(){FILE * data;FILE * data_array[5];data=NULL;data=freopen("BadSource_freopen.txt","w+",stdin);data_array[2]=data;b_main_sink(data_array);}void b_main_sink(FILE * data_array[]){FILE * data=data_array[2];if (data!=NULL){fclose(data);}}
static char * main_source(char * data){data=NULL;data=(char *)realloc(data, 100*sizeof(char));strcpy(data, "A String");printLine(data);return data;}static void main(){char * data;data=NULL;data=main_source(data);free(data);}
static void main(){wchar_t * data;wchar_t * &data_ref=data;data=NULL;data=new wchar_t[100];{wchar_t * data=data_ref;{wchar_t src[100];wcsncpy(data, src, 100);printWLine(data);delete [] data;}}}
static void main(){int data;data=-1;if(global_returns_t_or_f()){data=5;}else{data=5;}if(global_returns_t_or_f()){{int result=data * data;printIntLine(result);}}else{{int result=data * data;printIntLine(result);}}}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
static void main(){long long * data;data=NULL;data=new long long;printLongLongLine(*data);{long long * data_copy=data;long long * data=data_copy;delete data;}}
static void main_sink(int data){{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=20;func_ptr(data);}
static void main(){int data;_union_type my_union;data=7;my_union.a=data;{int data=my_union.b;{wchar_t data_buf[10]=L"AAAAAAAAA";if (data >=0){printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){long long * data;union_type my_union;data=NULL;data=new long long[100];my_union.a=data;{long long * data=my_union.b;delete [] data;}}
static void main_sink(wchar_t * data){if (wcsstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;main_sink(data);}
static void main(){unsigned int data;data=0;fscanf (stdin, "%u", &data);b_main_sink(data);}void b_main_sink(unsigned int data){{unsigned int result=-1;if (data < UINT_MAX){result=data+1;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main_sink(int data){assert(data > ASSERT_VALUE);}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=ASSERT_VALUE+1;func_ptr(data);}
static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}data_array[2]=data;b_main_sink(data_array);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(L"%s", args);va_end(args);}}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];main_vasink(data, data);}
static void main_sink(int count){{size_t i=0;FILE *file=NULL;const char *filename="output_bad.txt";file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}static void main(){int count;void (*func_ptr) (int)=main_sink;count=-1;count=20;func_ptr(count);}
static void main(){long long * data;long long * &data_ref=data;data=NULL;data=(long long *)calloc(100, sizeof(long long));{long long * data=data_ref;free(data);}}
static char * main_source(char * data){{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}return data;}static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, "%s", args);va_end(args);printLine(dest);}}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);main_vasink(data, data);}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;data=NULL;{wchar_t * data=*data_ptr1;data=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data, L'A', 100-1);data[100-1]=L'\0';}{wchar_t * data=*data_ptr2;printWLine(data);}}
static void main(){char * data;data=NULL;data=main_source(data);free(data);}char * main_source(char * data){data=(char *)malloc(100*sizeof(char));return data;}
static void main(){FILE * data;_union_type my_union;data=NULL;data=WFOPEN(L"file.txt", L"w+");my_union.a=data;{FILE * data=my_union.b;if (data!=NULL){fclose(data);}}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=7;}{int data=*data_ptr2;printIntLine(100/data);}}
static void main(){int * data;int * &data_ref=data;data=NULL;data=new int[100];{int * data=data_ref;{memcpy(data, src, 100*sizeof(int));printIntLine(data[0]);delete [] data;}}}
void main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}data_array[2]=data;main_sink(data_array);}void main_sink(char * data_array[]){char * data=data_array[2];{char src[100];memmove(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}
static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));if(global_returns_t_or_f()){data=data_goodbuf;}else{data=data_goodbuf;}{wchar_t src[100];wcscat(data, src);printWLine(data);}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;wcscpy(data, L"fixedstringtest");}{wchar_t * data=*data_ptr2;fwprintf(stdout, data);}}
static void main(){int data;data=-1;data=20;{int data_copy=data;int data=data_copy;{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}}
static void main_sink(){int data=main_data;{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}static void main(){int data;data=-1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}main_data=data;main_sink();}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");func_ptr(data);}void b_main_sink(wchar_t * data){fwprintf(stdout, data);}
static void main(){unsigned int data;data=0;data=(unsigned int)RAND32();{unsigned int result=-1;if (data <=(UINT_MAX/2)){result=data * 2;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
void b_main_sink();static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;_spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void main_sink(struct_type my_struct);static void main(){twointsclass * data;struct_type my_struct;{twointsclass * data_buf=new twointsclass[100];{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){twointsclass * data=my_struct.a;printIntLine(data[0].a);delete [] data;}
static void main(){wchar_t * data;data=NULL;{wchar_t mystring[]=L"mystring";data=wcsdup(mystring);}main_sink(&data);}void main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;free(data);}
static void main(){long long * data;data=NULL;main_source(data);printLongLongLine(*data);}void main_source(long long * &data){data=new long long;}
static int main_source(int data){fscanf (stdin, "%d", &data);return data;}static void main(){int data;data=-1;data=main_source(data);{int result=-1;if (data < INT_MAX){result=data+1;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));data[0]=L'\0';wcscpy(data, BAD_SRC_FIXED);b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{size_t i;for (i=0;i < wcslen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}
static void main(){int data;data=-1;data=5;b_main_sink(data);}void b_main_sink(int data){{int result=data * data;printIntLine(result);}}
static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;data=PASSWORD;my_union.a=data;{char * data=my_union.b;if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}}
static void main(){int data;data=7;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{wchar_t data_buf[10]=L"AAAAAAAAA";if (data >=0){printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){{twoints * data=(twoints *)malloc(100*sizeof(twoints));twoints * tmp;data[0].a=0;data[0].b=0;printStructLine(&data[0]);tmp=(twoints *)realloc(data, (130000)*sizeof(twoints));if (tmp!=NULL){data=tmp;data[0].a=1;data[0].b=1;printStructLine(&data[0]);}free(data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){char data;data=' ';fscanf (stdin, "%c", &data);{char result=0;if (data > CHAR_MIN){result=data-1;printHexCharLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static void main(){int data;data=-1;data=INT_MIN;b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static void main(){struct _twoints * data;data=NULL;data=(struct _twoints *)calloc(100, sizeof(struct _twoints));data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);free(data);}
static void main_sink(wchar_t * data){}static void main(){wchar_t * data;data=NULL;data=new wchar_t;delete data;main_sink(data);}
static void main_sink(){char * data=_main_data;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_main_data=data;main_sink();}
static void main(){unsigned int data;data=0;data=b_main_source(data);{unsigned int result=data * 2;printUnsignedLine(result);}}unsigned int b_main_source(unsigned int data){data=5;return data;}
static unsigned int main_source(unsigned int data){data=5;return data;}static void main(){unsigned int data;data=0;data=main_source(data);{unsigned int result=data+1;printUnsignedLine(result);}}
static void main(){unsigned int data;data=0;data=(unsigned int)RAND32();b_main_sink(&data);}void b_main_sink(unsigned int * data_ptr){unsigned int data=*data_ptr;{unsigned int result=-1;if (data <=(unsigned int)sqrt((unsigned int)UINT_MAX)){result=data * data;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){long long * data;long long * data_array[5];data=NULL;data=(long long *)malloc(100*sizeof(long long));{size_t i;for(i=0;i < 100;i++){data[i]=5L;}}free(data);data_array[2]=data;b_main_sink(data_array);}void b_main_sink(long long * data_array[]){long long * data=data_array[2];}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, L"%s", args);va_end(args);}}static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}}{wchar_t * data=*data_ptr2;main_vasink(data, data);}}
static twoints * main_source(twoints * data){data=(twoints *)malloc(100*sizeof(twoints));data[0].a=0;data[0].b=0;printStructLine(&data[0]);return data;}static void main(){twoints * data;data=NULL;data=main_source(data);free(data);}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;func_ptr(data);}void b_main_sink(char * data){{char src[100];memcpy(data, src, 100*sizeof(char));printLine(data);}}
void b_main_sink(void * void_data_ptr);static void main(){short data;data=0;data=100-1;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){short * data_ptr=(short *)void_data_ptr;short data=(*data_ptr);{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
void b_main_sink(int data);static void main(){int data;data=-1;data=100-1;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void d_main_sink(int data);void c_main_sink(int data){d_main_sink(data);}void e_main_sink(int data);void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf(data, args);va_end(args);}}static void main_sink(){char * data=_main_data;main_vasink(data, data);}static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");_main_data=data;main_sink();}
static void main_sink(int data){{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=20;func_ptr(data);}
static void main(){char * password;char password_buf[100]="";password=password_buf;strcpy(password, "Password1234!");{HANDLE pHandle;char * username="User";char * domain="Domain";if (LogonUserA( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}
char * b_main_source(char * data);static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;data=b_main_source(data);{FILE *pipe;pipe=POPEN(data, "wb");if (pipe!=NULL) PCLOSE(pipe);}}char * b_main_source(char * data){strcat(data, "*.*");return data;}
static void main_sink(){int data=_main_data;printIntLine(100 % data);}static void main(){int data;data=-1;data=7;_main_data=data;main_sink();}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(&data);}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf(data, args);va_end(args);}}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);main_vasink(data, data);}
static void main(){unsigned int data;unsigned int *data_ptr1=&data;unsigned int *data_ptr2=&data;data=0;{unsigned int data=*data_ptr1;data=5;}{unsigned int data=*data_ptr2;{unsigned int result=data * data;printUnsignedLine(result);}}}
static void main(){int data;data=-1;if(global_returns_t_or_f()){data=7;}else{data=7;}printIntLine(100/data);}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));{wchar_t src[100];wcsncat(data, src, 100);printWLine(data);free(data);}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;main_data=data;main_sink();}void main_sink(){twointsclass * data=main_data;delete data;}
static void main(){twoints * data;data=NULL;if(global_returns_t_or_f()){data=(twoints *)malloc(100*sizeof(twoints));{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}free(data);}else{data=(twoints *)malloc(100*sizeof(twoints));{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}free(data);}if(global_returns_t_or_f()){}else{}}
static void main(){wchar_t * data;_union_type my_union;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));data=data_buf;}my_union.a=data;{wchar_t * data=my_union.b;printWLine(data);free(data);}}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data, L'A', 100-1);data[100-1]=L'\0';free(data);b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){}
static void main_sink(int data){{int result=-1;if (data <=(int)sqrt((int)INT_MAX)){result=data * data;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}
static void main(){int data;data=-1;fscanf (stdin, "%d", &data);b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100];data=data_buf;{wchar_t * data=*data_ptr1;}{wchar_t * data=*data_ptr2;{size_t src_len;wchar_t src[100];src_len=wcslen(src);wcsncat(data, src, src_len);printWLine(data);}}}
static void main(){wchar_t * data;wchar_t * &data_ref=data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));{wchar_t * data=data_ref;free(data);}}
static void main(){char * data;_union_type my_union;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");my_union.a=data;{char * data=my_union.b;{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}}
static void main(){char * data;data=NULL;data=new char[100];main_sink(&data);}void main_sink(char * * data_ptr){char * data=*data_ptr;delete [] data;}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
static void main(){long long * data;data=NULL;{long long data_goodbuf[100];data=data_goodbuf;data[0]=5L;printLongLongLine(data[0]);}main_sink(&data);}void main_sink(void * void_data_ptr){long long * * data_ptr=(long long * *)void_data_ptr;long long * data=(*data_ptr);}
static void main(){int * data;data=NULL;data=new int[100];main_sink_b(data);}void main_sink_b(int * data){main_sink_c(data);}void main_sink_c(int * data){delete [] data;}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);_wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){int data;data=-1;data=7;printIntLine(100/data);}
static void main(){char data;data=' ';data=5;b_main_sink(data);}void b_main_sink(char data){{char result=data * data;printHexCharLine(result);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t src[100];wcsncpy(data, src, 100);printWLine(data);}}
static char * main_source(char * data){strcat(data, "*.*");return data;}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);_spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[250]="PATH=";data=data_buf;{char * data=*data_ptr1;strcat(data, NEW_PATH);}{char * data=*data_ptr2;PUTENV(data);}}
static void main(){int data;data=-1;fscanf (stdin, "%d", &data);b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){char * data;data=NULL;if(global_returns_t_or_f()){data=(char *)malloc(100*sizeof(char));}else{data=(char *)malloc(100*sizeof(char));}if(global_returns_t_or_f()){free(data);}else{free(data);}}
static wchar_t * main_source(wchar_t * data){return data;}static void main(){wchar_t * data;data=new wchar_t[100];data=main_source(data);{wchar_t dest[50]=L"";memmove(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);delete [] data;}}
static void main(){wchar_t * data;wchar_t * data_array[5];data=NULL;data=new wchar_t[100];data_array[2]=data;main_sink(data_array);}void main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];delete [] data;}
static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){if(global_returns_t_or_f()){{if (fputc((int)'A', stdout)==EOF){printLine("fputc failed!");exit(1);}}}else{{if (fputc((int)'A', stdout)==EOF){printLine("fputc failed!");exit(1);}}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(char * data){if (strncmp(PASSWORD, data, strlen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}
void _main_sink(wchar_t * data){{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");_main_sink(data);}
static void main_sink(wchar_t * data){delete [] data;}static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_sink(data);}
static void main(){long long data;data=5L;printLongLongLine(data);}
void b_main_sink(void * void_data_ptr);static void main(){char * data;data=(char *)malloc(100*sizeof(char));data[0]='\0';{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{size_t i;for (i=0;i < strlen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}
int b_main_source(int data);static void main(){int data;data=-1;data=b_main_source(data);printIntLine(100/data);}int b_main_source(int data){data=7;return data;}
static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));b_main_sink(&data);}void b_main_sink(twoints * * data_ptr){twoints * data=*data_ptr;free(data);}
static void main(){twoints * data;data=(twoints *)malloc(10*sizeof(twoints));{int i;for(i=0;i<10;i++){data[i].a=i;data[i].b=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){int data;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{char data_buf[10]="AAAAAAAAA";{printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){char * data;data=NULL;data=new char;main_sink(&data);}void main_sink(char * * data_ptr){char * data=*data_ptr;delete data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_t_or_f()){wcscpy(data, L"fixedstringtest");}else{wcscpy(data, L"fixedstringtest");}if(global_returns_t_or_f()){fwprintf(stdout, data);}else{fwprintf(stdout, data);}}
static void main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");func_ptr(data);}
static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));printWLine(data);delete [] data;}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{char dest[100]="";SNPRINTF(dest, 100-1, data);printLine(dest);}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;wcscpy(data, GOOD_OS_COMMAND);}{wchar_t * data=*data_ptr2;{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}}
static void main(){int data;data=7;{int data_copy=data;int data=data_copy;{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}}
char * b_main_source(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;data=b_main_source(data);{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}char * b_main_source(char * data){strcat(data, "file.txt");return data;}
static void main(){char * data;data=NULL;data=(char *)calloc(100, sizeof(char));strcpy(data, "A String");printLine(data);b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){free(data);}
static void main(){char * data;data=NULL;data=new char[100];delete [] data;{char * data_copy=data;char * data=data_copy;}}
static void main(){double * data;data=NULL;data=(double *)malloc(sizeof(*data));printDoubleLine(*data);free(data);}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=OPEN("BadSource_open.txt", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);}{int data=*data_ptr2;if (data!=-1){CLOSE(data);}}}
static void main(){unsigned char data;data=' ';data=UCHAR_MAX;{unsigned char data_copy=data;unsigned char data=data_copy;{unsigned char result=-1;if (data <=(UCHAR_MAX/2)){result=data * 2;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
void main_sink_b(char * data);static void main(){char * data;data=NULL;data=new char[100];main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){{size_t i, dest_sz;char dest[100];memset(dest, 'C', 100-1);dest_sz=strlen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);delete [] data;}}
static void main(){long long * data;long long * *data_ptr1=&data;long long * *data_ptr2=&data;data=NULL;{long long * data=*data_ptr1;data=(long long *)calloc(100, sizeof(long long));}{long long * data=*data_ptr2;free(data);}}
static void main(){long long * data;data=NULL;data=main_source(data);delete data;}long long * main_source(long long * data){data=new long long;return data;}
static void main(){wchar_t * password;wchar_t password_buf[100]=L"";password=password_buf;wcscpy(password, L"Password1234!");{HANDLE pHandle;wchar_t * username=L"User";wchar_t * domain=L"Domain";if (LogonUserW( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}func_ptr(data);}void b_main_sink(char * data){{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]='\0';printLine(data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}{char * data_copy=data;char * data=data_copy;if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}}
static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}func_ptr(data);}void b_main_sink(char * data){printf("%s\n", data);}
static void main(){wchar_t * data;data=NULL;if(global_returns_t_or_f()){data=new wchar_t[100];}else{data=new wchar_t[100];}{wchar_t dest[100];wmemset(dest, L'C', 100-1);memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);delete [] data;}}
static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;if(global_returns_t_or_f()){strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");}else{strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");}{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){wchar_t * data;wchar_t * data_array[5];data=NULL;{wchar_t data_goodbuf[100];data=data_goodbuf;wcscpy(data, L"A String");printWLine(data);}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];}
static void main(){char * data;char data_buf[100]="";data=data_buf;if(global_returns_t_or_f()){strcpy(data, "fixedstringtest");}else{strcpy(data, "fixedstringtest");}if(global_returns_t_or_f()){{char dest[100]="";SNPRINTF(dest, 100-1, data);printLine(dest);}}else{{char dest[100]="";SNPRINTF(dest, 100-1, data);printLine(dest);}}}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;data=NULL;data=(char *)malloc((10+1)*sizeof(char));func_ptr(data);}void b_main_sink(char * data){{char data_src[10+1]=SRC_STRING;size_t i, src_len;src_len=strlen(data_src);for (i=0;i < src_len;i++){data[i]=data_src[i];}printLine(data);free(data);}}
static void main_sink(){int * data=main_data;printIntLine(data[0]);}static void main(){int * data;data=NULL;data=new int[100];{size_t i;for(i=0;i < 100;i++){data[i]=5;}}main_data=data;main_sink();}
static void main(){int * data;data=NULL;data=(int *)calloc(100, sizeof(int));free(data);}
void b_main_sink(short data);static void main(){short data;data=0;data=100-1;b_main_sink(data);}void c_main_sink(short data);void b_main_sink(short data){c_main_sink(data);}void d_main_sink(short data);void c_main_sink(short data){d_main_sink(data);}void e_main_sink(short data);void d_main_sink(short data){e_main_sink(data);}void e_main_sink(short data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
void b_main_sink(short data_array[]);static void main(){short data;short data_array[5];data=0;data=100-1;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(short data_array[]){short data=data_array[2];{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");{wchar_t * data_copy=data;wchar_t * data=data_copy;{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_t_or_f()){{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}}else{{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}}if(global_returns_t_or_f()){{int i, n, v;if (swscanf(data, L"%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}else{{int i, n, v;if (swscanf(data, L"%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}}
void main_sink(twoints * data);static void main(){twoints * data;void (*func_ptr) (twoints *)=main_sink;{twoints * data_buf=new twoints[100];{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}func_ptr(data);}void main_sink(twoints * data){printStructLine(&data[0]);delete [] data;}
static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));{wchar_t dest[50]=L"";_snwprintf(dest, wcslen(data), L"%s", data);printWLine(data);free(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;if (wcsncmp(PASSWORD, data, wcslen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);if (strncmp(PASSWORD, data, strlen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}char * b_main_source(char * data){data=PASSWORD;return data;}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}}{int data=*data_ptr2;{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}}
void b_main_sink(int data);static void main(){int data;data=-1;data=7;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void d_main_sink(int data);void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){printIntLine(100 % data);}
static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;{wchar_t dest[50]=L"";wcscat(dest, data);printWLine(data);}}
static void main(){unsigned char data;data=' ';data=(unsigned char)rand();{unsigned char data_copy=data;unsigned char data=data_copy;{unsigned char result=-1;if (data <=(UCHAR_MAX/2)){result=data * 2;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");func_ptr(data);}void b_main_sink(wchar_t * data){_wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_t_or_f()){wcscat(data, L"*.*");}else{wcscat(data, L"*.*");}_wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){int * data;data=NULL;main_source(data);delete data;}void main_source(int * &data){data=new int;}
char * b_main_source(char * data);static void main(){char * data;data=(char *)malloc(100*sizeof(char));data=b_main_source(data);{char dest[50]="";_snprintf(dest, strlen(data), "%s", data);printLine(data);free(data);}}char * b_main_source(char * data){return data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");_main_data=data;b_main_sink();}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}void b_main_sink(){wchar_t * data=_main_data;main_vasink(data, data);}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char dest[100];memset(dest, 'C', 100-1);memcpy(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);}}
static void main(){{int * data=(int *)malloc(100*sizeof(int));int * tmp;data[0]=5;printIntLine(data[0]);tmp=(int *)realloc(data, (130000)*sizeof(int));if (tmp!=NULL){data=tmp;data[0]=10;printIntLine(data[0]);}free(data);}}
static void main(){int count;count=-1;count=RAND32();{size_t i=0;FILE *file=NULL;const char *filename="output_good.txt";if (count > 0 && count <=20){file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}}
static void main(){long long * data;data=NULL;data=(long long *)calloc(100, sizeof(long long));data[0]=5L;printLongLongLine(data[0]);_main_data=data;b_main_sink();}void b_main_sink(){long long * data=_main_data;free(data);}
static void main(){unsigned char data;data=' ';fscanf (stdin, "%hc", &data);{unsigned char result=-1;if (data <=(unsigned char)sqrt((unsigned char)UCHAR_MAX)){result=data * data;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){if(global_returns_t_or_f()){{FILE * file_ptr=fopen("file.txt", "w+");if (file_ptr==NULL){printLine("The file failed to open");exit(1);}if (fputs("Write something to the file", stdout)==EOF){printLine("fputs failed!");exit(1);}if (file_ptr!=NULL){fclose(file_ptr);}}}else{{FILE * file_ptr=fopen("file.txt", "w+");if (file_ptr==NULL){printLine("The file failed to open");exit(1);}if (fputs("Write something to the file", stdout)==EOF){printLine("fputs failed!");exit(1);}if (file_ptr!=NULL){fclose(file_ptr);}}}}
static char * main_source(char * data){strcat(data, "*.*");return data;}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main_sink(wchar_t * data){wprintf(data);}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");func_ptr(data);}
static char * main_source(char * data){strcpy(data, "fixedstringtest");return data;}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);{char dest[100]="";SNPRINTF(dest, 100-1, data);printLine(dest);}}
static void main(){int * data;data=NULL;data=(int *)malloc(100*sizeof(int));{size_t i;for(i=0;i < 100;i++){data[i]=5;}}free(data);{int * data_copy=data;int * data=data_copy;}}
static void main(){struct _twoints * data;data=NULL;data=new struct _twoints;data->a=0;data->b=0;printStructLine((twoints *)data);main_sink_b(data);}void main_sink_b(struct _twoints * data){main_sink_c(data);}void main_sink_c(struct _twoints * data){main_sink_d(data);}void main_sink_d(struct _twoints * data){delete data;}
void _main_sink(int * data){printIntLine(data[0]);free(data);}static void main(){int * data;{int * data_buf=(int *)malloc(100*sizeof(int));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}_main_sink(data);}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t dest[100];wmemset(dest, L'C', 100-1);memmove(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);free(data);}}}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(data, args);va_end(args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");{wchar_t * data_copy=data;wchar_t * data=data_copy;main_vasink(data, data);}}
static void main_sink(){wchar_t * data=main_data;delete [] data;}static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_data=data;main_sink();}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
void b_main_sink(_struct_type my_struct);static void main(){int data;_struct_type my_struct;data=-1;data=ASSERT_VALUE+1;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;assert(data > ASSERT_VALUE);}
void b_main_sink(char * data);static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{char src[100];strcpy(data, src);printLine(data);}}
static void main(){void * data;_union_type my_union;data=NULL;data=WIDE_STRING;my_union.a=data;{void * data=my_union.b;{size_t data_len=wcslen((wchar_t *)data);void * data_dest=(void *)calloc(data_len+1, sizeof(wchar_t));memcpy(data_dest, data, (data_len+1)*sizeof(wchar_t));printWLine((wchar_t *)data_dest);free(data_dest);}}}
static int main_source(int data){data=20;return data;}static void main(){int data;data=-1;data=main_source(data);{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}
static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;data=new char;func_ptr(data);}void main_sink(char * data){delete data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}{int i, n, v;if (sscanf(data, "%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static void main(){if(global_returns_t_or_f()){{char * pipeName="\\\\.\\pipe\\mypipe";HANDLE hPipe=INVALID_HANDLE_VALUE;hPipe=CreateNamedPipeA( pipeName, FILE_FLAG_FIRST_PIPE_INSTANCE, PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, BUFSIZE, BUFSIZE, NMPWAIT_USE_DEFAULT_WAIT, NULL);if (hPipe==INVALID_HANDLE_VALUE){exit(1);}if (GetLastError()==ERROR_ACCESS_DENIED){exit(1);}if (!ImpersonateNamedPipeClient(hPipe)){exit(1);}CloseHandle(hPipe);}}else{{char * pipeName="\\\\.\\pipe\\mypipe";HANDLE hPipe=INVALID_HANDLE_VALUE;hPipe=CreateNamedPipeA( pipeName, FILE_FLAG_FIRST_PIPE_INSTANCE, PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, BUFSIZE, BUFSIZE, NMPWAIT_USE_DEFAULT_WAIT, NULL);if (hPipe==INVALID_HANDLE_VALUE){exit(1);}if (GetLastError()==ERROR_ACCESS_DENIED){exit(1);}if (!ImpersonateNamedPipeClient(hPipe)){exit(1);}CloseHandle(hPipe);}}}
static int main_source(int data){data=100-1;return data;}static void main(){int data;data=-1;data=main_source(data);{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "C:\\Windows\\System32\\winsrv.dll");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{HMODULE hModule;hModule=LoadLibraryA(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
static void main_sink(int count){{size_t i=0;FILE *file=NULL;const char *filename="output_bad.txt";file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}static void main(){int count;count=-1;count=20;main_sink(count);}
static void main(){wchar_t * cryptokey;wchar_t cryptokey_buf[100]=L"";cryptokey=cryptokey_buf;if(global_returns_t_or_f()){{size_t cryptokey_len=wcslen(cryptokey);if(100-cryptokey_len > 1){fgetws(cryptokey+cryptokey_len, (int)(100-cryptokey_len), stdin);cryptokey_len=wcslen(cryptokey);if (cryptokey_len > 0){cryptokey[cryptokey_len-1]=L'\0';}}}}else{{size_t cryptokey_len=wcslen(cryptokey);if(100-cryptokey_len > 1){fgetws(cryptokey+cryptokey_len, (int)(100-cryptokey_len), stdin);cryptokey_len=wcslen(cryptokey);if (cryptokey_len > 0){cryptokey[cryptokey_len-1]=L'\0';}}}}{HCRYPTPROV cryptoprov;HCRYPTKEY key;HCRYPTHASH hash;DWORD toBeEncryptedLen=wcslen(toBeEncrypted)*sizeof(wchar_t);if(!CryptAcquireContext(&cryptoprov, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, 0)){if(!CryptAcquireContext(&cryptoprov, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET)){printLine("Error in acquiring cryptographic context");exit(1);}}if(!CryptCreateHash(cryptoprov, CALG_SHA1, 0, 0, &hash)){printLine("Error in creating hash");exit(1);}if(!CryptHashData(hash, (BYTE *) cryptokey, wcslen(cryptokey)*sizeof(wchar_t), 0)){printLine("Error in hashing cryptokey");exit(1);}if(!CryptDeriveKey(cryptoprov, CALG_3DES, hash, 0, &key)){printLine("Error in CryptDeriveKey");exit(1);}if(!CryptEncrypt(key, (HCRYPTHASH)NULL, 1, 0, (BYTE *)toBeEncrypted, &toBeEncryptedLen, sizeof(toBeEncrypted))){printLine("Error in CryptEncryptData");exit(1);}printWLine(toBeEncrypted);}}
static void main(){twoints * data;_union_type my_union;twoints data_badbuf[50];twoints data_goodbuf[100];data=data_goodbuf;my_union.a=data;{twoints * data=my_union.b;{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memmove(data, src, 100*sizeof(twoints));printStructLine(&data[0]);}}}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{char dest[50]="";strcpy(dest, data);printLine(data);}}
static void main(){if(global_returns_t_or_f()){{time_t time_val;time(&time_val);if (time_val > TIME_CHECK){printLine("Happy New Year!");}}}else{{time_t time_val;time(&time_val);if (time_val > TIME_CHECK){printLine("Happy New Year!");}}}}
void b_main_sink(char * data);static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{char dest[100];memset(dest, 'C', 100-1);memcpy(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);}}
static void main(){{if (fwprintf(stdout, L"%s\n", L"string") < 0){printLine("fwprintf failed!");}}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];wmemset(data, L'A', 100-1);data[100-1]=L'\0';main_sink_b(data);}void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){printWLine(data);}
static void main(){int data;_union_type my_union;data=-1;data=100-1;my_union.a=data;{int data=my_union.b;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}}
static void main(){char * data;data=NULL;data=new char;main_sink(&data);}void main_sink(char * * data_ptr){char * data=*data_ptr;delete data;}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}}{int data=*data_ptr2;{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * password;_struct_type my_struct;wchar_t password_buf[100]=L"";password=password_buf;wcscpy(password, L"Password1234!");my_struct.a=password;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * password=my_struct.a;{HANDLE pHandle;wchar_t * username=L"User";wchar_t * domain=L"Domain";if (LogonUserW( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}
void b_main_sink(int data);static void main(){int data;data=-1;data=7;b_main_sink(data);}void b_main_sink(int data){printIntLine(100/data);}
static void main(){char * data;char data_buf[250]="PATH=";data=data_buf;strcat(data, NEW_PATH);{char * data_copy=data;char * data=data_copy;PUTENV(data);}}
static char main_source(char data){data=5;return data;}static void main(){char data;data=' ';data=main_source(data);{char result=data * data;printHexCharLine(result);}}
static void main(){twointsclass * data;data=NULL;data=(twointsclass *)calloc(100, sizeof(twointsclass));main_data=data;main_sink();}void main_sink(){twointsclass * data=main_data;free(data);}
void _main_sink(wchar_t * data){{wchar_t dest[100];wcsncpy(dest, data, wcslen(dest));dest[100-1]=L'\0';printWLine(dest);}}static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}_main_sink(data);}
static void main_sink(wchar_t * data){EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");func_ptr(data);}
void b_main_sink(_struct_type my_struct);static void main(){short data;_struct_type my_struct;data=-1;data=CHAR_MAX-5;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){short data=my_struct.a;{char c=(char)data;printHexCharLine(c);}}
static void main(){int * data;data=NULL;if(global_returns_t_or_f()){data=(int *)malloc(100*sizeof(int));free(data);}else{data=(int *)malloc(100*sizeof(int));free(data);}if(global_returns_t_or_f()){}else{}}
static twointsclass * main_source(twointsclass * data){{twointsclass * data_buf=new twointsclass[100];{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}return data;}static void main(){twointsclass * data;data=main_source(data);printIntLine(data[0].a);delete [] data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, data);printWLine(dest);}}
static void main(){{char dst[DST_SZ];memmove(dst, COPY_STR, (DST_SZ-1)*sizeof(char));dst[DST_SZ-1]='\0';printLine(dst);}}
static void main_sink(char * data){{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");func_ptr(data);}
void b_main_sink();static void main(){int data;data=-1;data=CHAR_MAX-5;_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{char c=(char)data;printHexCharLine(c);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;data=(wchar_t *)malloc(100*sizeof(wchar_t));func_ptr(data);}void b_main_sink(wchar_t * data){{wchar_t dest[50]=L"";memmove(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);free(data);}}
static void main(){long long * data;data=NULL;data=new long long;delete data;main_sink(&data);}void main_sink(void * void_data_ptr){long long * * data_ptr=(long long * *)void_data_ptr;long long * data=(*data_ptr);}
static void main(){wchar_t * data;data=NULL;data=new wchar_t;main_sink_b(data);}void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_d(wchar_t * data){main_sink_e(data);}void main_sink_e(wchar_t * data){delete data;}
void main_sink_b(wchar_t * data);static void main(){wchar_t * data;data=new wchar_t[100];main_sink_b(data);}void main_sink_c(wchar_t * data);void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_d(wchar_t * data);void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_d(wchar_t * data){{wchar_t dest[50]=L"";wcsncpy(dest, data, wcslen(data));printWLine(data);delete [] data;}}
static void main(){unsigned int data;data=0;data=5;{unsigned int result=data * data;printUnsignedLine(result);}}
static void main_sink(long long * data){{memcpy(data, src, 100*sizeof(long long));printLongLongLine(data[0]);}}static void main(){long long * data;void (*func_ptr) (long long *)=main_sink;long long * data_badbuf=(long long *)ALLOCA(50*sizeof(long long));long long * data_goodbuf=(long long *)ALLOCA(100*sizeof(long long));data=data_goodbuf;func_ptr(data);}
static void main(){unsigned int data;data=0;data=5;{unsigned int result=data * 2;printUnsignedLine(result);}}
static void main(){twoints * data;{twoints * data_buf=(twoints *)malloc(100*sizeof(twoints));{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}{twoints * data_copy=data;twoints * data=data_copy;printStructLine(&data[0]);free(data);}}
static void main_sink(int data){{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=RAND32();func_ptr(data);}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';{wchar_t * data=*data_ptr1;data=data_buf;}{wchar_t * data=*data_ptr2;{wchar_t src[100];wcscpy(data, src);printWLine(data);}}}
static void main(){int count;count=-1;count=RAND32();{size_t i=0;if (count > 0 && count <=20){for (i=0;i < (size_t)count;i++){printLine("Hello");}}}}
static void main(){long long * data;data=NULL;data=new long long[100];{memcpy(data, src, 100*sizeof(long long));printLongLongLine(data[0]);delete [] data;}}
static void main(){twoints * data;data=NULL;data=(twoints *)calloc(100, sizeof(twoints));free(data);}
static void main_sink(){wchar_t * data=_main_data;{wchar_t src[100];wcscat(data, src);printWLine(data);}}static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;_main_data=data;main_sink();}
static char * main_source(char * data){{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}return data;}static void main(){char * data;data=NULL;data=main_source(data);{size_t i;char dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);}}
static char * main_source(char * data){{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}return data;}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(_struct_type my_struct);static void main(){short data;_struct_type my_struct;data=0;data=100-1;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){short data=my_struct.a;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main(){unsigned char data;data=' ';data=5;b_main_sink(&data);}void b_main_sink(unsigned char * data_ptr){unsigned char data=*data_ptr;{unsigned char result=data+1;printHexUnsignedCharLine(result);}}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main_sink(char data){{char result=data * data;printHexCharLine(result);}}static void main(){char data;data=' ';data=5;main_sink(data);}
static void main(){long long data;data=5L;printLongLongLine(data);}
static void main(){int data;int &data_ref=data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}{int data=data_ref;{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}}
static void main_sink(){int data=_main_data;{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than the length of the source string or too large");}}}static void main(){int data;data=-1;data=RAND32();_main_data=data;main_sink();}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{wchar_t src[100];wcsncpy(data, src, 100);printWLine(data);}}
static void main_sink(){wchar_t * data=_main_data;{wchar_t dest[100];wmemset(dest, L'C', 100-1);memmove(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);free(data);}}static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));_main_data=data;main_sink();}
static void main_sink(){FILE * data=_main_data;if (data!=NULL){fclose(data);}}static void main(){FILE * data;data=NULL;data=freopen("BadSource_freopen.txt","w+",stdin);_main_data=data;main_sink();}
static wchar_t * main_source(wchar_t * data){{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));strcpy(data, "A String");printLine(data);_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;free(data);}
static void main_sink(int count){{size_t i=0;FILE *file=NULL;const char *filename="output_good.txt";if (count > 0 && count <=20){file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}}static void main(){int count;count=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;count=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}main_sink(count);}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf(data, args);va_end(args);}}void d_main_sink(char * data){main_vasink(data, data);}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;wcscat(data, L"*.*");}{wchar_t * data=*data_ptr2;_wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];_wsystem(data);}
static void main_sink(){wchar_t * data=_main_data;{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, data);printWLine(dest);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");_main_data=data;main_sink();}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(&data);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(data, args);va_end(args);}}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;main_vasink(data, data);}
static void main(){twoints * data;data=(twoints *)malloc(100);if(global_returns_t_or_f()){if (data!=NULL){data[0].a=1;data[0].b=1;printStructLine(&data[0]);free(data);}}else{if (data!=NULL){data[0].a=1;data[0].b=1;printStructLine(&data[0]);free(data);}}}
static void main(){char * data;data=NULL;{char data_goodbuf[100];data=data_goodbuf;strcpy(data, "A String");printLine(data);}main_sink_b(data);}void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(data, args);va_end(args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);main_vasink(data, data);}wchar_t * b_main_source(wchar_t * data){wcscpy(data, L"fixedstringtest");return data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");func_ptr(data);}void b_main_sink(wchar_t * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){int data;data=-1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){wchar_t * data;data=new wchar_t[100];{wchar_t dest[50]=L"";memmove(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);delete [] data;}}
static void main(){FILE * data;data=fopen("BadSource_fopen.txt", "w+");fclose(data);b_main_sink(&data);}void b_main_sink(FILE * * data_ptr){FILE * data=*data_ptr;}
static void main(){FILE * data;data=fopen("GoodSource_fopen.txt", "w+");b_main_sink(data);}void b_main_sink(FILE * data){c_main_sink(data);}void c_main_sink(FILE * data){d_main_sink(data);}void d_main_sink(FILE * data){e_main_sink(data);}void e_main_sink(FILE * data){fclose(data);}
static wchar_t * main_source(wchar_t * data){data=PASSWORD;return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);if (wcsncmp(PASSWORD, data, wcslen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;wcscpy(data, L"fixedstringtest");}{wchar_t * data=*data_ptr2;main_vasink(data, data);}}
static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));{size_t i;for(i=0;i < 100;i++){data[i]=5L;}}_main_data=data;b_main_sink();}void b_main_sink(){long long * data=_main_data;printLongLongLine(data[0]);}
static void main(){{if (fprintf(stdout, "%s\n", "string") < 0){printLine("fprintf failed!");exit(1);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(&data);}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;main_vasink(data, data);}
static void main(){int data;data=-1;data=5;_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{int result=data+1;printIntLine(result);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data="P";b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){long long * data;long long * data_array[5];data=NULL;data=(long long *)calloc(100, sizeof(long long));data[0]=5L;printLongLongLine(data[0]);data_array[2]=data;b_main_sink(data_array);}void b_main_sink(long long * data_array[]){long long * data=data_array[2];free(data);}
static void main(){char data;data=' ';data=5;b_main_sink(data);}void b_main_sink(char data){c_main_sink(data);}void c_main_sink(char data){d_main_sink(data);}void d_main_sink(char data){{char result=data * data;printHexCharLine(result);}}
static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;data=PASSWORD;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];data=NULL;data="Good";data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];printf("%s\n", data);}
static void main(){char data;data=' ';data=b_main_source(data);{char result=-1;if (data < CHAR_MAX){result=data+1;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}char b_main_source(char data){data=CHAR_MAX;return data;}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}void b_main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void _main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnv(_P_WAIT, COMMAND_INT_PATH, args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_sink(data);}
void b_main_sink(int data);static void main(){int data;data=-1;data=ASSERT_VALUE+1;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){assert(data > ASSERT_VALUE);}
static void main(){int data;data=-1;data=20;{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}
static void main(){int * data;data=NULL;data=new int;delete data;main_data=data;main_sink();}void main_sink(){int * data=main_data;}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;data=b_main_source(data);{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}wchar_t * b_main_source(wchar_t * data){wcscat(data, L"file.txt");return data;}
static void main(){char * data;data=NULL;main_source(data);}void main_source(char * &data){data=new char[100];memset(data, 'A', 100-1);data[100-1]='\0';delete [] data;}
static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=-1;data=20;func_ptr(data);}void b_main_sink(int data){{char * char_string;if (data > 0){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than 0");}}}
void b_main_sink(int * * data);static void main(){int * data;int data_badbuf[50];int data_goodbuf[100];data=data_goodbuf;b_main_sink(&data);}void b_main_sink(int * * data_ptr){int * data=*data_ptr;{memcpy(data, src, 100*sizeof(int));printIntLine(data[0]);}}
static void main_sink(twoints * data){free(data);}static void main(){twoints * data;data=NULL;data=NULL;data=(twoints *)realloc(data, 100*sizeof(twoints));data[0].a=0;data[0].b=0;printStructLine(&data[0]);main_sink(data);}
static void main_sink(){unsigned int data=_main_data;{unsigned int result=0;if (data > 0){result=data-1;printUnsignedLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}static void main(){unsigned int data;data=0;data=0;_main_data=data;main_sink();}
void b_main_sink(int data);static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=-1;data=7;func_ptr(data);}void b_main_sink(int data){printIntLine(100 % data);}
static void main_source(twointsclass * &data){data=new twointsclass[100];}static void main(){twointsclass * data;data=NULL;main_source(data);delete [] data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{int i, n, v;if (sscanf(data, "%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static void main(){long long * data;long long * data_badbuf=(long long *)ALLOCA(50*sizeof(long long));long long * data_goodbuf=(long long *)ALLOCA(100*sizeof(long long));if(global_returns_t_or_f()){data=data_goodbuf;}else{data=data_goodbuf;}{memmove(data, src, 100*sizeof(long long));printLongLongLine(data[0]);}}
static void main(){int data;data=-1;fscanf (stdin, "%d", &data);main_data=data;main_sink();}void main_sink(){int data=main_data;{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){long long * data;data=NULL;{long long data_goodbuf[100];data=data_goodbuf;data[0]=5L;printLongLongLine(data[0]);}}
static void main(){{double * data;double * * pointer=(double * *)ALLOCA(sizeof(double *));data=(double *)malloc(sizeof(double));{double * data=*pointer;printDoubleLine(*data);}}}
static void main_vasinkg(char * data, ...){{va_list args;va_start(args, data);vprintf("%s", args);va_end(args);}}static void main_vasinkb(char * data, ...){{va_list args;va_start(args, data);vprintf(data, args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;if(global_returns_f()){strcpy(data, "fixedstringtest");}else{strcpy(data, "fixedstringtest");}if(global_returns_t()){main_vasinkb(data, data);}else{main_vasinkb(data, data);}}
static void main_sink(){twoints * data=_main_data;free(data);}static void main(){twoints * data;data=NULL;data=NULL;data=(twoints *)realloc(data, 100*sizeof(twoints));data[0].a=0;data[0].b=0;printStructLine(&data[0]);_main_data=data;main_sink();}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
static void main(){int data;data=-1;data=CHAR_MAX-5;{int data_copy=data;int data=data_copy;{short s=(short)data;printf("%hd\n", s);}}}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
static void main_sink(){char * data=_main_data;if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}_main_data=data;main_sink();}
static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));free(data);}
static void main(){twoints * data;twoints * data_array[5];data=NULL;data=new twoints[100];{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}data_array[2]=data;main_sink(data_array);}void main_sink(twoints * data_array[]){twoints * data=data_array[2];printStructLine(&data[0]);}
static void main(){char * data;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}{char src[100];strcpy(data, src);printLine(data);}}
static int main_source(int data){data=ASSERT_VALUE+1;return data;}static void main(){int data;data=-1;data=main_source(data);assert(data > ASSERT_VALUE);}
static void main(){list<int> data;data=main_source(data);{list<int>::iterator i;cout << "The list contains: ";for( i=data.begin();i!=data.end();i++){if (!*i){data.clear();}cout << " " << *i;}cout << endl;}}list<int> main_source(list<int> data){data.push_back(100);data.push_back(200);return data;}
static void main(){struct _twoints * data;data=NULL;data=NULL;data=(struct _twoints *)realloc(data, 100*sizeof(struct _twoints));data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);b_main_sink(data);}void b_main_sink(struct _twoints * data){c_main_sink(data);}void c_main_sink(struct _twoints * data){d_main_sink(data);}void d_main_sink(struct _twoints * data){e_main_sink(data);}void e_main_sink(struct _twoints * data){free(data);}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100];data=data_buf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{char dest[50]="";memmove(dest, data, strlen(data)*sizeof(char));printLine(data);}}
static void main(){int data;data=-1;data=ASSERT_VALUE+1;assert(data > ASSERT_VALUE);}
static void main(){int data;data=-1;data=5;b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{int result=data * data;printIntLine(result);}}
static void main(){unsigned char data;data=' ';data=(unsigned char)rand();b_main_sink(data);}void b_main_sink(unsigned char data){c_main_sink(data);}void c_main_sink(unsigned char data){d_main_sink(data);}void d_main_sink(unsigned char data){{unsigned char result=-1;if (data <=(UCHAR_MAX/2)){result=data * 2;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;b_main_sink(data);}void b_main_sink(wchar_t * data){{size_t src_len;wchar_t src[100];src_len=wcslen(src);wcsncat(data, src, src_len);printWLine(data);}}
void b_main_sink(char * data);static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{char src[100];_snprintf(data, 100, "%s", src);printLine(data);}}
static void main(){twointsclass * data;data=NULL;main_source(data);delete [] data;}void main_source(twointsclass * &data){data=new twointsclass[100];}
void b_main_sink(int * data);static void main(){int * data;void (*func_ptr) (int *)=b_main_sink;data=(int *)malloc(100);func_ptr(data);}void b_main_sink(int * data){if (data!=NULL){data[0]=5;printIntLine(data[0]);free(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){if (wcsncmp(PASSWORD, data, wcslen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){long long * data;long long * *data_ptr1=&data;long long * *data_ptr2=&data;long long * data_badbuf=(long long *)ALLOCA(50*sizeof(long long));long long * data_goodbuf=(long long *)ALLOCA(100*sizeof(long long));{long long * data=*data_ptr1;data=data_goodbuf;}{long long * data=*data_ptr2;{memmove(data, src, 100*sizeof(long long));printLongLongLine(data[0]);}}}
static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;{char src[100];strcpy(data, src);printLine(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");{wchar_t * data_copy=data;wchar_t * data=data_copy;{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}}
void b_main_sink(short data);static void main(){short data;data=0;data=100-1;b_main_sink(data);}void c_main_sink(short data);void b_main_sink(short data){c_main_sink(data);}void d_main_sink(short data);void c_main_sink(short data){d_main_sink(data);}void d_main_sink(short data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
void b_main_sink();static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
static void main(){int count;count=-1;count=b_main_source(count);{size_t i=0;for (i=0;i < (size_t)count;i++){printLine("Hello");}}}int b_main_source(int count){count=20;return count;}
static void main(){int data;data=-1;main_source(data);{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}void main_source(int &data){data=20;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=L"P";{wchar_t * data_copy=data;wchar_t * data=data_copy;if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}}
static void main(){int data;data=-1;data=5;{int data_copy=data;int data=data_copy;{int result=data * 2;printIntLine(result);}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){if (strstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
static void main(){int data;data=-1;data=5;b_main_sink(data);}void b_main_sink(int data){{int result=data * 2;printIntLine(result);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, L"%s", args);va_end(args);}}void c_main_sink(wchar_t * data){main_vasink(data, data);}
static void main(){unsigned int data;data=0;if(global_returns_t_or_f()){data=(unsigned int)RAND32();}else{data=(unsigned int)RAND32();}if(global_returns_t_or_f()){{unsigned int result=0;if (data > 0){result=data-1;printUnsignedLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}else{{unsigned int result=0;if (data > 0){result=data-1;printUnsignedLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(data);}void b_main_sink(wchar_t * data){fwprintf(stdout, L"%s\n", data);}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;data=b_main_source(data);{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}wchar_t * b_main_source(wchar_t * data){wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");return data;}
void b_main_sink(char * data);static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{char dest[100];memcpy(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
static void main(){twointsclass * data;union_type my_union;data=NULL;data=new twointsclass[100];my_union.a=data;{twointsclass * data=my_union.b;delete [] data;}}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;_wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main_sink(){int count=_main_data;{size_t i=0;if (count > 0 && count <=20){for (i=0;i < (size_t)count;i++){printLine("Hello");}}}}static void main(){int count;count=-1;fscanf (stdin, "%d", &count);_main_data=count;main_sink();}
static void main(){twoints * data;twoints * data_array[5];data=NULL;data=new twoints;data_array[2]=data;main_sink(data_array);}void main_sink(twoints * data_array[]){twoints * data=data_array[2];delete data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t dest[100];memcpy(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';{wchar_t * data=*data_ptr1;data=data_buf;}{wchar_t * data=*data_ptr2;{wchar_t dest[100];wcscpy(dest, data);printWLine(dest);}}}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main_sink(twoints * data){}static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));free(data);main_sink(data);}
void _main_sink(char * data){system(data);}static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");_main_sink(data);}
static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;{char * data_copy=data;char * data=data_copy;{size_t i, dest_sz;char dest[100];memset(dest, 'C', 100-1);dest_sz=strlen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);}}}
static void main(){int * data;int * *data_ptr1=&data;int * *data_ptr2=&data;data=NULL;{int * data=*data_ptr1;data=new int[100];}{int * data=*data_ptr2;delete [] data;}}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{wchar_t dest[100];wmemset(dest, L'C', 100-1);memmove(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}main_sink(data);}void main_sink(int data){{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){int data;data=OPEN("BadSource_open.txt", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);CLOSE(data);{int data_copy=data;int data=data_copy;}}
static void main(){int * data;data=NULL;data=new int[100];{size_t i;for(i=0;i < 100;i++){data[i]=5;}}delete [] data;main_sink(&data);}void main_sink(void * void_data_ptr){int * * data_ptr=(int * *)void_data_ptr;int * data=(*data_ptr);}
static void main(){wchar_t * data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t dest[100];memmove(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));main_sink(&data);}void main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);free(data);}
static void main(){FILE * data;data=NULL;data=freopen("BadSource_freopen.txt","w+",stdin);{FILE * data_copy=data;FILE * data=data_copy;if (data!=NULL){fclose(data);}}}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data, L'A', 100-1);data[100-1]=L'\0';free(data);b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){}
static void main(){int * data;data=NULL;data=(int *)malloc(100*sizeof(int));free(data);}
static void main(){wchar_t * data;wchar_t data_buf[250]=L"PATH=";data=data_buf;wcscat(data, NEW_PATH);PUTENV(data);}
static void main_sink(){wchar_t * data=main_data;free(data);}static void main(){wchar_t * data;data=NULL;data=NULL;data=(wchar_t *)realloc(data, 100*sizeof(wchar_t));main_data=data;main_sink();}
void main_sink(wchar_t * * data);static void main(){wchar_t * data;data=new wchar_t[100];main_sink(&data);}void main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{wchar_t dest[50]=L"";size_t i, data_len;data_len=wcslen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printWLine(data);delete [] data;}}
static void main(){twoints * data;data=NULL;main_source(data);free(data);}void main_source(twoints * &data){data=NULL;data=(twoints *)realloc(data, 100*sizeof(twoints));}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){char data;data=' ';data=CHAR_MAX;b_main_sink(data);}void b_main_sink(char data){{char result=-1;if (data < CHAR_MAX){result=data+1;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){unsigned char data;data=' ';data=UCHAR_MAX;b_main_sink(data);}void b_main_sink(unsigned char data){c_main_sink(data);}void c_main_sink(unsigned char data){d_main_sink(data);}void d_main_sink(unsigned char data){{unsigned char result=-1;if (data < UCHAR_MAX){result=data+1;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");b_main_sink(data);}void b_main_sink(char * data){{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
static void main(){struct _twoints * data;data=NULL;{struct _twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);}main_sink(&data);}void main_sink(struct _twoints * * data_ptr){struct _twoints * data=*data_ptr;}
static void main(){FILE * data;data=freopen("BadSource_freopen.txt","w+",stdin);fclose(data);}
static void main(){twoints * data;twoints * &data_ref=data;data=new twoints[10];{twoints * data=data_ref;{int i;for(i=0;i<10;i++){data[i].a=i;data[i].b=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}delete [] data;}}
static void main(){long long * data;data=NULL;main_source(data);delete data;}void main_source(long long * &data){data=new long long;}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}main_sink(data);}void main_sink(int data){{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");func_ptr(data);}void b_main_sink(wchar_t * data){EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){int data;data=-1;data=5;{int result=data * 2;printIntLine(result);}}
static void main(){{if (putwc((wchar_t)L'A', stdout)==WEOF){printLine("putwc failed!");}}}
static void main(){wchar_t * data;data=new wchar_t[100];{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t dest[50]=L"";memmove(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);delete [] data;}}}
void _main_sink(char * data){{char src[100];memmove(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;_main_sink(data);}
static void main(){int * data;data=NULL;main_source(data);delete [] data;}void main_source(int * &data){data=new int[100];}
static void main(){char * data;data=NULL;data=(char *)malloc((10+1)*sizeof(char));{char * data_copy=data;char * data=data_copy;{char data_src[10+1]=SRC_STRING;memcpy(data, data_src, strlen(data_src)*sizeof(char));printLine(data);free(data);}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnvp(_P_WAIT, COMMAND_INT, args);}}
static void main(){unsigned char data;data=' ';data=5;b_main_sink(data);}void b_main_sink(unsigned char data){{unsigned char result=data-1;printHexUnsignedCharLine(result);}}
static void main_sink(char * data){{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");func_ptr(data);}
int * b_main_source(int * data);static void main(){int * data;data=b_main_source(data);if (data!=NULL){data[0]=5;printIntLine(data[0]);free(data);}}int * b_main_source(int * data){data=(int *)malloc(100);return data;}
void b_main_sink(FILE * data_array[]);static void main(){FILE * data;FILE * data_array[5];data=NULL;data=WFOPEN(L"file.txt", L"w+");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(FILE * data_array[]){FILE * data=data_array[2];if (data!=NULL){fclose(data);}}
static void main_sink(){int * data=_main_data;free(data);}static void main(){int * data;data=NULL;data=(int *)calloc(100, sizeof(int));data[0]=5;printIntLine(data[0]);_main_data=data;main_sink();}
static void main(){unsigned char data;data=' ';data=5;{unsigned char data_copy=data;unsigned char data=data_copy;{unsigned char result=data+1;printHexUnsignedCharLine(result);}}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_buf[100];data=data_buf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char dest[50]="";_snprintf(dest, strlen(data), "%s", data);printLine(data);}}
static void main(){FILE * data;_struct_type my_struct;data=fopen("GoodSource_fopen.txt", "w+");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){FILE * data=my_struct.a;fclose(data);}
static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");my_union.a=data;{wchar_t * data=my_union.b;main_vasink(data, data);}}
static void main(){unsigned int data;_struct_type my_struct;data=0;fscanf (stdin, "%u", &data);my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){unsigned int data=my_struct.a;{unsigned int result=-1;if (data < UINT_MAX){result=data+1;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static char * main_source(char * data){data=new char;return data;}static void main(){char * data;data=NULL;data=main_source(data);delete data;}
static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));{twoints * data_copy=data;twoints * data=data_copy;{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printStructLine(&data[0]);free(data);}}}}
static void main_sink(char * data){if (strncmp(PASSWORD, data, strlen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;main_sink(data);}
static void main(){int data;_union_type my_union;data=7;my_union.a=data;{int data=my_union.b;{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}}
static void main(){if(global_returns_t_or_f()){{HANDLE hMutex=NULL;hMutex=CreateMutexW(NULL, FALSE, NULL);if (hMutex==NULL){exit(1);}if (GetLastError()==ERROR_ALREADY_EXISTS){exit(1);}CloseHandle(hMutex);}}else{{HANDLE hMutex=NULL;hMutex=CreateMutexW(NULL, FALSE, NULL);if (hMutex==NULL){exit(1);}if (GetLastError()==ERROR_ALREADY_EXISTS){exit(1);}CloseHandle(hMutex);}}}
static void main(){if(global_returns_t_or_f()){{long long * data=(long long *)malloc(100*sizeof(long long));long long * tmp;data[0]=5L;printLongLongLine(data[0]);tmp=(long long *)realloc(data, (130000)*sizeof(long long));if (tmp!=NULL){data=tmp;data[0]=10L;printLongLongLine(data[0]);}free(data);}}else{{long long * data=(long long *)malloc(100*sizeof(long long));long long * tmp;data[0]=5L;printLongLongLine(data[0]);tmp=(long long *)realloc(data, (130000)*sizeof(long long));if (tmp!=NULL){data=tmp;data[0]=10L;printLongLongLine(data[0]);}free(data);}}}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(L"%s", args);va_end(args);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *, ...)=main_vasink;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}func_ptr(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;if (wcsncmp(PASSWORD, data, wcslen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){char * data;_union_type my_union;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;my_union.a=data;{char * data=my_union.b;{size_t i;char dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);}}}
static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=-1;data=20;func_ptr(data);}void b_main_sink(int data){{char * char_string;if (data > 0){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than 0");}}}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=NULL;{wchar_t mystring[]=L"mystring";data=wcsdup(mystring);}func_ptr(data);}void main_sink(wchar_t * data){free(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){{char * data=SRC_STR;char dst[100]="";char * end=strchr(data, '/');memmove(dst, data, sizeof(char)*(end-data));printLine(dst);}}
wchar_t * main_source(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=main_source(data);{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}wchar_t * main_source(wchar_t * data){{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}return data;}
static void main(){int * data;data=NULL;data=(int *)calloc(100, sizeof(int));free(data);}
static void main(){twointsclass * data;struct_type my_struct;data=NULL;data=NULL;data=(twointsclass *)realloc(data, 100*sizeof(twointsclass));my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){twointsclass * data=my_struct.a;free(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, data, args);va_end(args);printLine(dest);}}void c_main_sink(char * data){main_vasink(data, data);}
static void main(){wchar_t * data;data=NULL;main_source(data);}void main_source(wchar_t * &data){data=new wchar_t[100];delete [] data;}
static void main_sink(wchar_t * data){{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, L"%s", data);printWLine(dest);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}func_ptr(data);}
static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];{wchar_t dest[100];wmemset(dest, L'C', 100-1);memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);delete [] data;}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");{char * data_copy=data;char * data=data_copy;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"C:\\Windows\\System32\\winsrv.dll");b_main_sink(data);}void b_main_sink(wchar_t * data){{HMODULE hModule;hModule=LoadLibraryW(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}printLine(data);}}
static void main(){twoints * data;data=NULL;data=new twoints[100];main_sink(&data);}void main_sink(void * void_data_ptr){twoints * * data_ptr=(twoints * *)void_data_ptr;twoints * data=(*data_ptr);delete [] data;}
static void main(){int data;data=-1;data=5;{int result=data+1;printIntLine(result);}}
static void main_sink(twointsclass * data){delete data;}static void main(){twointsclass * data;void (*func_ptr) (twointsclass *)=main_sink;data=NULL;data=new twointsclass;func_ptr(data);}
static void main_sink(wchar_t * data){if (data!=NULL){wcscpy(data, L"Initialize");printWLine(data);free(data);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=(wchar_t *)calloc(100, sizeof(wchar_t));func_ptr(data);}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){char * data;union_type my_union;data=NULL;data=new char;my_union.a=data;{char * data=my_union.b;delete data;}}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;func_ptr(data);}void b_main_sink(char * data){{char dest[50]="";strncpy(dest, data, strlen(data));printLine(data);}}
static void main(){double * data;double data_uninit_array[10];data=data_uninit_array;if(global_returns_t_or_f()){}else{}if(global_returns_t_or_f()){{int i;for(i=0;i<10;i++){data[i]=(double)i;}}{int i;for(i=0;i<10;i++){printDoubleLine(data[i]);}}}else{{int i;for(i=0;i<10;i++){data[i]=(double)i;}}{int i;for(i=0;i<10;i++){printDoubleLine(data[i]);}}}}
static void main_sink(int data){{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}
static void main(){int * data;_union_type my_union;data=NULL;data=(int *)malloc(100*sizeof(int));data[0]=5;printIntLine(data[0]);my_union.a=data;{int * data=my_union.b;free(data);}}
void main_sink(twointsclass * data_array[]);static void main(){twointsclass * data;twointsclass * data_array[5];data=NULL;data=new twointsclass[100];data_array[2]=data;main_sink(data_array);}void main_sink(twointsclass * data_array[]){twointsclass * data=data_array[2];{twointsclass src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memmove(data, src, 100*sizeof(twointsclass));printIntLine(data[0].a);delete [] data;}}
static void main(){int * data;union_type my_union;{int * data_buf=new int[100];{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}my_union.a=data;{int * data=my_union.b;printIntLine(data[0]);delete [] data;}}
void b_main_sink(short data);static void main(){short data;data=0;data=100-1;b_main_sink(data);}void b_main_sink(short data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
void main_sink(void * void_data_ptr);static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}main_sink(&data);}void main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{size_t i;wchar_t dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);}}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{char src[100];strncpy(data, src, 100);data[100-1]='\0';printLine(data);}}
static void main(){char * data;_union_type my_union;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;my_union.a=data;{char * data=my_union.b;{char src[100];memcpy(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}}
static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, data);printWLine(dest);}}
static int main_source(int count){fscanf (stdin, "%d", &count);return count;}static void main(){int count;count=-1;count=main_source(count);{size_t i=0;FILE *file=NULL;const char *filename="output_good.txt";if (count > 0 && count <=20){file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
static void main_sink(char * data){}static void main(){char * data;data=NULL;{char data_goodbuf[100];data=data_goodbuf;strcpy(data, "a string");printLine(data);}main_sink(data);}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void b_main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnvp(_P_WAIT, COMMAND_INT, args);}}
static twointsclass * main_source(twointsclass * data){data=new twointsclass;data->a=0;data->b=0;printIntLine(data->a);printIntLine(data->b);return data;}static void main(){twointsclass * data;data=NULL;data=main_source(data);delete data;}
static void main(){int * data;data=NULL;data=NULL;data=(int *)realloc(data, 100*sizeof(int));data[0]=5;printIntLine(data[0]);b_main_sink(&data);}void b_main_sink(int * * data_ptr){int * data=*data_ptr;free(data);}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");my_union.a=data;{wchar_t * data=my_union.b;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnvp(_P_WAIT, COMMAND_INT, args);}}}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];data=NULL;data=(char *)malloc(100*sizeof(char));data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{char src[100];strncat(data, src, 100);printLine(data);free(data);}}
static void main(){int data;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}{int data_copy=data;int data=data_copy;{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;wcscat(data, L"*.*");}{wchar_t * data=*data_ptr2;EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}}
static void main(){int * data;int * &data_ref=data;data=NULL;data=new int[100];{size_t i;for(i=0;i < 100;i++){data[i]=5;}}{int * data=data_ref;printIntLine(data[0]);}}
void b_main_sink(void * void_data_ptr);static void main(){char * data;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{char dest[100];strncpy(dest, data, strlen(dest));dest[100-1]='\0';printLine(dest);}}
static void main_sink(){int data=_main_data;{int result=data-1;printIntLine(result);}}static void main(){int data;data=-1;data=5;_main_data=data;main_sink();}
static void main_source(int &data){fscanf (stdin, "%d", &data);}static void main(){int data;data=-1;main_source(data);{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){if(global_returns_t_or_f()){{char data_buf[100]="";char * data=data_buf;if (fscanf(stdin, "%99s\0", data)==EOF){printLine("fscanf failed!");exit(1);}}}else{{char data_buf[100]="";char * data=data_buf;if (fscanf(stdin, "%99s\0", data)==EOF){printLine("fscanf failed!");exit(1);}}}}
static void main(){char data;char data_array[5];data=' ';data=(char)rand();data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char data_array[]){char data=data_array[2];{char result=-1;if (data <=(char)sqrt((char)CHAR_MAX)){result=data * data;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}{char * data_copy=data;char * data=data_copy;{char src[100];strncpy(data, src, 100);data[100-1]='\0';printLine(data);}}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]="";data=data_buf;{char * data=*data_ptr1;strcat(data, "*.*");}{char * data=*data_ptr2;_spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){fwprintf(stdout, L"%s\n", data);}
void b_main_sink(short data);static void main(){short data;data=-1;data=CHAR_MAX-5;b_main_sink(data);}void b_main_sink(short data){{char c=(char)data;printHexCharLine(c);}}
int b_main_source(int data);static void main(){int data;data=-1;data=b_main_source(data);{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}int b_main_source(int data){data=100-1;return data;}
static void main(){int * data;data=NULL;main_source(data);delete data;}void main_source(int * &data){data=new int;}
static void main_sink(){int data=main_data;{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}static void main(){int data;data=-1;data=20;main_data=data;main_sink();}
static void main_sink(){wchar_t * data=main_data;delete data;}static void main(){wchar_t * data;data=NULL;data=new wchar_t;main_data=data;main_sink();}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char data_buf[100];data=data_buf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{char dest[50]="";size_t i, data_len;data_len=strlen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printLine(data);}}
static int main_source(int data){data=10;return data;}static void main(){int data;data=main_source(data);{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, L"%s", args);va_end(args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}{wchar_t * data_copy=data;wchar_t * data=data_copy;main_vasink(data, data);}}
static void main(){twoints * data;void (*func_ptr) (twoints *)=b_main_sink;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));data[0].a=0;data[0].b=0;printStructLine(&data[0]);func_ptr(data);}void b_main_sink(twoints * data){free(data);}
static void main_sink(){char * data=_main_data;fprintf(stdout, data);}static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");_main_data=data;main_sink();}
static void main(){wchar_t * data;data=NULL;data=NULL;data=(wchar_t *)realloc(data, 100*sizeof(wchar_t));wcscpy(data, L"A String");printWLine(data);free(data);}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;strcat(data, "*.*");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
static void main(){long long * data;data=NULL;data=(long long *)malloc(sizeof(*data));printLongLongLine(*data);free(data);}
static void main_sink(){int data=_main_data;{int result=-1;if (data < INT_MAX){result=data+1;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}_main_data=data;main_sink();}
void b_main_sink(_struct_type my_struct);static void main(){HANDLE data;_struct_type my_struct;data=INVALID_HANDLE_VALUE;data=CreateFile("BadSource_w32CreateFile.txt", (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){HANDLE data=my_struct.a;if (data!=INVALID_HANDLE_VALUE){CloseHandle(data);}}
static void main(){{char data_buf[100]="";char * data=data_buf;if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin)!=100-1){printLine("fread failed!");}}}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"C:\\Windows\\System32\\winsrv.dll");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{HMODULE hModule;hModule=LoadLibraryW(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
static void main(){wchar_t * data;data=NULL;if(global_returns_t_or_f()){data=(wchar_t *)malloc(100*sizeof(wchar_t));}else{data=(wchar_t *)malloc(100*sizeof(wchar_t));}{size_t i, dest_sz;wchar_t dest[100];wmemset(dest, L'C', 100-1);dest_sz=wcslen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);free(data);}}
int * b_main_source(int * data);static void main(){int * data;data=NULL;data=b_main_source(data);{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printIntLine(data[0]);free(data);}}}int * b_main_source(int * data){data=(int *)malloc(100*sizeof(int));return data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(char * data){if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{wchar_t src[100];_snwprintf(data, 100, L"%s", src);printWLine(data);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;{wchar_t dest[100];wmemset(dest, L'C', 100-1);memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, data);printWLine(dest);}}
static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]="";data=data_buf;data=PASSWORD;func_ptr(data);}void b_main_sink(char * data){if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;{char dest[100];memmove(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;{wchar_t dest[50]=L"";wcscat(dest, data);printWLine(data);}}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, data, args);va_end(args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);main_vasink(data, data);}wchar_t * b_main_source(wchar_t * data){wcscpy(data, L"fixedstringtest");return data;}
static void main(){if(global_returns_t_or_f()){{char * data;char * * pointer=(char * *)ALLOCA(sizeof(char *));data="string";{char * data=*pointer;printLine(data);}}}else{{char * data;char * * pointer=(char * *)ALLOCA(sizeof(char *));data="string";{char * data=*pointer;printLine(data);}}}}
static void main_sink(){wchar_t * data=_main_data;{wchar_t src[100];_snwprintf(data, 100, L"%s", src);printWLine(data);}}static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;_main_data=data;main_sink();}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");my_union.a=data;{wchar_t * data=my_union.b;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}}
static void main(){char data;char *data_ptr1=&data;char *data_ptr2=&data;data=' ';{char data=*data_ptr1;data=5;}{char data=*data_ptr2;{char result=data * data;printHexCharLine(result);}}}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");func_ptr(data);}void b_main_sink(char * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){int data;data=-1;data=20;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}
static void main(){wchar_t data;data=L'W';printf("%02lx\n", data);}
static char * main_source(char * data){{char * data_buf=(char *)malloc(100*sizeof(char));data=data_buf;}return data;}static void main(){char * data;data=main_source(data);printLine(data);free(data);}
static void main_sink(){short data=_main_data;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}static void main(){short data;data=0;data=100-1;_main_data=data;main_sink();}
void main_sink_b(long long * data);static void main(){long long * data;data=NULL;data=new long long[100];main_sink_b(data);}void main_sink_c(long long * data);void main_sink_b(long long * data){main_sink_c(data);}void main_sink_d(long long * data);void main_sink_c(long long * data){main_sink_d(data);}void main_sink_e(long long * data);void main_sink_d(long long * data){main_sink_e(data);}void main_sink_e(long long * data){{memcpy(data, src, 100*sizeof(long long));printLongLongLine(data[0]);delete [] data;}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
static void main_sink(wchar_t * data){{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");func_ptr(data);}
void main_sink_b(char * data);static void main(){char * data;data=NULL;data=new char[100];main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_d(char * data);void main_sink_c(char * data){main_sink_d(data);}void main_sink_e(char * data);void main_sink_d(char * data){main_sink_e(data);}void main_sink_e(char * data){{char dest[100];memset(dest, 'C', 100-1);memcpy(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);delete [] data;}}
static void main(){int data;_struct_type my_struct;data=-1;data=INT_MAX;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{int result=-1;if (data <=(int)sqrt((int)INT_MAX)){result=data * data;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){if(global_returns_t_or_f()){{wchar_t * key=L"TEST\\TestKey";HUSKEY hKey=HKEY_CURRENT_USER;if (SHRegCreateUSKeyW( key, KEY_WRITE, NULL, &hKey, SHREGSET_HKCU)!=ERROR_SUCCESS){printLine("Registry key could not be created");}else{printLine("Registry key created successfully");}}}else{{wchar_t * key=L"TEST\\TestKey";HUSKEY hKey=HKEY_CURRENT_USER;if (SHRegCreateUSKeyW( key, KEY_WRITE, NULL, &hKey, SHREGSET_HKCU)!=ERROR_SUCCESS){printLine("Registry key could not be created");}else{printLine("Registry key created successfully");}}}}
static void main(){{charvoid cv_struct;cv_struct.y=SRC_STR;printWLine((wchar_t *)cv_struct.y);memcpy(cv_struct.x, SRC_STR, sizeof(cv_struct.x));printWLine((wchar_t *)cv_struct.x);printWLine((wchar_t *)cv_struct.y);}}
static void main_sink(){wchar_t * data=_main_data;_wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_data=data;main_sink();}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{size_t i, dest_sz;wchar_t dest[100];wmemset(dest, L'C', 100-1);dest_sz=wcslen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);}}
static void main(){int data;data=-1;data=20;{int data_copy=data;int data=data_copy;{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;fwprintf(stdout, L"%s\n", data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main_sink(){int data=_main_data;{wchar_t data_buf[10]=L"AAAAAAAAA";if (data >=0){printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}static void main(){int data;data=7;_main_data=data;main_sink();}
static void main(){char * data;char data_buf[100]="";data=data_buf;if(global_returns_t_or_f()){strcpy(data, GOOD_OS_COMMAND);}else{strcpy(data, GOOD_OS_COMMAND);}{FILE *pipe;pipe=POPEN(data, "wb");if (pipe!=NULL) PCLOSE(pipe);}}
static void main(){char * data;char data_buf[250]="PATH=";data=data_buf;if(global_returns_t_or_f()){strcat(data, NEW_PATH);}else{strcat(data, NEW_PATH);}PUTENV(data);}
static void main(){long long * data;data=NULL;{long long tmp=5L;data=&tmp;}{long long * data_copy=data;long long * data=data_copy;printLongLongLine(*data);}}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));data[0]=L'\0';{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{size_t i;for (i=0;i < wcslen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}wchar_t * b_main_source(wchar_t * data){wcscat(data, L"*.*");return data;}
static void main(){char * data;data=NULL;{char mystring[]="mystring";data=strdup(mystring);printLine(data);}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){free(data);}
static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));data[0].a=0;data[0].b=0;printStructLine(&data[0]);b_main_sink(data);}void b_main_sink(twoints * data){free(data);}
static void main(){twointsclass * data;data=NULL;data=(twointsclass *)malloc(100*sizeof(twointsclass));{twointsclass * data_copy=data;twointsclass * data=data_copy;free(data);}}
void b_main_sink();static void main(){wchar_t * data;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));data=data_buf;}_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;printWLine(data);free(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
static void main(){int data;data=-1;data=100-1;{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}
static void main(){twointsclass * data;data=NULL;{twointsclass data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printIntLine(data[0].a);printIntLine(data[0].b);}main_sink_b(data);}void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_c(twointsclass * data){main_sink_d(data);}void main_sink_d(twointsclass * data){}
static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");system(data);}
static void main(){int data;int data_array[5];data=-1;data=5;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{int result=data * 2;printIntLine(result);}}
static void main(){char * data;_union_type my_union;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;my_union.a=data;{char * data=my_union.b;{char dest[100];memcpy(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}}
void b_main_sink();static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){long long * data;data=NULL;data=new long long[100];delete [] data;}
static void main(){char * data;_union_type my_union;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");my_union.a=data;{char * data=my_union.b;system(data);}}
static void main(){int data;data=7;{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main_sink(FILE * data){fclose(data);}static void main(){FILE * data;data=fopen("GoodSource_fopen.txt", "w+");main_sink(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));printWLine(data);free(data);}}
void b_main_sink(int data);static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=-1;data=7;func_ptr(data);}void b_main_sink(int data){printIntLine(100 % data);}
static void main(){char * data;char * data_array[5];char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){unsigned int data;data=0;data=5;b_main_sink(data);}void b_main_sink(unsigned int data){c_main_sink(data);}void c_main_sink(unsigned int data){d_main_sink(data);}void d_main_sink(unsigned int data){{unsigned int result=data * data;printUnsignedLine(result);}}
void main_sink();static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];_main_data=data;main_sink();}void main_sink(){twointsclass * data=_main_data;{twointsclass src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printIntLine(data[0].a);delete [] data;}}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
static void main(){list<int> data;list<int> &data_ref=data;data.push_back(100);data.push_back(200);{list<int> data=data_ref;{list<int>::iterator i;cout << "The list contains: ";for( i=data.begin();i!=data.end();i++){if (!*i){data.clear();}cout << " " << *i;}cout << endl;}}}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, "%s", args);va_end(args);}}static void main_sink(char * data){main_vasink(data, data);}static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}main_sink(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void b_main_sink(wchar_t * data){EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]="";data=data_buf;{char * data=*data_ptr1;strcat(data, "*.*");}{char * data=*data_ptr2;EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}}
static void main(){int data;data=b_main_source(data);{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}int b_main_source(int data){data=7;return data;}
static void main(){char * data;char * data_array[5];data=NULL;data=new char;delete data;data_array[2]=data;main_sink(data_array);}void main_sink(char * data_array[]){char * data=data_array[2];}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char data_buf[100];data=data_buf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{char dest[50]="";strcpy(dest, data);printLine(data);}}
static void main(){twointsclass * data;union_type my_union;data=NULL;data=NULL;data=(twointsclass *)realloc(data, 100*sizeof(twointsclass));my_union.a=data;{twointsclass * data=my_union.b;free(data);}}
static void main_sink(char * data){if (strncmp(PASSWORD, data, strlen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;main_sink(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){if (wcsncmp(PASSWORD, data, wcslen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){int * data;int data_uninit_array[10];data=data_uninit_array;if(global_returns_t_or_f()){{int i;for(i=0;i<10;i++){data[i]=i;}}}else{{int i;for(i=0;i<10;i++){data[i]=i;}}}if(global_returns_t_or_f()){{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}}else{{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}}}
void main_sink(wchar_t * data){{wchar_t dest[50]=L"";wcscat(dest, data);printWLine(data);delete [] data;}}static void main(){wchar_t * data;data=new wchar_t[100];main_sink(data);}
static void main_sink(int * data){free(data);}static void main(){int * data;void (*func_ptr) (int *)=main_sink;data=NULL;data=(int *)malloc(100*sizeof(int));func_ptr(data);}
static void main(){long long * data;long long * *data_ptr1=&data;long long * *data_ptr2=&data;{long long * data=*data_ptr1;{long long * data_buf=(long long *)malloc(100*sizeof(long long));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5L;}}data=data_buf;}}{long long * data=*data_ptr2;printLongLongLine(data[0]);free(data);}}
static void main(){char * data;data=NULL;if(global_returns_t_or_f()){data=(char *)malloc(100*sizeof(char));}else{data=(char *)malloc(100*sizeof(char));}if(global_returns_t_or_f()){free(data);}else{free(data);}}
static void main(){unsigned int data;data=0;fscanf (stdin, "%u", &data);{unsigned int result=-1;if (data < UINT_MAX){result=data+1;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
void _main_sink(char * data){{char data_src[10+1]=SRC_STRING;strcpy(data, data_src);printLine(data);free(data);}}static void main(){char * data;data=NULL;data=(char *)malloc((10+1)*sizeof(char));_main_sink(data);}
static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, L"%s", args);va_end(args);printWLine(dest);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}{wchar_t * data_copy=data;wchar_t * data=data_copy;main_vasink(data, data);}}
static void main_sink(int * data){delete [] data;}static void main(){int * data;void (*func_ptr) (int *)=main_sink;data=NULL;data=new int[100];func_ptr(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){wprintf(data);}
static char * main_source(char * data){strcat(data, "*.*");return data;}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);_spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;data=PASSWORD;}{wchar_t * data=*data_ptr2;if (wcsncmp(PASSWORD, data, wcslen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}}
static char * main_source(char * data){{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}return data;}static void main(){char * data;data=NULL;data=main_source(data);{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]='\0';printLine(data);}}
static void main(){unsigned char data;data=' ';data=b_main_source(data);{unsigned char result=-1;if (data < UCHAR_MAX){result=data+1;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}unsigned char b_main_source(unsigned char data){data=(unsigned char)rand();return data;}
static void main(){char * data;char * data_array[5];data=NULL;data=new char;data_array[2]=data;main_sink(data_array);}void main_sink(char * data_array[]){char * data=data_array[2];delete data;}
static void main(){wchar_t * data;data=NULL;data=new wchar_t;delete data;main_sink(&data);}void main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=100-1;}{int data=*data_ptr2;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}}
static void main(){long long * data;data=NULL;data=NULL;data=(long long *)realloc(data, 100*sizeof(long long));data[0]=5L;printLongLongLine(data[0]);b_main_sink(data);}void b_main_sink(long long * data){c_main_sink(data);}void c_main_sink(long long * data){d_main_sink(data);}void d_main_sink(long long * data){e_main_sink(data);}void e_main_sink(long long * data){free(data);}
static void main_sink(){int * data=main_data;}static void main(){int * data;data=NULL;int data_good;data=&data_good;printIntLine(*data);main_data=data;main_sink();}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{wchar_t dest[50]=L"";wcsncat(dest, data, wcslen(data));printWLine(data);free(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}{int i, n, v;if (swscanf(data, L"%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static int * main_source(int * data){data=NULL;data=(int *)realloc(data, 100*sizeof(int));data[0]=5;printIntLine(data[0]);return data;}static void main(){int * data;data=NULL;data=main_source(data);free(data);}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;func_ptr(data);}void b_main_sink(wchar_t * data){{wchar_t src[100];wcscpy(data, src);printWLine(data);}}
static void main(){twointsclass * data;data=(twointsclass *)malloc(10*sizeof(twointsclass));for(int i=0;i<10;i++){data[i].a=i;data[i].b=i;}for(int i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}
static void main(){{wchar_t data_buf[100]=L"";wchar_t * data=data_buf;printLine("Please enter a string: ");if (fgetws(data, 100, stdin)==NULL){printLine("fgetws failed!");exit(1);}printWLine(data);}}
char * b_main_source(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);_spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}char * b_main_source(char * data){strcat(data, "*.*");return data;}
static int main_source(int data){data=100-1;return data;}static void main(){int data;data=-1;data=main_source(data);{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main(){int data;_struct_type my_struct;data=-1;data=20;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}
static void main(){twointsclass * data;data=NULL;data=(twointsclass *)malloc(100*sizeof(twointsclass));main_sink(&data);}void main_sink(twointsclass * * data_ptr){twointsclass * data=*data_ptr;free(data);}
void b_main_sink(int * data);static void main(){int * data;data=(int *)calloc(100, sizeof(int));b_main_sink(data);}void c_main_sink(int * data);void b_main_sink(int * data){c_main_sink(data);}void c_main_sink(int * data){if (data!=NULL){data[0]=5;printIntLine(data[0]);free(data);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{char src[100];strcpy(data, src);printLine(data);}}
static void main(){twoints * data;struct_type my_struct;data=NULL;data=(twoints *)calloc(100, sizeof(twoints));my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){twoints * data=my_struct.a;free(data);}
void b_main_sink(bad_struct data);static void main(){bad_struct data;linked_list head={&head, &head};data.list.next=head.next;data.list.prev=&head;head.next=&data.list;head.next->prev=&data.list;b_main_sink(data);}void c_main_sink(bad_struct data);void b_main_sink(bad_struct data){c_main_sink(data);}void d_main_sink(bad_struct data);void c_main_sink(bad_struct data){d_main_sink(data);}void d_main_sink(bad_struct data){* */prev=data.list.prev;next=data.list.next;prev->next=next;next->prev=prev;}
static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");func_ptr(data);}void b_main_sink(char * data){printf(data);}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;data=NULL;{wchar_t * data=*data_ptr1;data=new wchar_t;delete data;}{wchar_t * data=*data_ptr2;}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_sink(&data);}void main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;delete [] data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}{int i, n, v;if (sscanf(data, "%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static void main_sink(){wchar_t * data=_main_data;}static void main(){wchar_t * data;data=NULL;{wchar_t data_goodbuf[100];data=data_goodbuf;wcscpy(data, L"A String");printWLine(data);}_main_data=data;main_sink();}
static void main(){double data;data=5.0;printDoubleLine(data);}
static void main(){int data;_struct_type my_struct;fscanf (stdin, "%d", &data);my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0 && data < 10){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}}
char * b_main_source(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnv(_P_WAIT, COMMAND_INT_PATH, args);}}char * b_main_source(char * data){strcat(data, "*.*");return data;}
void b_main_sink();static void main(){char * data;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{char src[100];strcpy(data, src);printLine(data);}}
void main_sink_b(char * data);static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_d(char * data);void main_sink_c(char * data){main_sink_d(data);}void main_sink_e(char * data);void main_sink_d(char * data){main_sink_e(data);}void main_sink_e(char * data){{char dest[100];memmove(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
static void main(){long long * data;data=NULL;data=new long long;{long long * data_copy=data;long long * data=data_copy;delete data;}}
static void main(){unsigned int data;data=0;fscanf (stdin, "%u", &data);_main_data=data;b_main_sink();}void b_main_sink(){unsigned int data=_main_data;{unsigned int result=-1;if (data < UINT_MAX){result=data+1;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){int * data;data=NULL;{int data_goodbuf[100];data=data_goodbuf;data[0]=5;printIntLine(data[0]);}main_sink_b(data);}void main_sink_b(int * data){main_sink_c(data);}void main_sink_c(int * data){main_sink_d(data);}void main_sink_d(int * data){main_sink_e(data);}void main_sink_e(int * data){}
void b_main_sink(char * data);static void main(){char * data;data=NULL;data=(char *)malloc((10+1)*sizeof(char));b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{char data_src[10+1]=SRC_STRING;strcpy(data, data_src);printLine(data);free(data);}}
static wchar_t * main_source(wchar_t * password){wcscpy(password, L"Password1234!");return password;}static void main(){wchar_t * password;wchar_t password_buf[100]=L"";password=password_buf;password=main_source(password);{HANDLE pHandle;wchar_t * username=L"User";wchar_t * domain=L"Domain";if (LogonUserW( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}
static void main_sink(int * data){delete data;}static void main(){int * data;void (*func_ptr) (int *)=main_sink;data=NULL;data=new int;func_ptr(data);}
void b_main_sink(int * data);static void main(){int * data;void (*func_ptr) (int *)=b_main_sink;{int * data_buf=(int *)malloc(100*sizeof(int));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}func_ptr(data);}void b_main_sink(int * data){printIntLine(data[0]);free(data);}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;wcscat(data, L"*.*");}{wchar_t * data=*data_ptr2;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[250]=L"PATH=";data=data_buf;data=b_main_source(data);PUTENV(data);}wchar_t * b_main_source(wchar_t * data){wcscat(data, NEW_PATH);return data;}
static void main(){void * data;data=NULL;data=WIDE_STRING;b_main_sink(&data);}void b_main_sink(void * * data_ptr){void * data=*data_ptr;{size_t data_len=wcslen((wchar_t *)data);void * data_dest=(void *)calloc(data_len+1, sizeof(wchar_t));memcpy(data_dest, data, (data_len+1)*sizeof(wchar_t));printWLine((wchar_t *)data_dest);free(data_dest);}}
static void main(){char * data;data=NULL;if(global_returns_t_or_f()){data=(char *)malloc(100*sizeof(char));memset(data, 'A', 100-1);data[100-1]='\0';free(data);}else{data=(char *)malloc(100*sizeof(char));memset(data, 'A', 100-1);data[100-1]='\0';free(data);}if(global_returns_t_or_f()){}else{}}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){int * data;data=NULL;{int data_goodbuf[100];data=data_goodbuf;data[0]=5;printIntLine(data[0]);}{int * data_copy=data;int * data=data_copy;}}
static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}free(data);b_main_sink(&data);}void b_main_sink(void * void_data_ptr){twoints * * data_ptr=(twoints * *)void_data_ptr;twoints * data=(*data_ptr);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t dest[50]=L"";wcsncat(dest, data, wcslen(data));printWLine(data);}}
static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}data_array[2]=data;b_main_sink(data_array);}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, L"%s", args);va_end(args);printWLine(dest);}}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];main_vasink(data, data);}
static void main(){int data;data=b_main_source(data);{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0 && data < 10){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}int b_main_source(int data){fscanf (stdin, "%d", &data);return data;}
static void main_sink(){int count=_main_data;{size_t i=0;FILE *file=NULL;const char *filename="output_bad.txt";file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}static void main(){int count;count=-1;count=20;_main_data=count;main_sink();}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{wchar_t data_src[10+1]=SRC_STRING;wcsncpy(data, data_src, wcslen(data_src));printWLine(data);free(data);}}
static void main_sink(){char * data=main_data;delete[] data;}static void main(){char * data;data=NULL;data=new char[100];strcpy(data, "A String");printLine(data);main_data=data;main_sink();}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t dest[50]=L"";wcsncat(dest, data, wcslen(data));printWLine(data);free(data);}}
void b_main_sink();static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));_main_data=data;b_main_sink();}void b_main_sink(){twoints * data=_main_data;{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printStructLine(&data[0]);free(data);}}}
static wchar_t * main_source(wchar_t * data){wcscpy(data, L"fixedstringtest");return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, data);printWLine(dest);}}
static void main_sink(char * data){if (strstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;data=PASSWORD;func_ptr(data);}
void _main_sink(int data){{char c=(char)data;printHexCharLine(c);}}static void main(){int data;data=-1;data=CHAR_MAX-5;_main_sink(data);}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, data, args);va_end(args);}}static void main_sink(wchar_t * data){main_vasink(data, data);}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");main_sink(data);}
static void main_sink(){unsigned int data=_main_data;{unsigned int result=-1;if (data <=(UINT_MAX/2)){result=data * 2;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}static void main(){unsigned int data;data=0;data=UINT_MAX;_main_data=data;main_sink();}
static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;{wchar_t dest[100];wmemset(dest, L'C', 100-1);memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){wchar_t * data;data=NULL;{wchar_t data_goodbuf[100];data=data_goodbuf;wcscpy(data, L"A String");printWLine(data);}}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;if(global_returns_t_or_f()){wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");}else{wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");}{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
static void main_sink(int count){{size_t i=0;for (i=0;i < (size_t)count;i++){printLine("Hello");}}}static void main(){int count;count=-1;count=20;main_sink(count);}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;{wchar_t * data=*data_ptr1;wcscat(data, L"*.*");}{wchar_t * data=*data_ptr2;{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}}
char * b_main_source(char * password);static void main(){char * password;char password_buf[100]="";password=password_buf;password=b_main_source(password);{HANDLE pHandle;char * username="User";char * domain="Domain";if (LogonUserA( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}char * b_main_source(char * password){{size_t password_len=0;fgets(password, 100, stdin);password_len=strlen(password);if (password_len > 0){password[password_len-1]='\0';}}return password;}
static void main(){int * data;int * data_array[5];data=NULL;data=new int;printIntLine(*data);data_array[2]=data;main_sink(data_array);}void main_sink(int * data_array[]){int * data=data_array[2];delete data;}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]="";data=data_buf;{char * data=*data_ptr1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}}{char * data=*data_ptr2;if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}}
static void main(){int data;data=-1;data=100-1;{int data_copy=data;int data=data_copy;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}}
void main_sink(struct_type my_struct);static void main(){long long * data;struct_type my_struct;data=NULL;data=new long long[100];my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){long long * data=my_struct.a;{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printLongLongLine(data[0]);delete [] data;}}}
static void main_source(twoints * &data){data=(twoints *)calloc(100, sizeof(twoints));}static void main(){twoints * data;data=NULL;main_source(data);free(data);}
static void main(){twoints * data;data=NULL;data=new twoints[100];data[0].a=0;data[0].b=0;printStructLine(&data[0]);main_sink(data);}void main_sink(twoints * data){delete[] data;}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);main_vasink(data, data);}char * b_main_source(char * data){strcpy(data, "fixedstringtest");return data;}
static void main(){wchar_t * data;wchar_t * &data_ref=data;data=NULL;data=new wchar_t;printHexCharLine((char)*data);{wchar_t * data=data_ref;delete data;}}
static void main(){twoints data;data.a=1;data.b=2;printIntLine(data.a);printIntLine(data.b);}
void main_sink(wchar_t * * data);static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_sink(&data);}void main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{wchar_t src[100];wcscat(data, src);printWLine(data);delete [] data;}}
void b_main_sink(char * * data);static void main(){char * data;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char dest[100];memmove(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));data[0]=L'\0';{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{size_t i;for (i=0;i < wcslen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}
static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");func_ptr(data);}void b_main_sink(char * data){{char dest[100]="";SNPRINTF(dest, 100-1, data);printLine(dest);}}
static void main_sink(twoints * data){}static void main(){twoints * data;data=NULL;data=new twoints;delete data;main_sink(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){twoints * data;data=NULL;main_source(data);delete data;}void main_source(twoints * &data){data=new twoints;}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "15");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{int i, n, v;if (sscanf(data, "%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main_source(twointsclass * &data){data=new twointsclass[100];}static void main(){twointsclass * data;data=NULL;main_source(data);delete [] data;}
static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;{char * data_copy=data;char * data=data_copy;{char src[100];strcat(data, src);printLine(data);}}}
static void main(){wchar_t * data;data=NULL;if(global_returns_t_or_f()){data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));}else{data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));}{wchar_t data_src[10+1]=SRC_STRING;wcscpy(data, data_src);printWLine(data);free(data);}}
static void main(){{HDESK hDesk;char * dtName="DesktopExample";hDesk=CreateDesktopA( dtName, NULL, NULL, 0, GENERIC_READ, NULL);if (hDesk==NULL){printLine("Desktop could not be created");}else{printLine("Desktop created successfully");CloseDesktop(hDesk);}}}
static void main_sink(int data){{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, data);printWLine(dest);}}wchar_t * b_main_source(wchar_t * data){wcscpy(data, L"fixedstringtest");return data;}
void b_main_sink();static void main(){char * data;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{char dest[100];memmove(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
static void main(){int * data;data=NULL;data=new int;printIntLine(*data);}
static void main(){twoints * data;data=NULL;data=NULL;data=(twoints *)realloc(data, 100*sizeof(twoints));data[0].a=0;data[0].b=0;printStructLine(&data[0]);b_main_sink(data);}void b_main_sink(twoints * data){c_main_sink(data);}void c_main_sink(twoints * data){d_main_sink(data);}void d_main_sink(twoints * data){free(data);}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char data_buf[100]="";data=data_buf;strcat(data, "*.*");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, data, args);va_end(args);}}void e_main_sink(wchar_t * data){main_vasink(data, data);}
static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");data_array[2]=data;b_main_sink(data_array);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, data, args);va_end(args);}}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];main_vasink(data, data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){int * data;void (*func_ptr) (int *)=main_sink;data=NULL;data=NULL;data=(int *)realloc(data, 100*sizeof(int));func_ptr(data);}void main_sink(int * data){free(data);}
static void main(){wchar_t * data;data=NULL;if(global_returns_t_or_f()){data=new wchar_t[100];}else{data=new wchar_t[100];}{wchar_t src[100];wcsncpy(data, src, 100);printWLine(data);delete [] data;}}
static void main(){unsigned char data;data=' ';fscanf (stdin, "%hc", &data);{unsigned char result=-1;if (data <=(UCHAR_MAX/2)){result=data * 2;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){fwprintf(stdout, L"%s\n", data);}
static void main(){int data;_union_type my_union;data=-1;data=5;my_union.a=data;{int data=my_union.b;{int result=data * 2;printIntLine(result);}}}
static void main(){twointsclass * data;data=(twointsclass *)ALLOCA(10*sizeof(twointsclass));for(int i=0;i<(10/2);i++){data[i].a=i;data[i].b=i;}main_sink(&data);}void main_sink(twointsclass * * data_ptr){twointsclass * data=*data_ptr;for(int i=0;i<10;i++){data[i].a=i;data[i].b=i;}for(int i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}
static void main_sink(){twoints * data=main_data;delete [] data;}static void main(){twoints * data;data=NULL;data=new twoints[100];main_data=data;main_sink();}
static void main_sink(short data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}static void main(){short data;void (*func_ptr) (short)=main_sink;data=0;data=100-1;func_ptr(data);}
static void main(){char * data;char * data_array[5];data=NULL;data=new char;data_array[2]=data;main_sink(data_array);}void main_sink(char * data_array[]){char * data=data_array[2];delete data;}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");my_union.a=data;{char * data=my_union.b;main_vasink(data, data);}}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;fwprintf(stdout, L"%s\n", data);}
static void main(){wchar_t * data;struct_type my_struct;data=NULL;data=new wchar_t[100];my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){wchar_t * data=my_struct.a;delete [] data;}
static void main(){int * data;data=NULL;data=new int[100];main_sink(&data);}void main_sink(int * * data_ptr){int * data=*data_ptr;delete [] data;}
void main_sink(int data);static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=20;func_ptr(data);}void main_sink(int data){{size_t a,i;int *b;b=(int*)new char[a];for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);delete [] b;}}
static void main(){{if (!ImpersonateSelf(SecurityImpersonation)){exit(1);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=L"P";b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink();static void main(){int * data;int data_badbuf[50];int data_goodbuf[100];data=data_goodbuf;_main_data=data;b_main_sink();}void b_main_sink(){int * data=_main_data;{memcpy(data, src, 100*sizeof(int));printIntLine(data[0]);}}
void _main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}static void main(){int data;data=-1;data=100-1;_main_sink(data);}
void b_main_sink(twoints * data);static void main(){twoints * data;void (*func_ptr) (twoints *)=b_main_sink;twoints data_badbuf[50];twoints data_goodbuf[100];data=data_goodbuf;func_ptr(data);}void b_main_sink(twoints * data){{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memmove(data, src, 100*sizeof(twoints));printStructLine(&data[0]);}}
static void main_sink(){twointsclass * data=main_data;delete data;}static void main(){twointsclass * data;data=NULL;data=new twointsclass;main_data=data;main_sink();}
static void main(){int data;fscanf (stdin, "%d", &data);b_main_sink(data);}void b_main_sink(int data){{char data_buf[10]="AAAAAAAAA";{printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
void _main_sink(char * data){EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_main_sink(data);}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf("%s", args);va_end(args);}}static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]="";data=data_buf;{char * data=*data_ptr1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}}{char * data=*data_ptr2;main_vasink(data, data);}}
static void main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnvp(_P_WAIT, COMMAND_INT, args);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");func_ptr(data);}
static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];wprintf(data);}
static void main(){{wchar_t data_buf[100]=L"";wchar_t * data=data_buf;if (fwscanf(stdin, L"%99s\0", data)==EOF){printLine("fwscanf failed!");}}}
void b_main_sink();static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "C:\\Windows\\System32\\winsrv.dll");_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{HMODULE hModule;hModule=LoadLibraryA(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
static void main(){wchar_t * data;data=NULL;{wchar_t mystring[]=L"mystring";data=wcsdup(mystring);}main_sink_b(data);}void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_d(wchar_t * data){free(data);}
static void main(){int data;data=-1;data=5;{int result=data * data;printIntLine(result);}}
char * b_main_source(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);system(data);}char * b_main_source(char * data){strcpy(data, GOOD_OS_COMMAND);return data;}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]="";data=data_buf;{char * data=*data_ptr1;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}}{char * data=*data_ptr2;{int i, n, v;if (sscanf(data, "%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char src[100];memmove(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}
static void main(){unsigned char data;void (*func_ptr) (unsigned char)=b_main_sink;data=' ';fscanf (stdin, "%hc", &data);func_ptr(data);}void b_main_sink(unsigned char data){{unsigned char result=-1;if (data <=(UCHAR_MAX/2)){result=data * 2;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){{if (_putws(L"string")==WEOF){printLine("puts failed!");}}}
static void main_sink(){int data=_main_data;{int result=data+1;printIntLine(result);}}static void main(){int data;data=-1;data=5;_main_data=data;main_sink();}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;wcscpy(data, L"fixedstringtest");}{wchar_t * data=*data_ptr2;{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, data);printWLine(dest);}}}
static void main_sink(int data){{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than the length of the source string or too large");}}}static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}main_sink(data);}
static void main(){wchar_t * data;data=new wchar_t[100];{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t dest[50]=L"";size_t i, data_len;data_len=wcslen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printWLine(data);delete [] data;}}}
static void main(){char * data;data=NULL;{char data_goodbuf[100];data=data_goodbuf;strcpy(data, "A String");printLine(data);}b_main_sink(data);}void b_main_sink(char * data){}
static unsigned int main_source(unsigned int data){data=(unsigned int)RAND32();return data;}static void main(){unsigned int data;data=0;data=main_source(data);{unsigned int result=-1;if (data <=(UINT_MAX/2)){result=data * 2;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main_sink(){char * data=_main_data;{char dest[50]="";memmove(dest, data, strlen(data)*sizeof(char));printLine(data);}}static void main(){char * data;char data_buf[100];data=data_buf;_main_data=data;main_sink();}
void _main_sink(wchar_t * data){{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");_main_sink(data);}
static void main(){unsigned char data;data=' ';data=5;b_main_sink(&data);}void b_main_sink(unsigned char * data_ptr){unsigned char data=*data_ptr;{unsigned char result=data * data;printHexUnsignedCharLine(result);}}
static void main_sink(long long * data){free(data);}static void main(){long long * data;data=NULL;data=NULL;data=(long long *)realloc(data, 100*sizeof(long long));data[0]=5L;printLongLongLine(data[0]);main_sink(data);}
void main_sink(twointsclass * data);static void main(){twointsclass * data;void (*func_ptr) (twointsclass *)=main_sink;data=NULL;data=new twointsclass[100];func_ptr(data);}void main_sink(twointsclass * data){{twointsclass src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printIntLine(data[0].a);delete [] data;}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){if (wcsncmp(PASSWORD, data, wcslen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}
static int main_source(int data){data=RAND32();return data;}static void main(){int data;data=-1;data=main_source(data);{int result=-1;if (data <=(int)sqrt((int)INT_MAX)){result=data * data;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}main_sink(&data);}void main_sink(int * data_ptr){int data=*data_ptr;{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)calloc(100, sizeof(wchar_t));main_sink(&data);}void main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);free(data);}
static void main(){long long * data;data=NULL;main_source(data);delete[] data;}void main_source(long long * &data){data=new long long[100];data[0]=5L;printLongLongLine(data[0]);}
static void main(){twoints * data;twoints * data_array[5];data=NULL;data=(twoints *)malloc(100*sizeof(twoints));data_array[2]=data;main_sink(data_array);}void main_sink(twoints * data_array[]){twoints * data=data_array[2];free(data);}
static void main(){twoints * data;data=new twoints[10];{int i;for(i=0;i<(10/2);i++){data[i].a=i;data[i].b=i;}}main_sink(&data);}void main_sink(twoints * * data_ptr){twoints * data=*data_ptr;{int i;for(i=0;i<10;i++){data[i].a=i;data[i].b=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}delete [] data;}
static void main_sink(){wchar_t * data=_main_data;{wchar_t dest[100];wcsncpy(dest, data, wcslen(dest));dest[100-1]=L'\0';printWLine(dest);}}static void main(){wchar_t * data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;_main_data=data;main_sink();}
static void main(){unsigned char data;data=' ';if(global_returns_t_or_f()){data=5;}else{data=5;}if(global_returns_t_or_f()){{unsigned char result=data-1;printHexUnsignedCharLine(result);}}else{{unsigned char result=data-1;printHexUnsignedCharLine(result);}}}
void _main_sink(char * data){{char dest[50]="";strncpy(dest, data, strlen(data));printLine(data);}}static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;_main_sink(data);}
char b_main_source(char data);static void main(){char data;data=' ';data=b_main_source(data);{char char_array[4];char_array[0]='x';char_array[1]=data;char_array[2]='z';char_array[3]='\0';printLine(char_array);}}char b_main_source(char data){data='a';return data;}
static void main(){wchar_t * data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;{wchar_t dest[100];wcscpy(dest, data);printWLine(dest);}}
static void main(){FILE * data;data=fopen("GoodSource_fopen.txt", "w+");{FILE * data_copy=data;FILE * data=data_copy;fclose(data);}}
static void main(){{if (RENAME(OLD_GOOD_FILE_NAME, L"newgoodfilename.txt")!=0){printLine("wrename failed!");}}}
static void main(){{if (fwrite((wchar_t *)L"string", sizeof(wchar_t), wcslen(L"string"), stdout)!=wcslen(L"string")){printLine("fwrite failed!");}}}
void main_sink(wchar_t * data){{wchar_t src[100];wcscpy(data, src);printWLine(data);delete [] data;}}static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_sink(data);}
static void main_source(wchar_t * &data){}static void main(){wchar_t * data;data=new wchar_t[100];main_source(data);{wchar_t dest[50]=L"";wcsncpy(dest, data, wcslen(data));printWLine(data);delete [] data;}}
static void main_sink(unsigned int data){{unsigned int result=-1;if (data <=(UINT_MAX/2)){result=data * 2;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}static void main(){unsigned int data;void (*func_ptr) (unsigned int)=main_sink;data=0;data=UINT_MAX;func_ptr(data);}
void b_main_sink(int data_array[]);static void main(){int data;int data_array[5];data=-1;data=100-1;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
static void main_sink(){wchar_t * data=main_data;}static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];delete [] data;main_data=data;main_sink();}
static void main(){wchar_t * password;password=L"";if(global_returns_t_or_f()){password=(wchar_t *)malloc(100*sizeof(wchar_t));if(!VirtualLock(password, 100*sizeof(wchar_t))){printLine("Memory could not be locked");exit(1);}wcscpy(password, L"Password1234!");}else{password=(wchar_t *)malloc(100*sizeof(wchar_t));if(!VirtualLock(password, 100*sizeof(wchar_t))){printLine("Memory could not be locked");exit(1);}wcscpy(password, L"Password1234!");}{HANDLE pHandle;wchar_t * username=L"User";wchar_t * domain=L"Domain";if (LogonUserW( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}
void b_main_sink();static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;data=new char[100];func_ptr(data);}void main_sink(char * data){delete [] data;}
void main_source(wchar_t * &data);static void main(){wchar_t * data;data=new wchar_t[100];main_source(data);{wchar_t dest[50]=L"";memmove(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);delete [] data;}}void main_source(wchar_t * &data){}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;if (wcsncmp(PASSWORD, data, wcslen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}
static int * main_source(int * data){data=(int *)malloc(100*sizeof(int));return data;}static void main(){int * data;data=NULL;data=main_source(data);free(data);}
static void main_sink(wchar_t * data){{wchar_t src[100];_snwprintf(data, 100, L"%s", src);printWLine(data);free(data);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));func_ptr(data);}
static void main(){int * data;struct_type my_struct;data=NULL;data=(int *)malloc(100*sizeof(int));my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){int * data=my_struct.a;free(data);}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100];data=data_buf;func_ptr(data);}void b_main_sink(char * data){{char dest[50]="";strncpy(dest, data, strlen(data));printLine(data);}}
static void main(){char * data;_union_type my_union;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}my_union.a=data;{char * data=my_union.b;{char dest[100];strncpy(dest, data, strlen(dest));dest[100-1]='\0';printLine(dest);}}}
static void main(){unsigned int data;data=0;data=5;b_main_sink(data);}void b_main_sink(unsigned int data){c_main_sink(data);}void c_main_sink(unsigned int data){d_main_sink(data);}void d_main_sink(unsigned int data){{unsigned int result=data-1;printUnsignedLine(result);}}
static void main(){{wchar_t * password=(wchar_t *)ALLOCA(100*sizeof(wchar_t));size_t password_len=0;HANDLE pHandle;wchar_t * username=L"User";wchar_t * domain=L"Domain";password[0]=L'\0';fgetws(password, 100, stdin);password_len=wcslen(password);if (password_len > 0){password[password_len-1]=L'\0';}if (LogonUserW( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}password_len=wcslen(password);SecureZeroMemory(password, password_len * sizeof(wchar_t));}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){wchar_t * data;data=NULL;if(global_returns_t_or_f()){data=new wchar_t[100];}else{data=new wchar_t[100];}if(global_returns_t_or_f()){delete [] data;}else{delete [] data;}}
static void main(){char * data;data=NULL;data=new char;main_sink_b(data);}void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){delete data;}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
static void main(){long long * data;data=NULL;data=main_source(data);}long long * main_source(long long * data){data=new long long[100];{size_t i;for(i=0;i < 100;i++){data[i]=5L;}}delete [] data;return data;}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");{wchar_t * data_copy=data;wchar_t * data=data_copy;{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}}
static void main(){unsigned char data;data=' ';if(global_returns_t_or_f()){data=(unsigned char)rand();}else{data=(unsigned char)rand();}if(global_returns_t_or_f()){{unsigned char result=-1;if (data <=(UCHAR_MAX/2)){result=data * 2;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}else{{unsigned char result=-1;if (data <=(UCHAR_MAX/2)){result=data * 2;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
void _main_sink(char * data){{char dest[50]="";strcat(dest, data);printLine(data);}}static void main(){char * data;char data_buf[100];data=data_buf;_main_sink(data);}
static void main(){twoints * data;data=NULL;{twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine(&data[0]);}b_main_sink(data);}void b_main_sink(twoints * data){c_main_sink(data);}void c_main_sink(twoints * data){}
static void main(){int data;data=-1;data=100-1;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
static void main(){int * data;int * &data_ref=data;data=NULL;data=new int[100];{int * data=data_ref;{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printIntLine(data[0]);delete [] data;}}}}
static void main(){char * data;data=NULL;{char data_goodbuf[100];data=data_goodbuf;strcpy(data, "A String");printLine(data);}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){}
static void main(){int data;_union_type my_union;data=-1;data=20;my_union.a=data;{int data=my_union.b;{size_t i;int *b;b=(int*)malloc(data * sizeof(int));for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);free(b);}}}
static void main(){long long * data;long long * data_array[5];data=NULL;data=new long long;data_array[2]=data;main_sink(data_array);}void main_sink(long long * data_array[]){long long * data=data_array[2];delete data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;fwprintf(stdout, L"%s\n", data);}
void _main_sink(char * data){{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");_main_sink(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t data_src[10+1]=SRC_STRING;wcsncpy(data, data_src, wcslen(data_src));printWLine(data);free(data);}}
static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));memset(data, 'A', 100-1);data[100-1]='\0';b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);printLine(data);}
static void main(){int data;data=-1;data=100-1;{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
static void main(){int data;int data_array[5];data=-1;data=5;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{int result=data-1;printIntLine(result);}}
static void main_sink(char * data){printLine(data);delete [] data;}static void main(){char * data;void (*func_ptr) (char *)=main_sink;{char * data_buf=new char[100];data=data_buf;}func_ptr(data);}
static void main(){unsigned int data;data=0;data=5;{unsigned int result=data * data;printUnsignedLine(result);}}
void _main_sink(twoints * data){printStructLine(&data[0]);free(data);}static void main(){twoints * data;{twoints * data_buf=(twoints *)malloc(100*sizeof(twoints));{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}_main_sink(data);}
void b_main_sink(char * data);static void main(){char * data;data=(char *)malloc(100*sizeof(char));b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{char dest[50]="";strncat(dest, data, strlen(data));printLine(data);free(data);}}
void b_main_sink();static void main(){short data;data=0;data=100-1;_main_data=data;b_main_sink();}void b_main_sink(){short data=_main_data;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
static void main_sink(int data){if (data!=-1){CLOSE(data);}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=OPEN("BadSource_open.txt", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);func_ptr(data);}
static void main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=100-1;func_ptr(data);}
static void main(){int data;data=-1;fscanf (stdin, "%d", &data);{int result=-1;if (data <=(INT_MAX/2)){result=data * 2;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main_sink(){int data=main_data;{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}static void main(){int data;data=-1;data=RAND32();main_data=data;main_sink();}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){e_main_sink(data);}static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, data, args);va_end(args);printLine(dest);}}void e_main_sink(char * data){main_vasink(data, data);}
static void main(){int data;data=7;{int data_copy=data;int data=data_copy;{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}}
static void main(){twoints * data;twoints * data_badbuf=(twoints *)ALLOCA(50*sizeof(twoints));twoints * data_goodbuf=(twoints *)ALLOCA(100*sizeof(twoints));data=data_goodbuf;{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memcpy(data, src, 100*sizeof(twoints));printStructLine(&data[0]);}}
static void main(){int data;data=b_main_source(data);{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}int b_main_source(int data){data=7;return data;}
static void main_sink(){void * data=_main_data;{size_t data_len=strlen((char *)data);void * data_dest=(void *)calloc(data_len+1, 1);memcpy(data_dest, data, (data_len+1));printLine((char *)data_dest);free(data_dest);}}static void main(){void * data;data=NULL;data=CHAR_STRING;_main_data=data;main_sink();}
static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));{memmove(data, src, 100*sizeof(long long));printLongLongLine(data[0]);free(data);}}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}wchar_t * b_main_source(wchar_t * data){wcscat(data, L"*.*");return data;}
char * b_main_source(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}char * b_main_source(char * data){strcat(data, "*.*");return data;}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void b_main_sink(char * data){_spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){{char data_buf[100]="";char * data=data_buf;printLine("Please enter a string: ");if (fgets(data, 100, stdin)==NULL){printLine("fgets failed!");exit(1);}printLine(data);}}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{char src[100];strncat(data, src, 100);printLine(data);}}
static void main(){short data;short *data_ptr1=&data;short *data_ptr2=&data;data=0;{short data=*data_ptr1;data=100-1;}{short data=*data_ptr2;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){unsigned char data;data=' ';data=5;b_main_sink(&data);}void b_main_sink(unsigned char * data_ptr){unsigned char data=*data_ptr;{unsigned char result=data * 2;printHexUnsignedCharLine(result);}}
static void main(){list<int> data;data.push_back(100);data.push_back(200);main_sink_b(data);}void main_sink_b(list<int> data){main_sink_c(data);}void main_sink_c(list<int> data){main_sink_d(data);}void main_sink_d(list<int> data){main_sink_e(data);}void main_sink_e(list<int> data){{list<int>::iterator i;cout << "The list contains: ";for( i=data.begin();i!=data.end();i++){if (!*i){data.clear();}cout << " " << *i;}cout << endl;}}
static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];fwprintf(stdout, L"%s\n", data);}
void _main_sink(wchar_t * data){{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");_main_sink(data);}
static void main(){int data;struct_type my_struct;data=-1;data=20;my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){int data=my_struct.a;{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}
static void main(){char * data;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}{char * data_copy=data;char * data=data_copy;{char dest[100];strncpy(dest, data, strlen(dest));dest[100-1]='\0';printLine(dest);}}}
wchar_t * main_source(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=main_source(data);{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]=L'\0';printWLine(data);}}wchar_t * main_source(wchar_t * data){{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}return data;}
static twoints * main_source(twoints * data){{twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine(&data[0]);}return data;}static void main(){twoints * data;data=NULL;data=main_source(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_t_or_f()){wcscpy(data, L"C:\\Windows\\System32\\winsrv.dll");}else{wcscpy(data, L"C:\\Windows\\System32\\winsrv.dll");}{HMODULE hModule;hModule=LoadLibraryW(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];{twointsclass * data_copy=data;twointsclass * data=data_copy;delete [] data;}}
static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;strcat(data, "*.*");my_union.a=data;{char * data=my_union.b;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnvp(_P_WAIT, COMMAND_INT, args);}}}
static void main_sink(twoints * data){{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memcpy(data, src, 100*sizeof(twoints));printStructLine(&data[0]);}}static void main(){twoints * data;void (*func_ptr) (twoints *)=main_sink;twoints data_badbuf[50];twoints data_goodbuf[100];data=data_goodbuf;func_ptr(data);}
void b_main_sink();static void main(){int data;data=-1;data=CHAR_MAX-5;_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{char c=(char)data;printHexCharLine(c);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){_spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
void main_source(char * &data);static void main(){char * data;data=NULL;main_source(data);{char dest[100];memset(dest, 'C', 100-1);memmove(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);delete [] data;}}void main_source(char * &data){data=new char[100];}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){system(data);}
static void main_sink(char * data){free(data);}static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;{char mystring[]="mystring";data=strdup(mystring);}func_ptr(data);}
static void main_sink(){char * data=_main_data;{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}printLine(data);}}static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;_main_data=data;main_sink();}
static wchar_t * main_source(wchar_t * data){{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}return data;}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, L"%s", args);va_end(args);printWLine(dest);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);main_vasink(data, data);}
static void main(){FILE * data;data=NULL;data=fopen("BadSource_fopen.txt", "w+");if(global_returns_t_or_f()){if (data!=NULL){fclose(data);}}else{if (data!=NULL){fclose(data);}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
void main_sink(struct_type my_struct);static void main(){char * data;struct_type my_struct;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){char * data=my_struct.a;{char src[100];memcpy(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}
void b_main_sink(void * void_data_ptr);static void main(){short data;data=0;data=100-1;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){short * data_ptr=(short *)void_data_ptr;short data=(*data_ptr);{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
static void main(){int data;int data_array[5];data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}data_array[2]=data;main_sink(data_array);}void main_sink(int data_array[]){int data=data_array[2];{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main_sink(char * data){_spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;strcat(data, "*.*");func_ptr(data);}
static void main(){int * data;data=NULL;data=main_source(data);}int * main_source(int * data){{int data_goodbuf[100];data=data_goodbuf;data[0]=5;printIntLine(data[0]);}return data;}
static void main_sink(){wchar_t * data=_main_data;{wchar_t dest[50]=L"";_snwprintf(dest, wcslen(data), L"%s", data);printWLine(data);}}static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;_main_data=data;main_sink();}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t src[100];wcsncpy(data, src, 100);data[100-1]=L'\0';printWLine(data);}}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;func_ptr(data);}void b_main_sink(char * data){{char src[100];strncpy(data, src, 100);data[100-1]='\0';printLine(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(&data);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(data, args);va_end(args);}}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);main_vasink(data, data);}
static void main_sink(){char * data=_main_data;free(data);}static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));strcpy(data, "A String");printLine(data);_main_data=data;main_sink();}
static void main(){char data;data=' ';if(global_returns_t_or_f()){data='a';}else{data='a';}{char char_array[4];char_array[0]='x';char_array[1]=data;char_array[2]='z';char_array[3]='\0';printLine(char_array);}}
void b_main_sink(void * void_data_ptr);static void main(){char * data;data=(char *)malloc(100*sizeof(char));b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{char dest[50]="";size_t i, data_len;data_len=strlen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printLine(data);free(data);}}
static void main(){short data;_union_type my_union;data=0;data=100-1;my_union.a=data;{short data=my_union.b;{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}{wchar_t * data_copy=data;wchar_t * data=data_copy;{int i, n, v;if (swscanf(data, L"%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}}
static void main(){int data;data=-1;data=5;{int result=data+1;printIntLine(result);}}
static void main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnvp(_P_WAIT, COMMAND_INT, args);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;strcat(data, "*.*");func_ptr(data);}
void b_main_sink(int data);static void main(){int data;data=-1;data=ASSERT_VALUE+1;b_main_sink(data);}void b_main_sink(int data){assert(data > ASSERT_VALUE);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);fwprintf(stdout, L"%s\n", data);}wchar_t * b_main_source(wchar_t * data){{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}return data;}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");func_ptr(data);}void b_main_sink(char * data){{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
static void main(){char * data;data=NULL;data=new char;delete data;}
void main_sink_b(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_sink_b(data);}void main_sink_c(wchar_t * data);void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){{wchar_t src[100];wcsncat(data, src, 100);printWLine(data);delete [] data;}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void main_source(wchar_t * &data);static void main(){wchar_t * data;data=NULL;main_source(data);{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}printWLine(data);delete [] data;}}void main_source(wchar_t * &data){data=new wchar_t[100];}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){wprintf(L"%s\n", data);}
void main_source(wchar_t * &data);static void main(){wchar_t * data;data=new wchar_t[100];main_source(data);{wchar_t dest[50]=L"";wcscat(dest, data);printWLine(data);delete [] data;}}void main_source(wchar_t * &data){}
static void main(){char * data;data=NULL;data=b_main_source(data);}char * b_main_source(char * data){{char data_goodbuf[100];data=data_goodbuf;strcpy(data, "a string");printLine(data);}return data;}
static void main(){char * data;union_type my_union;data=NULL;data=(char *)malloc(100*sizeof(char));my_union.a=data;{char * data=my_union.b;free(data);}}
void b_main_sink(int data);static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=-1;data=100-1;func_ptr(data);}void b_main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
void b_main_sink(int data);static void main(){int data;data=-1;data=7;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void d_main_sink(int data);void c_main_sink(int data){d_main_sink(data);}void e_main_sink(int data);void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){printIntLine(100 % data);}
static void main(){twoints * data;struct_type my_struct;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){twoints * data=my_struct.a;free(data);}
static void main(){float data;float *data_ptr1=&data;float *data_ptr2=&data;data=0.0F;{float data=*data_ptr1;data=7.0F;}{float data=*data_ptr2;printDoubleLine((double)(100.0/data));}}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
void _main_sink(char * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");_main_sink(data);}
static void main(){unsigned int data;data=0;fscanf (stdin, "%u", &data);{unsigned int data_copy=data;unsigned int data=data_copy;{unsigned int result=-1;if (data < UINT_MAX){result=data+1;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
static void main_sink(wchar_t * data){if (data!=NULL){wcscpy(data, L"Initialize");printWLine(data);free(data);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=(wchar_t *)realloc(data, 100);func_ptr(data);}
static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));free(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){printf(data);}
static void main_sink(){char * data=_main_data;if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;_main_data=data;main_sink();}
static void main_sink(){char * data=_main_data;_spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_main_data=data;main_sink();}
static void main(){int * data;data=NULL;if(global_returns_t_or_f()){data=new int;delete data;}else{data=new int;delete data;}if(global_returns_t_or_f()){}else{}}
static void main_sink(){int data=_main_data;{wchar_t data_buf[10]=L"AAAAAAAAA";if (data >=0){printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}static void main(){int data;data=7;_main_data=data;main_sink();}
static void main(){char * data;data=new char[100];{char dest[50]="";memmove(dest, data, strlen(data)*sizeof(char));printLine(data);delete [] data;}}
static wchar_t * main_source(wchar_t * data){return data;}static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;data=main_source(data);{size_t src_len;wchar_t src[100];src_len=wcslen(src);wcsncat(data, src, src_len);printWLine(data);}}
static void main(){twoints * data;twoints * *data_ptr1=&data;twoints * *data_ptr2=&data;data=NULL;{twoints * data=*data_ptr1;data=(twoints *)malloc(100*sizeof(twoints));}{twoints * data=*data_ptr2;free(data);}}
void _main_sink(char * data){PUTENV(data);}static void main(){char * data;char data_buf[250]="PATH=";data=data_buf;strcat(data, NEW_PATH);_main_sink(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);wprintf(data);}wchar_t * b_main_source(wchar_t * data){wcscpy(data, L"fixedstringtest");return data;}
static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, L"%s", args);va_end(args);printWLine(dest);}}static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}my_union.a=data;{wchar_t * data=my_union.b;main_vasink(data, data);}}
static int main_source(int data){data=5;return data;}static void main(){int data;data=-1;data=main_source(data);{int result=data-1;printIntLine(result);}}
static void main(){char * data;char * data_array[5];data=NULL;{char data_goodbuf[100];data=data_goodbuf;strcpy(data, "a string");printLine(data);}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];}
static void main(){char * data;char * &data_ref=data;data=NULL;data=new char[100];{char * data=data_ref;delete [] data;}}
static char * main_source(char * data){strcat(data, "*.*");return data;}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){int * data;int * *data_ptr1=&data;int * *data_ptr2=&data;{int * data=*data_ptr1;data=(int *)malloc(100);}{int * data=*data_ptr2;if (data!=NULL){data[0]=5;printIntLine(data[0]);free(data);}}}
static void main_sink(){wchar_t * data=_main_data;{wchar_t src[100];wcscpy(data, src);printWLine(data);}}static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;_main_data=data;main_sink();}
static void main(){long long * data;data=NULL;data=new long long[100];data[0]=5L;printLongLongLine(data[0]);delete[] data;}
static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, data, args);va_end(args);printLine(dest);}}static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);main_vasink(data, data);}char * b_main_source(char * data){strcpy(data, "fixedstringtest");return data;}
static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;if(global_returns_t_or_f()){strcat(data, "*.*");}else{strcat(data, "*.*");}system(data);}
static void main_sink(int data){{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}func_ptr(data);}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;data=NULL;data="Good";func_ptr(data);}void b_main_sink(char * data){printf("%s\n", data);}
static void main(){int * data;data=NULL;data=new int;main_sink(data);}void main_sink(int * data){delete data;}
static void main(){HANDLE data;data=INVALID_HANDLE_VALUE;data=CreateFile("BadSource_w32CreateFile.txt", (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (data!=INVALID_HANDLE_VALUE){CloseHandle(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}fwprintf(stdout, L"%s\n", data);}
void b_main_sink(char * data);static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{char src[100];strncpy(data, src, 100);printLine(data);}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}delete [] data;main_sink_b(data);}void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_c(twointsclass * data){main_sink_d(data);}void main_sink_d(twointsclass * data){}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[250]="PATH=";data=data_buf;{char * data=*data_ptr1;strcat(data, NEW_PATH);}{char * data=*data_ptr2;PUTENV(data);}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';{char * data=*data_ptr1;data=data_buf;}{char * data=*data_ptr2;{char src[100];memcpy(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}}
static void main(){{char * data;char string1[]=SRC_STR;char string2[]=SRC_STR;char * slashInString1;size_t indexOfSlashInString1;slashInString1=strchr(string1, '/');if (slashInString1==NULL){exit(1);}indexOfSlashInString1=(size_t)(slashInString1-string1);data=&(string1[indexOfSlashInString1+1]);printLine(data);}}
static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");{wchar_t * data_copy=data;wchar_t * data=data_copy;main_vasink(data, data);}}
static void main(){char data;data=' ';data=b_main_source(data);{char result=data * data;printHexCharLine(result);}}char b_main_source(char data){data=5;return data;}
static void main(){twoints * data;data=(twoints *)ALLOCA(10*sizeof(twoints));{int i;for(i=0;i<(10/2);i++){data[i].a=i;data[i].b=i;}}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){twoints * * data_ptr=(twoints * *)void_data_ptr;twoints * data=(*data_ptr);{int i;for(i=0;i<10;i++){data[i].a=i;data[i].b=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}}
static void main_vasinkg(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, L"%s", args);va_end(args);printWLine(dest);}}static void main_vasinkb(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");main_vasinkb(data, data);}
void b_main_sink();static void main(){int * data;data=NULL;{int tmp=5;data=&tmp;}_main_data=data;b_main_sink();}void b_main_sink(){int * data=_main_data;printIntLine(*data);}
static void main_sink(){wchar_t * data=_main_data;{wchar_t src[100];_snwprintf(data, 100, L"%s", src);printWLine(data);}}static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;_main_data=data;main_sink();}
static void main(){char * data;data=NULL;data=new char[100];delete [] data;}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t dest[100];wcsncpy(dest, data, wcslen(dest));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){int data;_struct_type my_struct;data=7;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main(){int data;data=-1;if(global_returns_t_or_f()){data=20;}else{data=20;}{size_t a,i;int *b;b=(int*)new char[a];for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);delete [] b;}}
static void main(){int * data;if(global_returns_t_or_f()){data=(int *)malloc(sizeof(int));}else{data=(int *)malloc(sizeof(int));}if(global_returns_t_or_f()){printIntLine(*data);}else{printIntLine(*data);}}
static void main(){int data;data=-1;if(global_returns_t_or_f()){fscanf (stdin, "%d", &data);}else{fscanf (stdin, "%d", &data);}if(global_returns_t_or_f()){{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}else{{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}}
static void main(){twointsclass * data;union_type my_union;data=NULL;data=new twointsclass;my_union.a=data;{twointsclass * data=my_union.b;delete data;}}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;if(global_returns_t_or_f()){wcscat(data, L"file.txt");}else{wcscat(data, L"file.txt");}{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main_sink(twointsclass * data){delete data;}static void main(){twointsclass * data;data=NULL;data=new twointsclass;main_sink(data);}
static void main(){char * data;data=NULL;char data_good;data=&data_good;printHexCharLine(*data);}
static void main(){wchar_t * data;_union_type my_union;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;my_union.a=data;{wchar_t * data=my_union.b;{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));printWLine(data);}}}
static int main_source(int data){{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}return data;}static void main(){int data;data=-1;data=main_source(data);{int result=-1;if (data < INT_MAX){result=data+1;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){wchar_t * data;data=NULL;data=NULL;data=(wchar_t *)realloc(data, 100*sizeof(wchar_t));main_sink_b(data);}void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_d(wchar_t * data){main_sink_e(data);}void main_sink_e(wchar_t * data){free(data);}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
static void main(){int data;data=-1;data=b_main_source(data);{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}int b_main_source(int data){{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}return data;}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t dest[100];memcpy(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
void b_main_sink(void * void_data_ptr);static void main(){int data;data=-1;data=100-1;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");{char * data_copy=data;char * data=data_copy;main_vasink(data, data);}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=NULL;{char * data=*data_ptr1;char data_good;data=&data_good;printHexCharLine(*data);}{char * data=*data_ptr2;}}
static long long * main_source(long long * data){data=(long long *)calloc(100, sizeof(long long));data[0]=5L;printLongLongLine(data[0]);return data;}static void main(){long long * data;data=NULL;data=main_source(data);free(data);}
static void main_sink(){int data=_main_data;{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}static void main(){int data;data=-1;data=20;_main_data=data;main_sink();}
static void main(){int data;data=-1;if(global_returns_t_or_f()){data=RAND32();}else{data=RAND32();}if(global_returns_t_or_f()){{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than the length of the source string or too large");}}}else{{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than the length of the source string or too large");}}}}
static void main(){int data;data=7;{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main_sink(){wchar_t * data=_main_data;{wchar_t dest[50]=L"";size_t i, data_len;data_len=wcslen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printWLine(data);free(data);}}static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));_main_data=data;main_sink();}
static void main(){unsigned int data;data=0;data=UINT_MAX;_main_data=data;b_main_sink();}void b_main_sink(){unsigned int data=_main_data;{unsigned int result=-1;if (data < UINT_MAX){result=data+1;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){wchar_t * data;union_type my_union;data=NULL;data=new wchar_t[100];my_union.a=data;{wchar_t * data=my_union.b;{wchar_t dest[100];wmemset(dest, L'C', 100-1);memmove(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);delete [] data;}}}
static void main(){int data;data=-1;data=20;{int data_copy=data;int data=data_copy;{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}}
static void main(){{char input[INPUT_SZ];if (fgets(input, INPUT_SZ, stdin)==NULL) return;printLine("This is the actual functionality.");}}
void b_main_sink(char * data);static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{char src[100];memmove(data, src, 100*sizeof(char));printLine(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_t_or_f()){wcscat(data, L"*.*");}else{wcscat(data, L"*.*");}_wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){wchar_t * data;_struct_type my_struct;data=NULL;{wchar_t data_goodbuf[100];data=data_goodbuf;wcscpy(data, L"A String");printWLine(data);}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;}
static void main_sink(unsigned char data){{unsigned char result=data+1;printHexUnsignedCharLine(result);}}static void main(){unsigned char data;data=' ';data=5;main_sink(data);}
static void main(){twoints * data;data=NULL;main_source(data);delete data;}void main_source(twoints * &data){data=new twoints;}
static void main_sink(char * data){{char dest[100]="";SNPRINTF(dest, 100-1, "%s", data);printLine(dest);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(&data);}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, "%s", args);va_end(args);}}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);main_vasink(data, data);}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");my_union.a=data;{wchar_t * data=my_union.b;fwprintf(stdout, data);}}
static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;if(global_returns_t_or_f()){strcat(data, "*.*");}else{strcat(data, "*.*");}{FILE *pipe;pipe=POPEN(data, "wb");if (pipe!=NULL) PCLOSE(pipe);}}
void main_sink(char * * data);static void main(){char * data;data=NULL;data=new char[100];main_sink(&data);}void main_sink(char * * data_ptr){char * data=*data_ptr;{char src[100];strncpy(data, src, 100);printLine(data);delete [] data;}}
static void main(){{char * filename;int fd;filename=tempnam(NULL, NULL);printLine(filename);fd=OPEN(filename, O_CREAT|O_EXCL, S_IREAD|S_IWRITE);if (fd!=-1){printLine("Temporary file was opened...now closing file");CLOSE(fd);}if (filename!=NULL){free(filename);}}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];main_sink(&data);}void main_sink(void * void_data_ptr){twointsclass * * data_ptr=(twointsclass * *)void_data_ptr;twointsclass * data=(*data_ptr);delete [] data;}
static void main(){int * data;data=NULL;data=(int *)malloc(100*sizeof(int));{size_t i;for(i=0;i < 100;i++){data[i]=5;}}free(data);b_main_sink(&data);}void b_main_sink(int * * data_ptr){int * data=*data_ptr;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, data, args);va_end(args);}}void e_main_sink(wchar_t * data){main_vasink(data, data);}
static void main(){long long * data;data=NULL;if(global_returns_t_or_f()){data=new long long[100];}else{data=new long long[100];}{memcpy(data, src, 100*sizeof(long long));printLongLongLine(data[0]);delete [] data;}}
static FILE * main_source(FILE * data){data=freopen("BadSource_freopen.txt","w+",stdin);fclose(data);return data;}static void main(){FILE * data;data=main_source(data);}
static void main(){int data;if(global_returns_t_or_f()){data=RAND32();}else{data=RAND32();}if(global_returns_t_or_f()){{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}else{{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}}
static void main_sink(){wchar_t * data=_main_data;{HMODULE hModule;hModule=LoadLibraryW(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"C:\\Windows\\System32\\winsrv.dll");_main_data=data;main_sink();}
static void main_sink(int data){{int result=-1;if (data <=(int)sqrt((int)INT_MAX)){result=data * data;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=RAND32();func_ptr(data);}
static void main(){twointsclass * data;data=NULL;data=(twointsclass *)malloc(100*sizeof(twointsclass));free(data);}
static void main_sink(){wchar_t * data=_main_data;_wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_data=data;main_sink();}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
static void main(){long long * data;data=NULL;data=new long long;main_sink_b(data);}void main_sink_b(long long * data){main_sink_c(data);}void main_sink_c(long long * data){main_sink_d(data);}void main_sink_d(long long * data){delete data;}
static void main(){twoints * data;twoints * data_array[5];data=NULL;data=NULL;data=(twoints *)realloc(data, 100*sizeof(twoints));data_array[2]=data;main_sink(data_array);}void main_sink(twoints * data_array[]){twoints * data=data_array[2];free(data);}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
static void main(){int * data;data=NULL;data=(int *)malloc(100*sizeof(int));main_sink(data);}void main_sink(int * data){free(data);}
static void main(){wchar_t * data;data=new wchar_t[100];{wchar_t dest[50]=L"";wcscat(dest, data);printWLine(data);delete [] data;}}
static void main(){short data;data=-1;if(global_returns_t_or_f()){data=CHAR_MAX-5;}else{data=CHAR_MAX-5;}{char c=(char)data;printHexCharLine(c);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, L"%s", args);va_end(args);}}void e_main_sink(wchar_t * data){main_vasink(data, data);}
static void main(){unsigned int data;_union_type my_union;data=0;data=(unsigned int)RAND32();my_union.a=data;{unsigned int data=my_union.b;{unsigned int result=-1;if (data <=(unsigned int)sqrt((unsigned int)UINT_MAX)){result=data * data;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{char src[100];strcpy(data, src);printLine(data);}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;main_sink_b(data);}void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_c(twointsclass * data){main_sink_d(data);}void main_sink_d(twointsclass * data){delete data;}
static void main(){struct _twoints * data;data=NULL;data=new struct _twoints[100];data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);{struct _twoints * data_copy=data;struct _twoints * data=data_copy;delete[] data;}}
static char * main_source(char * data){{char * data_buf=new char[100];data=data_buf;}return data;}static void main(){char * data;data=main_source(data);printLine(data);delete [] data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;func_ptr(data);}void b_main_sink(wchar_t * data){{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}
static void main(){if(global_returns_t_or_f()){{char * data=SRC_STR;char dst[100]="";char * end=strchr(data, '/');memcpy(dst, data, sizeof(char)*(end-data));printLine(dst);}}else{{char * data=SRC_STR;char dst[100]="";char * end=strchr(data, '/');memcpy(dst, data, sizeof(char)*(end-data));printLine(dst);}}}
void b_main_sink(char * data);static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{char dest[50]="";memcpy(dest, data, strlen(data)*sizeof(char));printLine(data);}}
static void main(){unsigned int data;data=0;data=5;b_main_sink(data);}void b_main_sink(unsigned int data){{unsigned int result=data-1;printUnsignedLine(result);}}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}my_union.a=data;{wchar_t * data=my_union.b;{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, L"%s", data);printWLine(dest);}}}
static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));{wchar_t dest[50]=L"";wcsncpy(dest, data, wcslen(data));printWLine(data);free(data);}}
static void main(){twoints * data;data=NULL;data=(twoints *)calloc(100, sizeof(twoints));main_sink_b(data);}void main_sink_b(twoints * data){main_sink_c(data);}void main_sink_c(twoints * data){main_sink_d(data);}void main_sink_d(twoints * data){free(data);}
static void main(){wchar_t * data;wchar_t * &data_ref=data;data=NULL;data=new wchar_t[100];{wchar_t * data=data_ref;delete [] data;}}
static void main(){int data;_union_type my_union;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}my_union.a=data;{int data=my_union.b;{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0 && data < 10){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}}
static void main_sink(){int data=_main_data;{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}static void main(){int data;data=7;_main_data=data;main_sink();}
static void main(){char data;data=' ';data=b_main_source(data);{char result=data-1;printHexCharLine(result);}}char b_main_source(char data){data=5;return data;}
static void main(){wchar_t * data;wchar_t * &data_ref=data;data=NULL;data=NULL;data=(wchar_t *)realloc(data, 100*sizeof(wchar_t));{wchar_t * data=data_ref;free(data);}}
static void main(){long long * data;_union_type my_union;data=NULL;data=(long long *)malloc(100*sizeof(long long));{size_t i;for(i=0;i < 100;i++){data[i]=5L;}}my_union.a=data;{long long * data=my_union.b;printLongLongLine(data[0]);}}
static void main(){if(global_returns_t_or_f()){{char data[150], dest[100];memset(data, 'A', 149);data[149]='\0';memcpy(dest, data, 100*sizeof(char));printLine(dest);}}else{{char data[150], dest[100];memset(data, 'A', 149);data[149]='\0';memcpy(dest, data, 100*sizeof(char));printLine(dest);}}}
static void main(){int * data;int * &data_ref=data;data=NULL;data=new int[100];{int * data=data_ref;delete [] data;}}
static void main(){twoints * data;data=NULL;data=main_source(data);free(data);}twoints * main_source(twoints * data){data=(twoints *)malloc(100*sizeof(twoints));return data;}
static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){printf(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));printWLine(data);}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_buf[100];data=data_buf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char dest[50]="";memmove(dest, data, strlen(data)*sizeof(char));printLine(data);}}
void b_main_sink(void * void_data_ptr);static void main(){twoints * data;twoints data_badbuf[50];twoints data_goodbuf[100];data=data_goodbuf;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){twoints * * data_ptr=(twoints * *)void_data_ptr;twoints * data=(*data_ptr);{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memcpy(data, src, 100*sizeof(twoints));printStructLine(&data[0]);}}
static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, data, args);va_end(args);printLine(dest);}}static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);main_vasink(data, data);}char * b_main_source(char * data){strcpy(data, "fixedstringtest");return data;}
static void main(){{if (fputs("string", stdout)==EOF){printLine("fputs failed!");}}}
static void main(){char * data;data=NULL;data=(char *)malloc((10+1)*sizeof(char));{char data_src[10+1]=SRC_STRING;memcpy(data, data_src, strlen(data_src)*sizeof(char));printLine(data);free(data);}}
static void main_sink(unsigned char data){{unsigned char result=data-1;printHexUnsignedCharLine(result);}}static void main(){unsigned char data;void (*func_ptr) (unsigned char)=main_sink;data=' ';data=5;func_ptr(data);}
void b_main_sink(char * data);static void main(){char * data;data=(char *)malloc(100*sizeof(char));b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{char dest[50]="";strncat(dest, data, strlen(data));printLine(data);free(data);}}
static void main(){char data;data=' ';data=5;{char result=data+1;printHexCharLine(result);}}
static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];if (wcsncmp(PASSWORD, data, wcslen(data))==0) printLine("Access granted");else printLine("Access denied!");}
void main_source(char * &data);static void main(){char * data;data=new char[100];main_source(data);{char dest[50]="";_snprintf(dest, strlen(data), "%s", data);printLine(data);delete [] data;}}void main_source(char * &data){}
static void main(){{char data;data=5;char * pointer=new char;{char data=*pointer;printHexCharLine(data);}delete pointer;}}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;_spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){char data;data=' ';data=(char)rand();b_main_sink(data);}void b_main_sink(char data){{char result=-1;if (data <=(CHAR_MAX/2)){result=data * 2;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
void main_sink_b(long long * data);static void main(){long long * data;data=NULL;data=new long long[100];main_sink_b(data);}void main_sink_c(long long * data);void main_sink_b(long long * data){main_sink_c(data);}void main_sink_d(long long * data);void main_sink_c(long long * data){main_sink_d(data);}void main_sink_d(long long * data){{memcpy(data, src, 100*sizeof(long long));printLongLongLine(data[0]);delete [] data;}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(wchar_t * data){wprintf(L"%s\n", data);}
void b_main_sink(short data);static void main(){short data;data=0;data=100-1;b_main_sink(data);}void c_main_sink(short data);void b_main_sink(short data){c_main_sink(data);}void d_main_sink(short data);void c_main_sink(short data){d_main_sink(data);}void d_main_sink(short data){{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
static void main(){int * data;data=NULL;data=new int;main_sink(&data);}void main_sink(void * void_data_ptr){int * * data_ptr=(int * *)void_data_ptr;int * data=(*data_ptr);delete data;}
static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){FILE * data;data=fopen("GoodSource_fopen.txt", "w+");b_main_sink(&data);}void b_main_sink(FILE * * data_ptr){FILE * data=*data_ptr;fclose(data);}
static void main(){int data;int &data_ref=data;data=-1;data=20;{int data=data_ref;{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, data);printWLine(dest);}}
static void main(){{char * pipeName="\\\\.\\pipe\\mypipe";HANDLE hPipe=INVALID_HANDLE_VALUE;hPipe=CreateNamedPipeA( pipeName, FILE_FLAG_FIRST_PIPE_INSTANCE, PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, BUFSIZE, BUFSIZE, NMPWAIT_USE_DEFAULT_WAIT, NULL);if (hPipe==INVALID_HANDLE_VALUE){exit(1);}if (GetLastError()==ERROR_ACCESS_DENIED){exit(1);}if (!ImpersonateNamedPipeClient(hPipe)){exit(1);}CloseHandle(hPipe);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main_sink(){short data=_main_data;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}static void main(){short data;data=0;data=100-1;_main_data=data;main_sink();}
void main_sink(char * data);static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}main_sink(data);}void main_sink(char * data){{char src[100];strcpy(data, src);printLine(data);}}
static void main(){wchar_t * data;data=NULL;{wchar_t data_goodbuf[100];data=data_goodbuf;wcscpy(data, L"A String");printWLine(data);}main_sink_b(data);}void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_d(wchar_t * data){}
static char * main_source(char * data){{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}return data;}static void main(){char * data;data=NULL;data=main_source(data);{char src[100];memmove(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}
static void main(){int data;struct_type my_struct;data=-1;data=10000;my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){int data=my_struct.a;{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");my_struct.a=data;b_main_sink(my_struct);}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;main_vasink(data, data);}
static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;if(global_returns_t_or_f()){}else{}{wchar_t dest[50]=L"";memmove(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);}}
static void main(){int count;count=-1;count=20;b_main_sink(count);}void b_main_sink(int count){c_main_sink(count);}void c_main_sink(int count){{size_t i=0;FILE *file=NULL;const char *filename="output_bad.txt";file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}
static void main_sink(){wchar_t * data=_main_data;_wsystem(data);}static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");_main_data=data;main_sink();}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
static void main(){unsigned int data;data=0;data=b_main_source(data);{unsigned int result=data-1;printUnsignedLine(result);}}unsigned int b_main_source(unsigned int data){data=5;return data;}
static void main(){twoints * data;_union_type my_union;data=(twoints *)malloc(100);my_union.a=data;{twoints * data=my_union.b;if (data!=NULL){data[0].a=1;data[0].b=1;printStructLine(&data[0]);free(data);}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){fprintf(stdout, data);}
static void main(){wchar_t * data;_union_type my_union;data=(wchar_t *)malloc(100*sizeof(wchar_t));my_union.a=data;{wchar_t * data=my_union.b;{wchar_t dest[50]=L"";memcpy(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);free(data);}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));data[0]=L'\0';{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{size_t i;for (i=0;i < wcslen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}
static void main(){int data;if(global_returns_t_or_f()){fscanf (stdin, "%d", &data);}else{fscanf (stdin, "%d", &data);}if(global_returns_t_or_f()){{char data_buf[10]="AAAAAAAAA";{printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}else{{char data_buf[10]="AAAAAAAAA";{printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}}
void _main_sink(wchar_t * data){{wchar_t data_src[10+1]=SRC_STRING;wcsncpy(data, data_src, wcslen(data_src));printWLine(data);free(data);}}static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));_main_sink(data);}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, data, args);va_end(args);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *, ...)=main_vasink;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");func_ptr(data);}
static void main(){int count;count=-1;count=20;b_main_sink(&count);}void b_main_sink(void * void_count_ptr){int * count_ptr=(int *)void_count_ptr;int count=(*count_ptr);{size_t i=0;for (i=0;i < (size_t)count;i++){printLine("Hello");}}}
static void main(){char * data;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}{char * data_copy=data;char * data=data_copy;{char src[100];memcpy(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}}
static void main(){{long l;l=0x10203040;* */l |=LONG_MIN;printIntLine(l);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;printf(data);}
static void main(){int count;count=-1;fscanf (stdin, "%d", &count);b_main_sink(&count);}void b_main_sink(void * void_count_ptr){int * count_ptr=(int *)void_count_ptr;int count=(*count_ptr);{size_t i=0;if (count > 0 && count <=20){for (i=0;i < (size_t)count;i++){printLine("Hello");}}}}
static void main(){long long * data;void (*func_ptr) (long long *)=b_main_sink;data=NULL;data=(long long *)malloc(100*sizeof(long long));{size_t i;for(i=0;i < 100;i++){data[i]=5L;}}free(data);func_ptr(data);}void b_main_sink(long long * data){}
static void main(){char * data;_union_type my_union;data=NULL;{char mystring[]="mystring";data=strdup(mystring);printLine(data);}my_union.a=data;{char * data=my_union.b;free(data);}}
static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));data[0].a=0;data[0].b=0;printStructLine(&data[0]);b_main_sink(&data);}void b_main_sink(void * void_data_ptr){twoints * * data_ptr=(twoints * *)void_data_ptr;twoints * data=(*data_ptr);free(data);}
static void main(){twoints * data;data=NULL;data=new twoints[100];delete [] data;}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];main_sink_b(data);}void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_c(twointsclass * data){delete [] data;}
static char * main_source(char * data){{char data_goodbuf[100];data=data_goodbuf;strcpy(data, "A String");printLine(data);}return data;}static void main(){char * data;data=NULL;data=main_source(data);}
static void main(){int * data;int * &data_ref=data;data=NULL;data=new int;{int * data=data_ref;delete data;}}
static void main_sink(char * data){if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;data=PASSWORD;func_ptr(data);}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];data=NULL;data=(char *)malloc((10+1)*sizeof(char));data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{char data_src[10+1]=SRC_STRING;strcpy(data, data_src);printLine(data);free(data);}}
void b_main_sink(char * data);static void main(){char * data;data=(char *)malloc(100*sizeof(char));data[0]='\0';{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}b_main_sink(data);}void b_main_sink(char * data){{size_t i;for (i=0;i < strlen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_t_or_f()){wcscat(data, L"*.*");}else{wcscat(data, L"*.*");}{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;data=(wchar_t *)malloc(100*sizeof(wchar_t));{wchar_t * data=*data_ptr1;}{wchar_t * data=*data_ptr2;{wchar_t dest[50]=L"";memcpy(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);free(data);}}}
static void main_sink(){char * data=main_data;{char src[100];strcpy(data, src);printLine(data);delete [] data;}}static void main(){char * data;data=NULL;data=new char[100];main_data=data;main_sink();}
int * b_main_source(int * data);static void main(){int * data;data=NULL;data=b_main_source(data);printIntLine(*data);}int * b_main_source(int * data){{int tmp=5;data=&tmp;}return data;}
static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, L"%s", args);va_end(args);printWLine(dest);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}main_vasink(data, data);}
static int main_source(int count){count=20;return count;}static void main(){int count;count=-1;count=main_source(count);{size_t i=0;for (i=0;i < (size_t)count;i++){printLine("Hello");}}}
static void main_sink(){twointsclass * data=main_data;}static void main(){twointsclass * data;data=NULL;data=new twointsclass;delete data;main_data=data;main_sink();}
static void main_source(twointsclass * &data){data=(twointsclass *)calloc(100, sizeof(twointsclass));}static void main(){twointsclass * data;data=NULL;main_source(data);free(data);}
void main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];data=new char[100];data_array[2]=data;main_sink(data_array);}void main_sink(char * data_array[]){char * data=data_array[2];{char dest[50]="";strcpy(dest, data);printLine(data);delete [] data;}}
void b_main_sink();static void main(){char * password;char password_buf[100]="";password=password_buf;{size_t password_len=0;fgets(password, 100, stdin);password_len=strlen(password);if (password_len > 0){password[password_len-1]='\0';}}_main_data=password;b_main_sink();}void b_main_sink(){char * password=_main_data;{HANDLE pHandle;char * username="User";char * domain="Domain";if (LogonUserA( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(data, args);va_end(args);}}static void main_sink(wchar_t * data){main_vasink(data, data);}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");main_sink(data);}
static void main(){int data;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0 && data < 10){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
void b_main_sink(twoints * data);static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));b_main_sink(data);}void c_main_sink(twoints * data);void b_main_sink(twoints * data){c_main_sink(data);}void d_main_sink(twoints * data);void c_main_sink(twoints * data){d_main_sink(data);}void e_main_sink(twoints * data);void d_main_sink(twoints * data){e_main_sink(data);}void e_main_sink(twoints * data){{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memmove(data, src, 100*sizeof(twoints));printStructLine(&data[0]);free(data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));strcpy(data, "A String");printLine(data);{char * data_copy=data;char * data=data_copy;free(data);}}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main_sink(){wchar_t * data=_main_data;EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_data=data;main_sink();}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;{wchar_t * data_copy=data;wchar_t * data=data_copy;if (wcsncmp(PASSWORD, data, wcslen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t dest[100];memmove(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){unsigned int data;void (*func_ptr) (unsigned int)=b_main_sink;data=0;data=5;func_ptr(data);}void b_main_sink(unsigned int data){{unsigned int result=data * data;printUnsignedLine(result);}}
static void main(){twoints * data;data=NULL;data=NULL;data=(twoints *)realloc(data, 100*sizeof(twoints));main_sink_b(data);}void main_sink_b(twoints * data){main_sink_c(data);}void main_sink_c(twoints * data){main_sink_d(data);}void main_sink_d(twoints * data){free(data);}
static void main(){long long * data;long long * data_array[5];data=NULL;data=(long long *)malloc(100*sizeof(long long));data_array[2]=data;main_sink(data_array);}void main_sink(long long * data_array[]){long long * data=data_array[2];free(data);}
static void main_sink(){unsigned int data=_main_data;{unsigned int result=data * data;printUnsignedLine(result);}}static void main(){unsigned int data;data=0;data=5;_main_data=data;main_sink();}
static void main(){char data;_struct_type my_struct;data=' ';data=(char)rand();my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char data=my_struct.a;{char result=-1;if (data <=(char)sqrt((char)CHAR_MAX)){result=data * data;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");{char * data_copy=data;char * data=data_copy;{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}}
static void main_sink(wchar_t * data){fwprintf(stdout, data);}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");main_sink(data);}
void b_main_sink();static void main(){twoints * data;data=(twoints *)calloc(100, sizeof(twoints));_bad_data_for_good_sink=data;b_main_sink();}void b_main_sink(){twoints * data=_bad_data_for_good_sink;if (data!=NULL){data[0].a=1;data[0].b=1;printStructLine(&data[0]);free(data);}}
static void main(){int data;data=10;b_main_sink(data);}void b_main_sink(int data){{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0 && data < 10){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main_sink(){wchar_t * data=_main_data;}static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data, L'A', 100-1);data[100-1]=L'\0';free(data);_main_data=data;main_sink();}
static void main(){twoints * data;data=NULL;data=new twoints;{twoints * data_copy=data;twoints * data=data_copy;delete data;}}
void b_main_sink(long long * data);static void main(){long long * data;void (*func_ptr) (long long *)=b_main_sink;{long long * data_buf=(long long *)malloc(100*sizeof(long long));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5L;}}data=data_buf;}func_ptr(data);}void b_main_sink(long long * data){printLongLongLine(data[0]);free(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;fwprintf(stdout, data);}
static void main_sink(int * data){if (data!=NULL){data[0]=5;printIntLine(data[0]);free(data);}}static void main(){int * data;void (*func_ptr) (int *)=main_sink;data=(int *)calloc(100, sizeof(int));func_ptr(data);}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));{char * data=*data_ptr1;data=data_goodbuf;}{char * data=*data_ptr2;{char dest[100];memset(dest, 'C', 100-1);memcpy(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);}}}
static void main_sink(long long * data){}static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));{size_t i;for(i=0;i < 100;i++){data[i]=5L;}}free(data);main_sink(data);}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;if (wcsstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));if(global_returns_t_or_f()){}else{}{wchar_t dest[50]=L"";memcpy(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);free(data);}}
static void main(){long long data;data=5L;printLongLongLine(data);data=10L;printLongLongLine(data);}
static void main(){int data;_struct_type my_struct;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){int data;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
void b_main_sink(int data);static void main(){int data;data=-1;data=100-1;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void d_main_sink(int data);void c_main_sink(int data){d_main_sink(data);}void e_main_sink(int data);void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}
static void main(){unsigned int data;data=0;data=5;b_main_sink(data);}void b_main_sink(unsigned int data){c_main_sink(data);}void c_main_sink(unsigned int data){d_main_sink(data);}void d_main_sink(unsigned int data){e_main_sink(data);}void e_main_sink(unsigned int data){{unsigned int result=data * data;printUnsignedLine(result);}}
static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));{char * data_copy=data;char * data=data_copy;free(data);}}
static void main(){int data;data=-1;data=20;_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static int main_source(int data){data=20;return data;}static void main(){int data;data=-1;data=main_source(data);{size_t a,i;int *b;b=(int*)new char[a];for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);delete [] b;}}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{char src[100];strcpy(data, src);printLine(data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;if(global_returns_t_or_f()){data=PASSWORD;}else{data=PASSWORD;}if(global_returns_t_or_f()){if (strstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}else{if (strstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}}
static void main(){int * data;data=NULL;data=(int *)malloc(100*sizeof(int));main_sink(data);}void main_sink(int * data){free(data);}
void b_main_sink(long long * data);static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));b_main_sink(data);}void c_main_sink(long long * data);void b_main_sink(long long * data){c_main_sink(data);}void c_main_sink(long long * data){{memcpy(data, src, 100*sizeof(long long));printLongLongLine(data[0]);free(data);}}
void b_main_sink();static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{wchar_t dest[100];wcscpy(dest, data);printWLine(dest);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");_main_data=data;b_main_sink();}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, data, args);va_end(args);}}void b_main_sink(){wchar_t * data=_main_data;main_vasink(data, data);}
static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;strcpy(data, "15");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{int i, n, v;if (sscanf(data, "%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, data, args);va_end(args);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *, ...)=main_vasink;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");func_ptr(data);}
static void main(){unsigned int data;data=0;data=5;{unsigned int data_copy=data;unsigned int data=data_copy;{unsigned int result=data * data;printUnsignedLine(result);}}}
void b_main_sink(char * * password);static void main(){char * password;char password_buf[100]="";password=password_buf;{size_t password_len=0;fgets(password, 100, stdin);password_len=strlen(password);if (password_len > 0){password[password_len-1]='\0';}}b_main_sink(&password);}void b_main_sink(char * * password_ptr){char * password=*password_ptr;{HANDLE pHandle;char * username="User";char * domain="Domain";if (LogonUserA( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));main_sink_b(data);}void main_sink_b(twoints * data){main_sink_c(data);}void main_sink_c(twoints * data){main_sink_d(data);}void main_sink_d(twoints * data){free(data);}
static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t dest[50]=L"";size_t i, data_len;data_len=wcslen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printWLine(data);}}}
void _main_sink(wchar_t * data){{wchar_t dest[50]=L"";wcsncat(dest, data, wcslen(data));printWLine(data);}}static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;_main_sink(data);}
static char * main_source(char * data){strcat(data, "*.*");return data;}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);_spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static HANDLE main_source(HANDLE data){data=CreateFile("GoodSource_w32CreateFile.txt", (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);return data;}static void main(){HANDLE data;data=main_source(data);CloseHandle(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(data);}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}void b_main_sink(char * data){main_vasink(data, data);}
void main_sink_b(char * data);static void main(){char * data;data=NULL;data=new char[100];main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_d(char * data);void main_sink_c(char * data){main_sink_d(data);}void main_sink_d(char * data){{char dest[100];memset(dest, 'C', 100-1);memcpy(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);delete [] data;}}
static void main(){wchar_t * data;wchar_t * &data_ref=data;data=NULL;data=new wchar_t;{wchar_t * data=data_ref;delete data;}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;{wchar_t * data=*data_ptr1;wcscat(data, L"file.txt");}{wchar_t * data=*data_ptr2;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';{char * data=*data_ptr1;data=data_buf;}{char * data=*data_ptr2;{char src[100];strcpy(data, src);printLine(data);}}}
void _main_sink(char * cryptokey){{HCRYPTPROV cryptoprov;HCRYPTKEY key;HCRYPTHASH hash;DWORD toBeEncryptedLen=strlen(toBeEncrypted)*sizeof(char);if(!CryptAcquireContext(&cryptoprov, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, 0)){if(!CryptAcquireContext(&cryptoprov, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET)){printLine("Error in acquiring cryptographic context");exit(1);}}if(!CryptCreateHash(cryptoprov, CALG_SHA1, 0, 0, &hash)){printLine("Error in creating hash");exit(1);}if(!CryptHashData(hash, (BYTE *) cryptokey, strlen(cryptokey)*sizeof(char), 0)){printLine("Error in hashing cryptokey");exit(1);}if(!CryptDeriveKey(cryptoprov, CALG_3DES, hash, 0, &key)){printLine("Error in CryptDeriveKey");exit(1);}if(!CryptEncrypt(key, (HCRYPTHASH)NULL, 1, 0, (BYTE *)toBeEncrypted, &toBeEncryptedLen, sizeof(toBeEncrypted))){printLine("Error in CryptEncryptData");exit(1);}printLine(toBeEncrypted);}}static void main(){char * cryptokey;char cryptokey_buf[100]="";cryptokey=cryptokey_buf;{size_t cryptokey_len=strlen(cryptokey);if(100-cryptokey_len > 1){fgets(cryptokey+cryptokey_len, (int)(100-cryptokey_len), stdin);cryptokey_len=strlen(cryptokey);if (cryptokey_len > 0){cryptokey[cryptokey_len-1]='\0';}}}_main_sink(cryptokey);}
static void main(){long long * data;data=NULL;main_source(data);free(data);}void main_source(long long * &data){data=(long long *)calloc(100, sizeof(long long));}
static void main(){struct _twoints * data;data=NULL;data=(struct _twoints *)calloc(100, sizeof(struct _twoints));data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);_main_data=data;b_main_sink();}void b_main_sink(){struct _twoints * data=_main_data;free(data);}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));data[0]=L'\0';data=b_main_source(data);{size_t i;for (i=0;i < wcslen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}wchar_t * b_main_source(wchar_t * data){wcscpy(data, BAD_SRC_FIXED);return data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_t_or_f()){{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}}else{{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}}if(global_returns_t_or_f()){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}else{if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t dest[100];wcsncpy(dest, data, wcslen(dest));dest[100-1]=L'\0';printWLine(dest);}}
void main_sink(char * data);static void main(){char * data;data=NULL;data=new char[100];main_sink(data);}void main_sink(char * data){{char src[100];memmove(data, src, 100*sizeof(char));printLine(data);delete [] data;}}
void main_sink_b(wchar_t * data);static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}main_sink_b(data);}void main_sink_c(wchar_t * data);void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}
static void main_sink(char * data){printLine(data);free(data);}static void main(){char * data;void (*func_ptr) (char *)=main_sink;{char * data_buf=(char *)malloc(100*sizeof(char));data=data_buf;}func_ptr(data);}
static void main_sink(wchar_t * data){delete [] data;}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=NULL;data=new wchar_t[100];func_ptr(data);}
static void main(){int data;data=-1;data=20;{int data_copy=data;int data=data_copy;{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}}
static void main_sink(){long long * data=_main_data;{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printLongLongLine(data[0]);}}}static void main(){long long * data;long long data_badbuf[50];long long data_goodbuf[100];data=data_goodbuf;_main_data=data;main_sink();}
void main_source(wchar_t * &data);static void main(){wchar_t * data;data=NULL;main_source(data);{wchar_t src[100];wcscpy(data, src);printWLine(data);}}void main_source(wchar_t * &data){{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}}
static void main(){{if (fwrite((char *)"string", sizeof(char), strlen("string"), stdout)!=strlen("string")){printLine("fwrite failed!");}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t dest[50]=L"";wcscpy(dest, data);printWLine(data);free(data);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{wchar_t dest[100];wcsncpy(dest, data, wcslen(dest));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){twoints * data;data=NULL;if(global_returns_t_or_f()){data=(twoints *)malloc(100*sizeof(twoints));}else{data=(twoints *)malloc(100*sizeof(twoints));}if(global_returns_t_or_f()){free(data);}else{free(data);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");b_main_sink(data);}void b_main_sink(wchar_t * data){{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
static void main(){char * data;data=(char *)malloc(100*sizeof(char));{char dest[50]="";_snprintf(dest, strlen(data), "%s", data);printLine(data);free(data);}}
static void main(){int data;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}{int data_copy=data;int data=data_copy;{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=b_main_source(data);{wchar_t dest[100];memmove(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}wchar_t * b_main_source(wchar_t * data){{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}return data;}
static void main(){int data;struct_type my_struct;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){int data=my_struct.a;{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){wchar_t * data;wchar_t * &data_ref=data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));{wchar_t * data=data_ref;free(data);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, GOOD_OS_COMMAND);b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){system(data);}
static char main_source(char data){fscanf (stdin, "%c", &data);return data;}static void main(){char data;data=' ';data=main_source(data);{char result=-1;if (data <=(CHAR_MAX/2)){result=data * 2;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}wchar_t * b_main_source(wchar_t * data){wcscpy(data, GOOD_OS_COMMAND);return data;}
static void main(){char * data;_union_type my_union;data=NULL;data=(char *)malloc(100*sizeof(char));my_union.a=data;{char * data=my_union.b;{char src[100];strcat(data, src);printLine(data);free(data);}}}
static void main(){int * data;int data_badbuf[50];int data_goodbuf[100];data=data_goodbuf;{memcpy(data, src, 100*sizeof(int));printIntLine(data[0]);}}
void b_main_sink(float * data);static void main(){float data;data=0.0F;data=7.0F;b_main_sink(&data);}void b_main_sink(float * data_ptr){float data=*data_ptr;printDoubleLine((double)(100.0/data));}
static void main(){twoints * data;twoints * *data_ptr1=&data;twoints * *data_ptr2=&data;data=NULL;{twoints * data=*data_ptr1;{twoints tmp;tmp.a=0;tmp.b=0;data=&tmp;}}{twoints * data=*data_ptr2;printStructLine(data);}}
char * b_main_source(char * data);static void main(){char * data;data=(char *)malloc(100*sizeof(char));data[0]='\0';data=b_main_source(data);{size_t i;for (i=0;i < strlen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}char * b_main_source(char * data){{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}return data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}printWLine(data);}}
static void main_vasinkg(char * data, ...){{va_list args;va_start(args, data);vprintf("%s", args);va_end(args);}}static void main_vasinkb(char * data, ...){{va_list args;va_start(args, data);vprintf(data, args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;if(global_returns_f()){strcpy(data, "fixedstringtest");}else{strcpy(data, "fixedstringtest");}if(global_returns_t()){main_vasinkb(data, data);}else{main_vasinkb(data, data);}}
static void main_sink(wchar_t * data){{wchar_t dest[100];wmemset(dest, L'C', 100-1);memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);free(data);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));func_ptr(data);}
static void main(){if(global_returns_t_or_f()){{char * data=(char *)malloc(100*sizeof(char));char * tmp;strcpy(data, "A String");printLine(data);tmp=(char *)realloc(data, (130000)*sizeof(char));if (tmp!=NULL){data=tmp;strcpy(data, "New String");printLine(data);}free(data);}}else{{char * data=(char *)malloc(100*sizeof(char));char * tmp;strcpy(data, "A String");printLine(data);tmp=(char *)realloc(data, (130000)*sizeof(char));if (tmp!=NULL){data=tmp;strcpy(data, "New String");printLine(data);}free(data);}}}
static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));main_sink_b(data);}void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){main_sink_d(data);}void main_sink_d(char * data){free(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t dest[100];wmemset(dest, L'C', 100-1);memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static wchar_t * main_source(wchar_t * data){wcscpy(data, L"15");return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main(){wchar_t * data;data=NULL;{wchar_t mystring[]=L"mystring";data=wcsdup(mystring);}main_sink(&data);}void main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);free(data);}
static void main(){unsigned char data;data=' ';data=5;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){unsigned char * data_ptr=(unsigned char *)void_data_ptr;unsigned char data=(*data_ptr);{unsigned char result=data * 2;printHexUnsignedCharLine(result);}}
static void main(){wchar_t * data;wchar_t * &data_ref=data;data=NULL;data=new wchar_t[100];wmemset(data, L'A', 100-1);data[100-1]=L'\0';{wchar_t * data=data_ref;printWLine(data);}}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[250]=L"PATH=";data=data_buf;data=b_main_source(data);PUTENV(data);}wchar_t * b_main_source(wchar_t * data){wcscat(data, NEW_PATH);return data;}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, "%s", args);va_end(args);}}static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}my_union.a=data;{char * data=my_union.b;main_vasink(data, data);}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]=FULL_COMMAND;data=data_buf;{char * data=*data_ptr1;strcat(data, "*.*");}{char * data=*data_ptr2;system(data);}}
void main_sink_b(wchar_t * data);static void main(){wchar_t * data;data=new wchar_t[100];main_sink_b(data);}void main_sink_c(wchar_t * data);void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){{wchar_t dest[50]=L"";memcpy(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);delete [] data;}}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;data=b_main_source(data);{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}wchar_t * b_main_source(wchar_t * data){wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");return data;}
static void main(){long long * data;long long * data_array[5];data=NULL;data=(long long *)malloc(100*sizeof(long long));data_array[2]=data;b_main_sink(data_array);}void b_main_sink(long long * data_array[]){long long * data=data_array[2];free(data);}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{wchar_t src[100];_snwprintf(data, 100, L"%s", src);printWLine(data);}}
static char * main_source(char * data){strcpy(data, "fixedstringtest");return data;}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);main_vasink(data, data);}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
void b_main_sink(short data_array[]);static void main(){short data;short data_array[5];data=-1;data=CHAR_MAX-5;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(short data_array[]){short data=data_array[2];{char c=(char)data;printHexCharLine(c);}}
static void main(){wchar_t * data;_union_type my_union;data=(wchar_t *)calloc(100, sizeof(wchar_t));my_union.a=data;{wchar_t * data=my_union.b;if (data!=NULL){wcscpy(data, L"Initialize");printWLine(data);free(data);}}}
static void main(){twointsclass * data;{twointsclass * data_buf=new twointsclass[100];{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}printIntLine(data[0].a);delete [] data;}
static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;{char dest[50]="";strncpy(dest, data, strlen(data));printLine(data);}}
static void main_vasinkb(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, data, args);va_end(args);printLine(dest);}}static void main_vasinkg(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, "%s", args);va_end(args);printLine(dest);}}static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}main_vasinkg(data, data);}
static void main(){twointsclass * data;twointsclass * *data_ptr1=&data;twointsclass * *data_ptr2=&data;data=NULL;{twointsclass * data=*data_ptr1;data=new twointsclass[100];}{twointsclass * data=*data_ptr2;delete [] data;}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(data, args);va_end(args);}}void d_main_sink(wchar_t * data){main_vasink(data, data);}
static void main(){int data;_struct_type my_struct;data=-1;data=5;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{int result=data+1;printIntLine(result);}}
static void main(){int data;data=-1;data=20;{size_t a,i;int *b;b=(int*)new char[a];for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);delete [] b;}}
void main_sink(wchar_t * * data);static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_sink(&data);}void main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));printWLine(data);delete [] data;}}
void main_sink(void * void_data_ptr);static void main(){char * data;data=new char[100];main_sink(&data);}void main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{char dest[50]="";strcat(dest, data);printLine(data);delete [] data;}}
static void main(){twointsclass * data;data=NULL;data=NULL;data=(twointsclass *)realloc(data, 100*sizeof(twointsclass));free(data);}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");fprintf(stdout, data);}
static void main(){int * data;data=NULL;data=(int *)malloc(100*sizeof(int));free(data);b_main_sink(&data);}void b_main_sink(int * * data_ptr){int * data=*data_ptr;}
static void main(){int data;data=-1;data=100-1;{int data_copy=data;int data=data_copy;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}}
void main_sink_b(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_sink_b(data);}void main_sink_c(wchar_t * data);void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){{wchar_t dest[100];wmemset(dest, L'C', 100-1);memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);delete [] data;}}
static void main(){int data;int data_array[5];data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}data_array[2]=data;main_sink(data_array);}void main_sink(int data_array[]){int data=data_array[2];{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];fwprintf(stdout, L"%s\n", data);}
static void main(){char * data;data=(char *)malloc(100);if (data!=NULL){strcpy(data, "Initialize");printLine(data);free(data);}}
static void main(){twoints * data;data=NULL;data=new twoints;main_sink(&data);}void main_sink(void * void_data_ptr){twoints * * data_ptr=(twoints * *)void_data_ptr;twoints * data=(*data_ptr);delete data;}
static long long * main_source(long long * data){data=(long long *)malloc(100*sizeof(long long));return data;}static void main(){long long * data;data=NULL;data=main_source(data);free(data);}
void main_sink(struct_type my_struct);static void main(){int data;struct_type my_struct;data=-1;data=20;my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){int data=my_struct.a;{size_t a,i;int *b;b=(int*)new char[a];for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);delete [] b;}}
static void main_sink(twoints * data){free(data);}static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));main_sink(data);}
static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));main_sink(data);}void main_sink(long long * data){free(data);}
static void main(){unsigned char data;_union_type my_union;data=' ';data=5;my_union.a=data;{unsigned char data=my_union.b;{unsigned char result=data-1;printHexUnsignedCharLine(result);}}}
void main_sink_b(char * data);static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){{size_t i;char dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);}}
static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));free(data);b_main_sink(data);}void b_main_sink(char * data){}
static void main(){int * data;data=NULL;data=new int;main_sink(&data);}void main_sink(int * * data_ptr){int * data=*data_ptr;delete data;}
void b_main_sink();static void main(){short data;data=0;data=100-1;_main_data=data;b_main_sink();}void b_main_sink(){short data=_main_data;{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
static char * main_source(char * data){data=new char[100];strcpy(data, "A String");printLine(data);return data;}static void main(){char * data;data=NULL;data=main_source(data);delete[] data;}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}printWLine(data);free(data);}}
static void main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnv(_P_WAIT, COMMAND_INT_PATH, args);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;strcat(data, "*.*");func_ptr(data);}
static void main(){if(global_returns_t_or_f()){{HANDLE hFile;wchar_t * filename=L"C:\\temp\\file.txt";hFile=CreateFileW( filename, GENERIC_READ, FILE_SHARE_READ, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile==INVALID_HANDLE_VALUE){printLine("File could not be created");}else{printLine("File created successfully");CloseHandle(hFile);}}}else{{HANDLE hFile;wchar_t * filename=L"C:\\temp\\file.txt";hFile=CreateFileW( filename, GENERIC_READ, FILE_SHARE_READ, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile==INVALID_HANDLE_VALUE){printLine("File could not be created");}else{printLine("File created successfully");CloseHandle(hFile);}}}}
static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, "%s", args);va_end(args);printLine(dest);}}static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}my_union.a=data;{char * data=my_union.b;main_vasink(data, data);}}
static wchar_t * main_source(wchar_t * data){wcscat(data, L"file.txt");return data;}static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;data=main_source(data);{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
static void main(){if(global_returns_t_or_f()){{charvoid * cv_struct=(charvoid *)malloc(sizeof(charvoid));cv_struct->y=SRC_STR;printLine((char *)cv_struct->y);memmove(cv_struct->x, SRC_STR, sizeof(cv_struct->x));printLine((char *)cv_struct->x);printLine((char *)cv_struct->y);}}else{{charvoid * cv_struct=(charvoid *)malloc(sizeof(charvoid));cv_struct->y=SRC_STR;printLine((char *)cv_struct->y);memmove(cv_struct->x, SRC_STR, sizeof(cv_struct->x));printLine((char *)cv_struct->x);printLine((char *)cv_struct->y);}}}
static void main_sink(char * data){{char src[100];strncat(data, src, 100);printLine(data);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;func_ptr(data);}
static void main(){int * data;data=NULL;data=(int *)malloc(100*sizeof(int));data[0]=5;printIntLine(data[0]);b_main_sink(&data);}void b_main_sink(int * * data_ptr){int * data=*data_ptr;free(data);}
static void main(){int data;data=-1;data=5;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);{int result=data * 2;printIntLine(result);}}
void b_main_sink(void * void_data_ptr);static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{char src[100];memcpy(data, src, 100*sizeof(char));printLine(data);free(data);}}
static void main(){int * data;int * *data_ptr1=&data;int * *data_ptr2=&data;data=NULL;{int * data=*data_ptr1;data=new int[100];}{int * data=*data_ptr2;delete [] data;}}
static void main(){long long * data;data=NULL;data=new long long;main_sink_b(data);}void main_sink_b(long long * data){main_sink_c(data);}void main_sink_c(long long * data){delete data;}
static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}my_struct.a=data;b_main_sink(my_struct);}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf("%s", args);va_end(args);}}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;main_vasink(data, data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{char dest[100]="";SNPRINTF(dest, 100-1, "%s", data);printLine(dest);}}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char data_buf[100]="";data=data_buf;strcat(data, "*.*");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
static void main(){int * data;data=NULL;main_source(data);free(data);}void main_source(int * &data){data=NULL;data=(int *)realloc(data, 100*sizeof(int));}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}b_main_sink(data);}void b_main_sink(wchar_t * data){fwprintf(stdout, L"%s\n", data);}
static void main_source(int * &data){data=new int;}static void main(){int * data;data=NULL;main_source(data);delete data;}
static void main(){twoints * data;_struct_type my_struct;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}free(data);my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){twoints * data=my_struct.a;}
static void main(){twointsclass * data;data=(twointsclass *)ALLOCA(10*sizeof(twointsclass));main_sink(&data);}void main_sink(twointsclass * * data_ptr){twointsclass * data=*data_ptr;for(int i=0;i<10;i++){data[i].a=i;data[i].b=i;}for(int i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}
static void main_sink(){long long * data=_main_data;free(data);}static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));data[0]=5L;printLongLongLine(data[0]);_main_data=data;main_sink();}
static void main(){twoints * data;data=NULL;data=b_main_source(data);free(data);}twoints * b_main_source(twoints * data){data=(twoints *)calloc(100, sizeof(twoints));data[0].a=0;data[0].b=0;printStructLine(&data[0]);return data;}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];delete [] data;}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=NULL;{char * data=*data_ptr1;data=(char *)calloc(100, sizeof(char));strcpy(data, "A String");printLine(data);}{char * data=*data_ptr2;free(data);}}
static void main(){FILE * data;FILE * *data_ptr1=&data;FILE * *data_ptr2=&data;data=NULL;{FILE * data=*data_ptr1;data=freopen("BadSource_freopen.txt","w+",stdin);}{FILE * data=*data_ptr2;if (data!=NULL){fclose(data);}}}
static void main(){long long * data;data=NULL;data=b_main_source(data);printLongLongLine(data[0]);}long long * b_main_source(long long * data){data=(long long *)malloc(100*sizeof(long long));{size_t i;for(i=0;i < 100;i++){data[i]=5L;}}return data;}
static void main(){twointsclass * data;data=NULL;main_source(data);delete[] data;}void main_source(twointsclass * &data){data=new twointsclass[100];data[0].a=0;data[0].b=0;printIntLine(data[0].a);printIntLine(data[0].b);}
void b_main_sink(char * data);static void main(){char * data;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{char src[100];memcpy(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}
char * b_main_source(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;data=b_main_source(data);{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}char * b_main_source(char * data){strcat(data, "file.txt");return data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){e_main_sink(data);}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}void e_main_sink(char * data){main_vasink(data, data);}
static void main(){int * data;void (*func_ptr) (int *)=b_main_sink;data=NULL;data=(int *)malloc(100*sizeof(int));free(data);func_ptr(data);}void b_main_sink(int * data){}
static void main_sink(unsigned char data){{unsigned char result=data * 2;printHexUnsignedCharLine(result);}}static void main(){unsigned char data;void (*func_ptr) (unsigned char)=main_sink;data=' ';data=5;func_ptr(data);}
static void main(){int data;int &data_ref=data;data=-1;data=20;{int data=data_ref;{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}}
static void main(){int * data;data=NULL;data=new int[100];{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printIntLine(data[0]);delete [] data;}}}
static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));memset(data, 'A', 100-1);data[100-1]='\0';_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;printLine(data);}
static void main_sink(){char * data=_main_data;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnv(_P_WAIT, COMMAND_INT_PATH, args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_main_data=data;main_sink();}
static void main(){int data;data=RAND32();b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){wchar_t * data;wchar_t * data_array[5];data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));data_array[2]=data;main_sink(data_array);}void main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];free(data);}
static void main(){int * data;data=NULL;if(global_returns_t_or_f()){data=new int;delete data;}else{data=new int;delete data;}if(global_returns_t_or_f()){}else{}}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"C:\\Windows\\System32\\winsrv.dll");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{HMODULE hModule;hModule=LoadLibraryW(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
static void main(){int data;data=-1;fscanf (stdin, "%d", &data);{int result=-1;if (data <=(int)sqrt((int)INT_MAX)){result=data * data;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){wchar_t * data;_union_type my_union;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;my_union.a=data;{wchar_t * data=my_union.b;{size_t i, dest_sz;wchar_t dest[100];wmemset(dest, L'C', 100-1);dest_sz=wcslen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);}}}
static void main(){twoints * data;data=NULL;data=main_source(data);}twoints * main_source(twoints * data){data=new twoints[100];delete [] data;return data;}
static void main(){twoints * data;data=(twoints *)realloc(data, 100);{twoints * data_copy=data;twoints * data=data_copy;if (data!=NULL){data[0].a=1;data[0].b=1;printStructLine(&data[0]);free(data);}}}
static void main(){short data;data=0;data=100-1;{short data_copy=data;short data=data_copy;{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}}
static void main(){char * data;data=NULL;data=new char[100];delete [] data;}
static void main(){char * data;data=NULL;if(global_returns_t_or_f()){data=new char[100];}else{data=new char[100];}{char src[100];memcpy(data, src, 100*sizeof(char));printLine(data);delete [] data;}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");fprintf(stdout, data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, "%s", args);va_end(args);printLine(dest);}}void d_main_sink(char * data){main_vasink(data, data);}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t dest[100];wcscpy(dest, data);printWLine(dest);}}
static void main(){{char * password=(char *)ALLOCA(100*sizeof(char));size_t password_len=0;HANDLE pHandle;char * username="User";char * domain="Domain";password[0]='\0';fgets(password, 100, stdin);password_len=strlen(password);if (password_len > 0){password[password_len-1]='\0';}if (LogonUserA( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}password_len=strlen(password);SecureZeroMemory(password, password_len * sizeof(char));}}
static void main(){short data;data=0;data=100-1;{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){char * data;char data_buf[100]="";data=data_buf;if(global_returns_t_or_f()){{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}}else{{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}}if(global_returns_t_or_f()){fprintf(stdout, "%s\n", data);}else{fprintf(stdout, "%s\n", data);}}
static void main_sink(twoints * data){delete data;}static void main(){twoints * data;void (*func_ptr) (twoints *)=main_sink;data=NULL;data=new twoints;func_ptr(data);}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnvp(_P_WAIT, COMMAND_INT, args);}}
static void main(){wchar_t * data;struct_type my_struct;data=NULL;data=new wchar_t[100];my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){wchar_t * data=my_struct.a;delete [] data;}
static void main(){int data;data=-1;data=20;b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{char * char_string;if (data > 0){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than 0");}}}
void main_sink(struct_type my_struct);static void main(){wchar_t * data;struct_type my_struct;{wchar_t * data_buf=new wchar_t[100];data=data_buf;}my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){wchar_t * data=my_struct.a;printWLine(data);delete [] data;}
static void main_sink(int * data){delete data;}static void main(){int * data;void (*func_ptr) (int *)=main_sink;data=NULL;data=new int;func_ptr(data);}
static void main(){wchar_t * data;_union_type my_union;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;my_union.a=data;{wchar_t * data=my_union.b;{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}}
static void main(){struct _twoints * data;data=NULL;data=new struct _twoints[100];data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);main_sink_b(data);}void main_sink_b(struct _twoints * data){main_sink_c(data);}void main_sink_c(struct _twoints * data){main_sink_d(data);}void main_sink_d(struct _twoints * data){main_sink_e(data);}void main_sink_e(struct _twoints * data){delete[] data;}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;strcat(data, "*.*");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;_spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main_sink(wchar_t * data){{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");func_ptr(data);}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{char dest[50]="";strncpy(dest, data, strlen(data));printLine(data);}}
static void main_sink(int data){{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than the length of the source string or too large");}}}static void main(){int data;data=-1;data=10000;main_sink(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100];data=data_buf;func_ptr(data);}void b_main_sink(char * data){{char dest[50]="";strncat(dest, data, strlen(data));printLine(data);}}
static void main_sink(){int data=_main_data;{int result=data * data;printIntLine(result);}}static void main(){int data;data=-1;data=5;_main_data=data;main_sink();}
static void main(){wchar_t * data;wchar_t * &data_ref=data;data=NULL;data=new wchar_t[100];wcscpy(data, L"A String");printWLine(data);{wchar_t * data=data_ref;delete[] data;}}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t dest[50]=L"";wcsncpy(dest, data, wcslen(data));printWLine(data);}}
static void main(){int data;data=-1;data=20;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{char * char_string;if (data > 0){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than 0");}}}
static void main(){int data;data=7;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);{wchar_t data_buf[10]=L"AAAAAAAAA";if (data >=0){printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
void main_sink_b(wchar_t * data);static void main(){wchar_t * data;data=new wchar_t[100];main_sink_b(data);}void main_sink_c(wchar_t * data);void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){{wchar_t dest[50]=L"";wcscat(dest, data);printWLine(data);delete [] data;}}
wchar_t * main_source(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=main_source(data);{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}wchar_t * main_source(wchar_t * data){{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}return data;}
void b_main_sink(char * * data);static void main(){char * data;data=(char *)malloc(100*sizeof(char));b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char dest[50]="";strcat(dest, data);printLine(data);free(data);}}
static void main(){unsigned char data;data=' ';data=5;b_main_sink(data);}void b_main_sink(unsigned char data){{unsigned char result=data * 2;printHexUnsignedCharLine(result);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnvp(_P_WAIT, COMMAND_INT, args);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
void b_main_sink(twoints * data);static void main(){twoints * data;void (*func_ptr) (twoints *)=b_main_sink;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));func_ptr(data);}void b_main_sink(twoints * data){{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printStructLine(&data[0]);free(data);}}}
static void main_sink(){wchar_t * data=_main_data;{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");_main_data=data;main_sink();}
void b_main_sink(_struct_type my_struct);static void main(){int data;_struct_type my_struct;data=-1;data=100-1;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
static void main(){twointsclass * data;data=NULL;{twointsclass data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printIntLine(data[0].a);printIntLine(data[0].b);}main_sink_b(data);}void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_c(twointsclass * data){}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char dest[100];strncpy(dest, data, strlen(dest));dest[100-1]='\0';printLine(dest);}}
static void main(){int count;void (*func_ptr) (int)=b_main_sink;count=-1;count=RAND32();func_ptr(count);}void b_main_sink(int count){{size_t i=0;if (count > 0 && count <=20){for (i=0;i < (size_t)count;i++){printLine("Hello");}}}}
static void main(){float data;data=0.0F;if(global_returns_t_or_f()){data=7.0F;}else{data=7.0F;}printDoubleLine((double)(100.0/data));}
void b_main_sink();static void main(){char * data;char data_buf[250]="PATH=";data=data_buf;strcat(data, NEW_PATH);_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;PUTENV(data);}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}delete [] data;main_sink(&data);}void main_sink(void * void_data_ptr){twointsclass * * data_ptr=(twointsclass * *)void_data_ptr;twointsclass * data=(*data_ptr);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){char * data;_union_type my_union;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");my_union.a=data;{char * data=my_union.b;{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}}
void b_main_sink(char * data);static void main(){char * data;data=(char *)malloc(100*sizeof(char));b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{char dest[50]="";strncpy(dest, data, strlen(data));printLine(data);free(data);}}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}{int data_copy=data;int data=data_copy;{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, data);printWLine(dest);}}
static void main(){{HWINSTA hWStation;wchar_t * wStationName=L"WindowsStationExample";hWStation=CreateWindowStationW( wStationName, 0, GENERIC_READ, NULL);if (hWStation==NULL){printLine("Windows station could not be created");}else{printLine("Windows Station created successfully");CloseWindowStation(hWStation);}}}
static void main(){char data;data=' ';data=5;{char data_copy=data;char data=data_copy;{char result=data * data;printHexCharLine(result);}}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;data->a=1;data->b=2;main_sink(data);}void main_sink(twointsclass * data){printIntLine(data->a);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");func_ptr(data);}void b_main_sink(wchar_t * data){{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){char * data;char * data_array[5];char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];fprintf(stdout, data);}
static void main_sink(){char * data=_main_data;if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}_main_data=data;main_sink();}
static void main(){int data;_union_type my_union;data=-1;data=20;my_union.a=data;{int data=my_union.b;{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}}
void main_sink(char * * data);static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}main_sink(&data);}void main_sink(char * * data_ptr){char * data=*data_ptr;{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]='\0';printLine(data);}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;main_sink_b(data);}void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_c(twointsclass * data){main_sink_d(data);}void main_sink_d(twointsclass * data){main_sink_e(data);}void main_sink_e(twointsclass * data){delete data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;if(global_returns_t_or_f()){strcat(data, "*.*");}else{strcat(data, "*.*");}{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
static void main(){char data;data=' ';data=5;_main_data=data;b_main_sink();}void b_main_sink(){char data=_main_data;{char result=data+1;printHexCharLine(result);}}
char * b_main_source(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnv(_P_WAIT, COMMAND_INT_PATH, args);}}char * b_main_source(char * data){strcat(data, "*.*");return data;}
void b_main_sink(int data);static void main(){int data;data=-1;data=7;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void d_main_sink(int data);void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){printIntLine(100/data);}
static void main(){char data;data=' ';fscanf (stdin, "%c", &data);{char data_copy=data;char data=data_copy;{char result=-1;if (data <=(char)sqrt((char)CHAR_MAX)){result=data * data;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
static void main_sink(int * data){delete [] data;}static void main(){int * data;void (*func_ptr) (int *)=main_sink;data=NULL;data=new int[100];func_ptr(data);}
static void main(){wchar_t * data;_union_type my_union;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));data=data_buf;}my_union.a=data;{wchar_t * data=my_union.b;printWLine(data);free(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){fwprintf(stdout, data);}
static void main_sink(char * data){free(data);}static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;data=(char *)malloc(100*sizeof(char));strcpy(data, "A String");printLine(data);func_ptr(data);}
static void main(){wchar_t * data;data=new wchar_t[100];if(global_returns_t_or_f()){}else{}{wchar_t dest[50]=L"";wcscat(dest, data);printWLine(data);delete [] data;}}
static char * main_source(char * data){strcat(data, "*.*");return data;}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){wchar_t * data;{wchar_t * data_buf=new wchar_t[100];data=data_buf;}printWLine(data);delete [] data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;fwprintf(stdout, L"%s\n", data);}
static void main(){long long * data;long long data_badbuf[50];long long data_goodbuf[100];data=data_goodbuf;{memcpy(data, src, 100*sizeof(long long));printLongLongLine(data[0]);}}
static void main(){unsigned int data;_union_type my_union;data=0;data=5;my_union.a=data;{unsigned int data=my_union.b;{unsigned int result=data-1;printUnsignedLine(result);}}}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");my_union.a=data;{wchar_t * data=my_union.b;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}}
static wchar_t * main_source(wchar_t * data){data=(wchar_t *)malloc(100*sizeof(wchar_t));return data;}static void main(){wchar_t * data;data=NULL;data=main_source(data);free(data);}
static void main(){twoints * data;struct_type my_struct;data=NULL;twoints data_good;data=&data_good;data->a=0;data->b=0;printStructLine(data);my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){twoints * data=my_struct.a;}
static void main(){twoints * data;twoints data_uninit_array[10];data=data_uninit_array;{int i;for(i=0;i<10;i++){data[i].a=i;data[i].b=i;}}b_main_sink(&data);}void b_main_sink(twoints * * data_ptr){twoints * data=*data_ptr;{int i;for(i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}}
void main_sink(void * void_data_ptr);static void main(){wchar_t * data;data=new wchar_t[100];main_sink(&data);}void main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{wchar_t dest[50]=L"";size_t i, data_len;data_len=wcslen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printWLine(data);delete [] data;}}
static void main(){if(global_returns_t_or_f()){{char * key="TEST\\TestKey";HKEY hKey;if (RegOpenKeyExA( HKEY_CURRENT_USER, key, 0, KEY_WRITE, &hKey)!=ERROR_SUCCESS){printLine("Registry key could not be opened");}else{printLine("Registry key opened successfully");}}}else{{char * key="TEST\\TestKey";HKEY hKey;if (RegOpenKeyExA( HKEY_CURRENT_USER, key, 0, KEY_WRITE, &hKey)!=ERROR_SUCCESS){printLine("Registry key could not be opened");}else{printLine("Registry key opened successfully");}}}}
void main_sink_b(char * data);static void main(){char * data;data=NULL;data=new char[100];main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){{char dest[100];memset(dest, 'C', 100-1);memmove(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);delete [] data;}}
static void main(){wchar_t * password;_union_type my_union;wchar_t password_buf[100]=L"";password=password_buf;{size_t password_len=0;fgetws(password, 100, stdin);password_len=wcslen(password);if (password_len > 0){password[password_len-1]=L'\0';}}my_union.a=password;{wchar_t * password=my_union.b;{HANDLE pHandle;wchar_t * username=L"User";wchar_t * domain=L"Domain";if (LogonUserW( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}}
static void main_source(twointsclass &data){data.a=1;data.b=2;}static void main(){twointsclass data;main_source(data);printIntLine(data.a);printIntLine(data.b);}
static void main_sink(){wchar_t * data=main_data;delete data;}static void main(){wchar_t * data;data=NULL;data=new wchar_t;main_data=data;main_sink();}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;func_ptr(data);}void b_main_sink(wchar_t * data){{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));printWLine(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){if (wcsncmp(PASSWORD, data, wcslen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main_sink(){int * data=_main_data;{int data_src[10]={0};memcpy(data, data_src, 10*sizeof(int));printIntLine(data[0]);free(data);}}static void main(){int * data;data=NULL;data=(int *)malloc(10*sizeof(int));_main_data=data;main_sink();}
static void main(){char * data;union_type my_union;data=NULL;data=NULL;data=(char *)realloc(data, 100*sizeof(char));my_union.a=data;{char * data=my_union.b;free(data);}}
void b_main_sink(float data);static void main(){float data;void (*func_ptr) (float)=b_main_sink;data=0.0F;data=7.0F;func_ptr(data);}void b_main_sink(float data){printDoubleLine((double)(100.0/data));}
void main_sink();static void main(){wchar_t * data;{wchar_t * data_buf=new wchar_t[100];data=data_buf;}_main_data=data;main_sink();}void main_sink(){wchar_t * data=_main_data;printWLine(data);delete [] data;}
static void main_sink(char * data){delete data;}static void main(){char * data;data=NULL;data=new char;main_sink(data);}
static void main(){double * data;data=new double[10];{int i;for(i=0;i<10;i++){data[i]=(double)i;}}{int i;for(i=0;i<10;i++){printDoubleLine(data[i]);}}delete [] data;}
void b_main_sink();static void main(){wchar_t * data;data=NULL;data=L"Good";_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;wprintf(L"%s\n", data);}
void b_main_sink(short * data);static void main(){short data;data=0;data=100-1;b_main_sink(&data);}void b_main_sink(short * data_ptr){short data=*data_ptr;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
static void main(){long long * data;data=NULL;data=new long long;main_sink_b(data);}void main_sink_b(long long * data){main_sink_c(data);}void main_sink_c(long long * data){main_sink_d(data);}void main_sink_d(long long * data){main_sink_e(data);}void main_sink_e(long long * data){printLongLongLine(*data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){e_main_sink(data);}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}void e_main_sink(char * data){main_vasink(data, data);}
static void main(){char * data;union_type my_union;data=NULL;data=new char[100];strcpy(data, "A String");printLine(data);my_union.a=data;{char * data=my_union.b;delete[] data;}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}b_main_sink(&data);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(L"%s", args);va_end(args);}}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);main_vasink(data, data);}
static void main(){int data;data=-1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);{int result=-1;if (data <=(int)sqrt((int)INT_MAX)){result=data * data;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;if(global_returns_t_or_f()){wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");}else{wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");}{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
void b_main_sink(wchar_t * password);static void main(){wchar_t * password;password=L"";password=(wchar_t *)malloc(100*sizeof(wchar_t));if(!VirtualLock(password, 100*sizeof(wchar_t))){printLine("Memory could not be locked");exit(1);}wcscpy(password, L"Password1234!");b_main_sink(password);}void c_main_sink(wchar_t * password);void b_main_sink(wchar_t * password){c_main_sink(password);}void c_main_sink(wchar_t * password){{HANDLE pHandle;wchar_t * username=L"User";wchar_t * domain=L"Domain";if (LogonUserW( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}
static void main(){long long * data;data=NULL;{long long data_goodbuf[100];data=data_goodbuf;data[0]=5L;printLongLongLine(data[0]);}{long long * data_copy=data;long long * data=data_copy;}}
static void main(){twointsclass * data;data=NULL;data=main_source(data);free(data);}twointsclass * main_source(twointsclass * data){data=(twointsclass *)calloc(100, sizeof(twointsclass));return data;}
static void main(){{int i=rand();if(i==5){printLine("i was 5");}}}
static void main(){int data;int data_array[5];data=10;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char data_buf[100]="";data=data_buf;strcat(data, "*.*");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];_spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){{wchar_t * filename;wchar_t * template=L"fnXXXXXX";int fd;filename=_wmktemp(template);printWLine(filename);fd=OPEN(filename, O_CREAT|O_EXCL, S_IREAD|S_IWRITE);if (fd!=-1){printLine("Temporary file was opened...now closing file");CLOSE(fd);}}}
static void main(){int count;_union_type my_union;count=-1;count=20;my_union.a=count;{int count=my_union.b;{size_t i=0;for (i=0;i < (size_t)count;i++){printLine("Hello");}}}}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");func_ptr(data);}void b_main_sink(char * data){{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
void b_main_sink(bad_struct * data);static void main(){bad_struct data;linked_list head={&head, &head};data.list.next=head.next;data.list.prev=&head;head.next=&data.list;head.next->prev=&data.list;b_main_sink(&data);}void b_main_sink(bad_struct * data_ptr){bad_struct data=*data_ptr;* */prev=data.list.prev;next=data.list.next;prev->next=next;next->prev=prev;}
static void main_sink(int data){{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}static void main(){int data;data=7;main_sink(data);}
void main_sink(struct_type my_struct);static void main(){wchar_t * data;struct_type my_struct;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){wchar_t * data=my_struct.a;{wchar_t dest[100];memcpy(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
void main_sink(wchar_t * * data);static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}main_sink(&data);}void main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");_wsystem(data);}
static void main(){int data;data=7;{wchar_t data_buf[10]=L"AAAAAAAAA";if (data >=0){printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
void main_sink(void * void_data_ptr);static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_sink(&data);}void main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{wchar_t src[100];_snwprintf(data, 100, L"%s", src);printWLine(data);delete [] data;}}
static void main(){char * data;_union_type my_union;data=NULL;data=(char *)malloc((10+1)*sizeof(char));my_union.a=data;{char * data=my_union.b;{char data_src[10+1]=SRC_STRING;memmove(data, data_src, strlen(data_src)*sizeof(char));printLine(data);free(data);}}}
static void main(){twoints * data;data=(twoints *)malloc(10*sizeof(twoints));{int i;for(i=0;i<10;i++){data[i].a=i;data[i].b=i;}}b_main_sink(&data);}void b_main_sink(twoints * * data_ptr){twoints * data=*data_ptr;{int i;for(i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}}
static void main_source(wchar_t * &data){}static void main(){wchar_t * data;data=new wchar_t[100];main_source(data);{wchar_t dest[50]=L"";_snwprintf(dest, wcslen(data), L"%s", data);printWLine(data);delete [] data;}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void b_main_sink(wchar_t * data){EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){short data;data=0;data=100-1;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main_sink(list<int> data){{list<int>::iterator i;cout << "The list contains: ";for( i=data.begin();i!=data.end();i++){if (!*i){data.clear();}cout << " " << *i;}cout << endl;}}static void main(){list<int> data;void (*func_ptr) (list<int>)=main_sink;data.push_back(100);data.push_back(200);func_ptr(data);}
static void main(){int data;_union_type my_union;data=-1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}my_union.a=data;{int data=my_union.b;{int result=-1;if (data < INT_MAX){result=data+1;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));{size_t i;for(i=0;i < 100;i++){data[i]=5L;}}printLongLongLine(data[0]);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(&data);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, L"%s", args);va_end(args);}}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;main_vasink(data, data);}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];main_data=data;main_sink();}void main_sink(){twointsclass * data=main_data;delete [] data;}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, "%s", args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}main_vasink(data, data);}
static void main(){char * data;char * data_array[5];char data_buf[100]="";data=data_buf;data=PASSWORD;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){struct _twoints * data;data=NULL;data=(struct _twoints *)calloc(100, sizeof(struct _twoints));data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);b_main_sink(&data);}void b_main_sink(void * void_data_ptr){struct _twoints * * data_ptr=(struct _twoints * *)void_data_ptr;struct _twoints * data=(*data_ptr);free(data);}
static void main_sink(){char * data=_main_data;{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");_main_data=data;main_sink();}
static void main(){int data;data=5;b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;printIntLine(data);}
static void main(){int * data;data=NULL;data=(int *)malloc(100*sizeof(int));main_data=data;main_sink();}void main_sink(){int * data=main_data;free(data);}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
void b_main_sink(short data);static void main(){short data;data=-1;data=CHAR_MAX-5;b_main_sink(data);}void c_main_sink(short data);void b_main_sink(short data){c_main_sink(data);}void d_main_sink(short data);void c_main_sink(short data){d_main_sink(data);}void d_main_sink(short data){{char c=(char)data;printHexCharLine(c);}}
static void main(){char * data;data=NULL;data=main_source(data);printf("%c\n", *data);}char * main_source(char * data){data=new char;return data;}
void b_main_sink();static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{char src[100];strncat(data, src, 100);printLine(data);free(data);}}
void b_main_sink(char * data);static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{char dest[100];memset(dest, 'C', 100-1);memmove(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);}}
void b_main_sink();static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
static void main(){int count;count=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;count=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(count);}void b_main_sink(int count){c_main_sink(count);}void c_main_sink(int count){{size_t i=0;FILE *file=NULL;const char *filename="output_good.txt";if (count > 0 && count <=20){file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}}
static void main(){double * data;data=new double[10];{int i;for(i=0;i<10;i++){data[i]=(double)i;}}{int i;for(i=0;i<10;i++){printDoubleLine(data[i]);}}delete [] data;}
static void main(){wchar_t * data;_union_type my_union;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;my_union.a=data;{wchar_t * data=my_union.b;{wchar_t dest[50]=L"";wcsncat(dest, data, wcslen(data));printWLine(data);}}}
static void main_sink(long long * data){free(data);}static void main(){long long * data;void (*func_ptr) (long long *)=main_sink;data=NULL;data=(long long *)calloc(100, sizeof(long long));func_ptr(data);}
char * main_source(char * data);static void main(){char * data;data=main_source(data);printLine(data);delete [] data;}char * main_source(char * data){{char * data_buf=new char[100];data=data_buf;}return data;}
static long long * main_source(long long * data){data=(long long *)malloc(100);return data;}static void main(){long long * data;data=main_source(data);if (data!=NULL){data[0]=5L;printLongLongLine(data[0]);free(data);}}
static char * main_source(char * data){data=new char[100];memset(data, 'A', 100-1);data[100-1]='\0';return data;}static void main(){char * data;data=NULL;data=main_source(data);printLine(data);}
static void main(){long long * data;data=NULL;data=new long long[100];main_sink(&data);}void main_sink(long long * * data_ptr){long long * data=*data_ptr;delete [] data;}
static void main(){long long * data;data=NULL;if(global_returns_t_or_f()){data=(long long *)malloc(100*sizeof(long long));data[0]=5L;printLongLongLine(data[0]);}else{data=(long long *)malloc(100*sizeof(long long));data[0]=5L;printLongLongLine(data[0]);}if(global_returns_t_or_f()){free(data);}else{free(data);}}
static void main_sink(){wchar_t * data=_main_data;{wchar_t src[100];wcsncpy(data, src, 100);printWLine(data);}}static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;_main_data=data;main_sink();}
static void main(){char * data;data=NULL;data=new char[100];{char * data_copy=data;char * data=data_copy;delete [] data;}}
static void main_source(wchar_t * &data){{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}}static void main(){wchar_t * data;data=NULL;main_source(data);{wchar_t src[100];wcscpy(data, src);printWLine(data);}}
static int * main_source(int * data){data=new int[100];return data;}static void main(){int * data;data=NULL;data=main_source(data);delete [] data;}
char * b_main_source(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;data=b_main_source(data);{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}char * b_main_source(char * data){strcat(data, "file.txt");return data;}
static void main(){char data;data=' ';data=CHAR_MAX;b_main_sink(data);}void b_main_sink(char data){c_main_sink(data);}void c_main_sink(char data){{char result=-1;if (data <=(char)sqrt((char)CHAR_MAX)){result=data * data;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){wchar_t * data;{wchar_t * data_buf=new wchar_t[100];data=data_buf;}printWLine(data);delete [] data;}
static void main(){twointsclass * data;data=(twointsclass *)malloc(10*sizeof(twointsclass));for(int i=0;i<10;i++){data[i].a=i;data[i].b=i;}for(int i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}
char * b_main_source(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);{HMODULE hModule;hModule=LoadLibraryA(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}char * b_main_source(char * data){strcpy(data, "C:\\Windows\\System32\\winsrv.dll");return data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t dest[50]=L"";memcpy(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);}}
static void main(){long long * data;union_type my_union;data=NULL;data=new long long;my_union.a=data;{long long * data=my_union.b;delete data;}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t dest[100];memcpy(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char data_buf[100];data=data_buf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{char dest[50]="";strncat(dest, data, strlen(data));printLine(data);}}
void main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}func_ptr(data);}void main_sink(char * data){{char dest[100];memcpy(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
static long long * main_source(long long * data){data=(long long *)malloc(sizeof(*data));return data;}static void main(){long long * data;data=NULL;data=main_source(data);printLongLongLine(*data);free(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, L"%s", data);printWLine(dest);}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;strcat(data, "*.*");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnvp(_P_WAIT, COMMAND_INT, args);}}
static void main(){wchar_t * data;wchar_t * data_array[5];data=NULL;data=new wchar_t[100];data_array[2]=data;main_sink(data_array);}void main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];delete [] data;}
static void main(){char * data;_union_type my_union;char data_buf[100];data=data_buf;my_union.a=data;{char * data=my_union.b;{char dest[50]="";memcpy(dest, data, strlen(data)*sizeof(char));printLine(data);}}}
static void main(){long long * data;long long * data_array[5];data=NULL;data=NULL;data=(long long *)realloc(data, 100*sizeof(long long));data_array[2]=data;main_sink(data_array);}void main_sink(long long * data_array[]){long long * data=data_array[2];free(data);}
static void main(){{wchar_t * key=L"TEST\\TestKey";HUSKEY hKey=HKEY_CURRENT_USER;if (SHRegCreateUSKeyW( key, KEY_WRITE, NULL, &hKey, SHREGSET_HKCU)!=ERROR_SUCCESS){printLine("Registry key could not be created");}else{printLine("Registry key created successfully");}}}
static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printLongLongLine(data[0]);free(data);}}}
static void main(){unsigned int data;data=0;data=5;_main_data=data;b_main_sink();}void b_main_sink(){unsigned int data=_main_data;{unsigned int result=data+1;printUnsignedLine(result);}}
static void main(){long long * data;data=NULL;data=main_source(data);free(data);}long long * main_source(long long * data){data=NULL;data=(long long *)realloc(data, 100*sizeof(long long));return data;}
static void main(){char data;data=' ';data=CHAR_MAX;b_main_sink(data);}void b_main_sink(char data){c_main_sink(data);}void c_main_sink(char data){d_main_sink(data);}void d_main_sink(char data){e_main_sink(data);}void e_main_sink(char data){{char result=-1;if (data <=(CHAR_MAX/2)){result=data * 2;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){int * data;_union_type my_union;data=NULL;{int tmp=5;data=&tmp;}my_union.a=data;{int * data=my_union.b;printIntLine(*data);}}
static void main(){struct _twoints * data;struct _twoints * data_array[5];data=NULL;{struct _twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(struct _twoints * data_array[]){struct _twoints * data=data_array[2];}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t data_buf[250]=L"PATH=";data=data_buf;wcscat(data, NEW_PATH);b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;PUTENV(data);}
static void main_sink(wchar_t * data){{wchar_t dest[100];wcscpy(dest, data);printWLine(dest);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;func_ptr(data);}
void b_main_sink(char * data);static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{size_t i;char dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);}}
void b_main_sink(char * * password);static void main(){char * password;char password_buf[100]="";password=password_buf;strcpy(password, "Password1234!");b_main_sink(&password);}void b_main_sink(char * * password_ptr){char * password=*password_ptr;{HANDLE pHandle;char * username="User";char * domain="Domain";if (LogonUserA( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}
static void main(){twointsclass * data;data=NULL;main_source(data);free(data);}void main_source(twointsclass * &data){data=NULL;data=(twointsclass *)realloc(data, 100*sizeof(twointsclass));}
static void main(){if(global_returns_t_or_f()){{wchar_t data_buf[100]=L"";wchar_t * data=data_buf;if (wscanf(L"%99s\0", data)==EOF){printLine("wscanf failed!");exit(1);}}}else{{wchar_t data_buf[100]=L"";wchar_t * data=data_buf;if (wscanf(L"%99s\0", data)==EOF){printLine("wscanf failed!");exit(1);}}}}
void main_sink(char * data);static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}main_sink(data);}void main_sink(char * data){{char dest[100];memmove(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
static void main(){short data;data=0;data=100-1;{short data_copy=data;short data=data_copy;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}}
void b_main_sink(_struct_type my_struct);static void main(){long long * data;_struct_type my_struct;data=(long long *)realloc(data, 100);my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){long long * data=my_struct.a;if (data!=NULL){data[0]=5L;printLongLongLine(data[0]);free(data);}}
static void main_sink(){long long * data=main_data;printLongLongLine(data[0]);delete [] data;}static void main(){long long * data;{long long * data_buf=new long long[100];{size_t i;for (i=0;i < 100;i++){data_buf[i]=5L;}}data=data_buf;}main_data=data;main_sink();}
static void main(){if(global_returns_t_or_f()){{wchar_t * data=(wchar_t *)malloc(100*sizeof(wchar_t));wchar_t * tmp;wcscpy(data, L"A String");printWLine(data);tmp=(wchar_t *)realloc(data, (130000)*sizeof(wchar_t));if (tmp!=NULL){data=tmp;wcscpy(data, L"New String");printWLine(data);}free(data);}}else{{wchar_t * data=(wchar_t *)malloc(100*sizeof(wchar_t));wchar_t * tmp;wcscpy(data, L"A String");printWLine(data);tmp=(wchar_t *)realloc(data, (130000)*sizeof(wchar_t));if (tmp!=NULL){data=tmp;wcscpy(data, L"New String");printWLine(data);}free(data);}}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;main_sink_b(data);}void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_c(twointsclass * data){main_sink_d(data);}void main_sink_d(twointsclass * data){main_sink_e(data);}void main_sink_e(twointsclass * data){delete data;}
void b_main_sink(_struct_type my_struct);static void main(){int data;_struct_type my_struct;data=-1;data=CHAR_MAX-5;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{char c=(char)data;printHexCharLine(c);}}
int _main_global=5;static void main(){printIntLine(_main_global);}
void b_main_sink(char * data);static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{char src[100];strncpy(data, src, 100);printLine(data);}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));printWLine(data);delete [] data;}}
static void main(){char * data;_union_type my_union;data=NULL;data=(char *)malloc(100*sizeof(char));my_union.a=data;{char * data=my_union.b;{char dest[100];memset(dest, 'C', 100-1);memcpy(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);free(data);}}}
static void main_sink(){wchar_t * data=_main_data;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_data=data;main_sink();}
static void main(){char * data;union_type my_union;data=NULL;data=new char[100];my_union.a=data;{char * data=my_union.b;delete [] data;}}
void b_main_sink(int data_array[]);static void main(){int data;int data_array[5];data=-1;data=7;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];printIntLine(100/data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{int i, n, v;if (swscanf(data, L"%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static void main(){wchar_t * data;data=NULL;data=NULL;data=(wchar_t *)realloc(data, 100*sizeof(wchar_t));main_data=data;main_sink();}void main_sink(){wchar_t * data=main_data;free(data);}
static void main(){int data;data=-1;data=OPEN("BadSource_open.txt", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if(global_returns_t_or_f()){if (data!=-1){CLOSE(data);}}else{if (data!=-1){CLOSE(data);}}}
static void main(){int * data;int * &data_ref=data;data=NULL;data=new int[100];{int * data=data_ref;delete [] data;}}
void b_main_sink(twoints * data);static void main(){twoints * data;twoints * data_badbuf=(twoints *)ALLOCA(50*sizeof(twoints));twoints * data_goodbuf=(twoints *)ALLOCA(100*sizeof(twoints));data=data_goodbuf;b_main_sink(data);}void c_main_sink(twoints * data);void b_main_sink(twoints * data){c_main_sink(data);}void d_main_sink(twoints * data);void c_main_sink(twoints * data){d_main_sink(data);}void e_main_sink(twoints * data);void d_main_sink(twoints * data){e_main_sink(data);}void e_main_sink(twoints * data){{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printStructLine(&data[0]);}}}
void _main_sink(wchar_t * data){{wchar_t dest[100];memcpy(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}static void main(){wchar_t * data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;_main_sink(data);}
static void main(){wchar_t * data;data=NULL;{wchar_t data_goodbuf[100];data=data_goodbuf;wcscpy(data, L"a string");printWLine(data);}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);}
static void main_sink(char * data){{int i, n, v;if (sscanf(data, "%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}main_sink(data);}
static void main(){char * data;data=NULL;main_source(data);printf("%c\n", *data);}void main_source(char * &data){data=new char;}
void _main_sink(wchar_t * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");_main_sink(data);}
static void main(){int data;data=7;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{wchar_t data_buf[10]=L"AAAAAAAAA";if (data >=0){printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");{char * data_copy=data;char * data=data_copy;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnvp(_P_WAIT, COMMAND_INT, args);}}}
void b_main_sink(int * data);static void main(){int data;data=-1;data=CHAR_MAX-5;b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{char c=(char)data;printHexCharLine(c);}}
static void main(){twointsclass * data;data=NULL;main_source(data);free(data);}void main_source(twointsclass * &data){data=NULL;data=(twointsclass *)realloc(data, 100*sizeof(twointsclass));}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(data);}void b_main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;{char src[100];strcpy(data, src);printLine(data);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void b_main_sink(wchar_t * data){EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;data=(wchar_t *)malloc(100*sizeof(wchar_t));func_ptr(data);}void b_main_sink(wchar_t * data){{wchar_t dest[50]=L"";memcpy(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);free(data);}}
static void main_sink(wchar_t * data){{wchar_t dest[50]=L"";wcsncpy(dest, data, wcslen(data));printWLine(data);delete [] data;}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=new wchar_t[100];func_ptr(data);}
static void main(){char data;_struct_type my_struct;data=' ';data=5;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char data=my_struct.a;{char result=data * data;printHexCharLine(result);}}
void _main_sink(char * data){printLine(data);free(data);}static void main(){char * data;{char * data_buf=(char *)malloc(100*sizeof(char));data=data_buf;}_main_sink(data);}
static void main(){wchar_t * data;data=NULL;{wchar_t data_goodbuf[100];data=data_goodbuf;wcscpy(data, L"a string");printWLine(data);}_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;data=(char *)malloc(100*sizeof(char));my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char dest[50]="";size_t i, data_len;data_len=strlen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printLine(data);free(data);}}
void _main_sink(short data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}static void main(){short data;data=0;data=100-1;_main_sink(data);}
static void main_sink(unsigned int data){{unsigned int result=data * 2;printUnsignedLine(result);}}static void main(){unsigned int data;void (*func_ptr) (unsigned int)=main_sink;data=0;data=5;func_ptr(data);}
static void main_sink(){char * data=main_data;free(data);}static void main(){char * data;data=NULL;data=(char *)calloc(100, sizeof(char));main_data=data;main_sink();}
static void main(){int * data;data=NULL;data=new int;main_sink(&data);}void main_sink(int * * data_ptr){int * data=*data_ptr;printIntLine(*data);}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(L"%s", args);va_end(args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}main_vasink(data, data);}
static void main(){int data;data=-1;data=RAND32();main_sink_b(data);}void main_sink_b(int data){main_sink_c(data);}void main_sink_c(int data){{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){char * data;data=NULL;data=new char[100];main_sink_b(data);}void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){main_sink_d(data);}void main_sink_d(char * data){delete [] data;}
static void main_sink(char data){{char result=data * 2;printHexCharLine(result);}}static void main(){char data;void (*func_ptr) (char)=main_sink;data=' ';data=5;func_ptr(data);}
static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t dest[100];wcscpy(dest, data);printWLine(dest);}}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;main_sink_b(data);}void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_c(twointsclass * data){main_sink_d(data);}void main_sink_d(twointsclass * data){delete data;}
static void main(){int * data;data=new int[10];{int i;for(i=0;i<10;i++){data[i]=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}delete [] data;}
static void main(){twoints * data;data=NULL;data=(twoints *)malloc(sizeof(*data));data->a=1;data->b=2;{twoints * data_copy=data;twoints * data=data_copy;printStructLine(data);free(data);}}
static void main(){int * data;data=NULL;data=new int[100];{size_t i;for(i=0;i < 100;i++){data[i]=5;}}delete [] data;{int * data_copy=data;int * data=data_copy;}}
static void main(){char data;data=' ';if(global_returns_t_or_f()){data=5;}else{data=5;}if(global_returns_t_or_f()){{char result=data+1;printHexCharLine(result);}}else{{char result=data+1;printHexCharLine(result);}}}
static void main_sink(int * data){free(data);}static void main(){int * data;data=NULL;data=(int *)malloc(100*sizeof(int));data[0]=5;printIntLine(data[0]);main_sink(data);}
static void main_vasinkg(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, L"%s", args);va_end(args);printWLine(dest);}}static void main_vasinkb(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");main_vasinkb(data, data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");func_ptr(data);}void b_main_sink(wchar_t * data){EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static int main_source(int data){data=5;return data;}static void main(){int data;data=-1;data=main_source(data);{int result=data+1;printIntLine(result);}}
static void main(){int data;data=-1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
void b_main_sink(char * * data);static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{size_t i, dest_sz;char dest[100];memset(dest, 'C', 100-1);dest_sz=strlen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);}}
void b_main_sink(short data);static void main(){short data;data=-1;data=CHAR_MAX-5;b_main_sink(data);}void c_main_sink(short data);void b_main_sink(short data){c_main_sink(data);}void c_main_sink(short data){{char c=(char)data;printHexCharLine(c);}}
static void main(){int data;data=-1;data=20;main_sink(data);}void main_sink(int data){{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}
static void main(){long long * data;{long long * data_buf=(long long *)malloc(100*sizeof(long long));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5L;}}data=data_buf;}printLongLongLine(data[0]);free(data);}
static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;strcpy(data, GOOD_OS_COMMAND);my_union.a=data;{char * data=my_union.b;system(data);}}
static long long * main_source(long long * data){data=(long long *)malloc(100*sizeof(long long));return data;}static void main(){long long * data;data=NULL;data=main_source(data);free(data);}
static void main_sink(char data){{char result=data+1;printHexCharLine(result);}}static void main(){char data;data=' ';data=5;main_sink(data);}
static void main(){{char data_buf[100]="";char * data=data_buf;if (fscanf(stdin, "%99s\0", data)==EOF){printLine("fscanf failed!");exit(1);}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");b_main_sink(data);}void b_main_sink(char * data){{FILE *pipe;pipe=POPEN(data, "wb");if (pipe!=NULL) PCLOSE(pipe);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){if (wcsstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
static void main_sink(){wchar_t * data=_main_data;{wchar_t data_src[10+1]=SRC_STRING;size_t i, src_len;src_len=wcslen(data_src);for (i=0;i < src_len;i++){data[i]=data_src[i];}printWLine(data);free(data);}}static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));_main_data=data;main_sink();}
static void main_sink(){int data=main_data;{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}static void main(){int data;data=-1;data=20;main_data=data;main_sink();}
void main_sink_b(char * data);static void main(){char * data;data=NULL;data=new char[100];main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_d(char * data);void main_sink_c(char * data){main_sink_d(data);}void main_sink_e(char * data);void main_sink_d(char * data){main_sink_e(data);}void main_sink_e(char * data){{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}printLine(data);delete [] data;}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';{wchar_t * data=*data_ptr1;data=data_buf;}{wchar_t * data=*data_ptr2;{size_t i;wchar_t dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);}}}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{char src[100];memcpy(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}
static void main(){twoints * data;twoints * &data_ref=data;data=NULL;data=new twoints;{twoints * data=data_ref;delete data;}}
static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;{wchar_t dest[50]=L"";wcscat(dest, data);printWLine(data);}}
void _main_sink(twoints * data){printStructLine(data);free(data);}static void main(){twoints * data;data=NULL;data=(twoints *)malloc(sizeof(*data));data->a=1;data->b=2;_main_sink(data);}
static void main_sink(char * data){}static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;data=(char *)malloc(100*sizeof(char));free(data);func_ptr(data);}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{size_t i, dest_sz;char dest[100];memset(dest, 'C', 100-1);dest_sz=strlen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);}}
static void main(){char data;data=' ';data=(char)rand();_main_data=data;b_main_sink();}void b_main_sink(){char data=_main_data;{char result=0;if (data > CHAR_MIN){result=data-1;printHexCharLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static void main(){twointsclass * data;twointsclass * *data_ptr1=&data;twointsclass * *data_ptr2=&data;data=NULL;{twointsclass * data=*data_ptr1;data=(twointsclass *)calloc(100, sizeof(twointsclass));}{twointsclass * data=*data_ptr2;free(data);}}
static void main(){wchar_t * data;wchar_t * &data_ref=data;data=NULL;data=new wchar_t[100];{wchar_t * data=data_ref;{wchar_t src[100];_snwprintf(data, 100, L"%s", src);printWLine(data);delete [] data;}}}
static void main(){int data;data=-1;if(global_returns_t_or_f()){data=100-1;}else{data=100-1;}{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
static void main(){int data;data=-1;data=100-1;{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
static void main(){int count;count=-1;count=20;{size_t i=0;FILE *file=NULL;const char *filename="output_bad.txt";file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}
static void main(){struct _twoints * data;_struct_type my_struct;data=NULL;data=(struct _twoints *)calloc(100, sizeof(struct _twoints));data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){struct _twoints * data=my_struct.a;free(data);}
static void main(){int data;int data_array[5];data=-1;data=20;data_array[2]=data;main_sink(data_array);}void main_sink(int data_array[]){int data=data_array[2];{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char data_buf[100]="";data=data_buf;strcat(data, "*.*");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnvp(_P_WAIT, COMMAND_INT, args);}}
static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]="";data=data_buf;strcpy(data, "15");func_ptr(data);}void b_main_sink(char * data){{int i, n, v;if (sscanf(data, "%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnvp(_P_WAIT, COMMAND_INT, args);}}
static void main(){unsigned char data;_struct_type my_struct;data=' ';data=(unsigned char)rand();my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){unsigned char data=my_struct.a;{unsigned char result=-1;if (data <=(unsigned char)sqrt((unsigned char)UCHAR_MAX)){result=data * data;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;_wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){char * data;data=NULL;data=new char[100];main_sink(data);}void main_sink(char * data){delete [] data;}
static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;strcat(data, "*.*");my_union.a=data;{char * data=my_union.b;EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}}
static void main(){int count;count=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;count=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(count);}void b_main_sink(int count){c_main_sink(count);}void c_main_sink(int count){{size_t i=0;if (count > 0 && count <=20){for (i=0;i < (size_t)count;i++){printLine("Hello");}}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");{wchar_t * data_copy=data;wchar_t * data=data_copy;main_vasink(data, data);}}
static void main(){twoints * data;union_type my_union;data=NULL;data=NULL;data=(twoints *)realloc(data, 100*sizeof(twoints));my_union.a=data;{twoints * data=my_union.b;free(data);}}
static void main(){int * data;data=(int *)ALLOCA(10*sizeof(int));{int i;for(i=0;i<10;i++){data[i]=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}}
static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}func_ptr(data);}void b_main_sink(char * data){{char dest[100]="";SNPRINTF(dest, 100-1, "%s", data);printLine(dest);}}
static void main(){int data;_struct_type my_struct;data=-1;data=5;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{int result=data-1;printIntLine(result);}}
static void main(){wchar_t * data;union_type my_union;data=NULL;data=new wchar_t[100];my_union.a=data;{wchar_t * data=my_union.b;{size_t i, dest_sz;wchar_t dest[100];wmemset(dest, L'C', 100-1);dest_sz=wcslen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);delete [] data;}}}
static void main(){int data;data=-1;if(global_returns_t_or_f()){data=5;}else{data=5;}if(global_returns_t_or_f()){{int result=data * data;printIntLine(result);}}else{{int result=data * data;printIntLine(result);}}}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=20;}{int data=*data_ptr2;{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}}
static void main(){int data;data=-1;data=20;{int data_copy=data;int data=data_copy;{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}}
void _main_sink(int * data){printIntLine(data[0]);free(data);}static void main(){int * data;{int * data_buf=(int *)malloc(100*sizeof(int));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}_main_sink(data);}
void _main_sink(char * data){{char src[100];strcpy(data, src);printLine(data);}}static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;_main_sink(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnv(_P_WAIT, COMMAND_INT_PATH, args);}}}
static twointsclass * main_source(twointsclass * data){data=new twointsclass[100];{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}return data;}static void main(){twointsclass * data;data=NULL;data=main_source(data);printIntLine(data[0].a);}
static void main_sink(wchar_t * data){{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));printWLine(data);free(data);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));func_ptr(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));func_ptr(data);}void b_main_sink(wchar_t * data){{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));printWLine(data);free(data);}}
void main_sink(char * * data);static void main(){char * data;data=new char[100];main_sink(&data);}void main_sink(char * * data_ptr){char * data=*data_ptr;{char dest[50]="";strncpy(dest, data, strlen(data));printLine(data);delete [] data;}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data="P";b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){int count;count=-1;count=20;{size_t i=0;FILE *file=NULL;const char *filename="output_bad.txt";file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}main_sink(&data);}void main_sink(void * void_data_ptr){twointsclass * * data_ptr=(twointsclass * *)void_data_ptr;twointsclass * data=(*data_ptr);printIntLine(data[0].a);}
static void main_sink(){char * data=_main_data;{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");_main_data=data;main_sink();}
static char * main_source(char * data){strcat(data, "file.txt");return data;}static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;data=main_source(data);{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
static void main(){unsigned int data;data=0;data=5;b_main_sink(data);}void b_main_sink(unsigned int data){{unsigned int result=data * data;printUnsignedLine(result);}}
static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));free(data);}
static void main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;strcat(data, "*.*");func_ptr(data);}
static void main(){int * data;data=NULL;data=NULL;data=(int *)realloc(data, 100*sizeof(int));data[0]=5;printIntLine(data[0]);b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * * data_ptr=(int * *)void_data_ptr;int * data=(*data_ptr);free(data);}
static void main(){if(global_returns_t_or_f()){{wchar_t * filename;int fd;filename=_wtempnam(NULL, NULL);printWLine(filename);fd=OPEN(filename, O_CREAT|O_EXCL, S_IREAD|S_IWRITE);if (fd!=-1){printLine("Temporary file was opened...now closing file");CLOSE(fd);}if (filename!=NULL){free(filename);}}}else{{wchar_t * filename;int fd;filename=_wtempnam(NULL, NULL);printWLine(filename);fd=OPEN(filename, O_CREAT|O_EXCL, S_IREAD|S_IWRITE);if (fd!=-1){printLine("Temporary file was opened...now closing file");CLOSE(fd);}if (filename!=NULL){free(filename);}}}}
static char * main_source(char * data){strcat(data, "*.*");return data;}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){bad_struct data;bad_struct *data_ptr1=&data;bad_struct *data_ptr2=&data;linked_list head={&head, &head};data.list.next=head.next;data.list.prev=&head;head.next=&data.list;head.next->prev=&data.list;{bad_struct data=*data_ptr1;}{bad_struct data=*data_ptr2;* */prev=data.list.prev;next=data.list.next;prev->next=next;next->prev=prev;}}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t dest[100];wmemset(dest, L'C', 100-1);memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){int data;data=-1;data=7;{int data_copy=data;int data=data_copy;printIntLine(100 % data);}}
static void main(){char * data;_union_type my_union;data=NULL;data=NULL;data=(char *)realloc(data, 100*sizeof(char));strcpy(data, "A String");printLine(data);my_union.a=data;{char * data=my_union.b;free(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(data);}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}void b_main_sink(wchar_t * data){main_vasink(data, data);}
static char * main_source(char * password){{size_t password_len=0;fgets(password, 100, stdin);password_len=strlen(password);if (password_len > 0){password[password_len-1]='\0';}}return password;}static void main(){char * password;char password_buf[100]="";password=password_buf;password=main_source(password);{HANDLE pHandle;char * username="User";char * domain="Domain";if (LogonUserA( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}
static void main(){int data;fscanf (stdin, "%d", &data);{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0 && data < 10){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){long long * data;data=NULL;data=new long long;printLongLongLine(*data);main_sink_b(data);}void main_sink_b(long long * data){main_sink_c(data);}void main_sink_c(long long * data){main_sink_d(data);}void main_sink_d(long long * data){main_sink_e(data);}void main_sink_e(long long * data){delete data;}
static void main(){{WSADATA wsadata;BOOL wsa_init=FALSE;SOCKET listener=INVALID_SOCKET;SOCKET client=INVALID_SOCKET;struct sockaddr_in s_in;struct sockaddr_in s_in_client;int s_in_client_len;struct hostent *h_client;FILE * file;do{if (0!=WSAStartup(MAKEWORD(2, 2), &wsadata)) break;wsa_init=TRUE;listener=socket(PF_INET, SOCK_STREAM, 0);if (listener==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(LISTEN_PORT);if (SOCKET_ERROR==bind(listener, (struct sockaddr*)&s_in, sizeof(s_in))) break;if (SOCKET_ERROR==listen(listener, LISTEN_BACKLOG)) break;s_in_client_len=sizeof(s_in_client);client=accept(listener, (struct sockaddr*)&s_in_client, &s_in_client_len);if (client==INVALID_SOCKET) break;if (s_in_client.sin_family!=AF_INET) break;h_client=gethostbyaddr((char*)&s_in_client.sin_addr, sizeof(s_in_client.sin_addr), AF_INET);if (h_client==NULL) break;if (h_client->h_name==NULL) break;printLine(h_client->h_name);file=fopen("log.txt", "a+");fprintf(file, "Host name: %s\n", h_client->h_name);fclose(file);}while (0);if (client!=INVALID_SOCKET) CLOSESOCKET(client);if (listener!=INVALID_SOCKET) CLOSESOCKET(listener);if (wsa_init) WSACleanup();}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=20;}{int data=*data_ptr2;{size_t a,i;int *b;b=(int*)new char[a];for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);delete [] b;}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{wchar_t src[100];wcsncpy(data, src, 100);printWLine(data);free(data);}}
static void main(){unsigned int data;_struct_type my_struct;data=0;data=(unsigned int)RAND32();my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){unsigned int data=my_struct.a;{unsigned int result=-1;if (data <=(UINT_MAX/2)){result=data * 2;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");{char * data_copy=data;char * data=data_copy;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnvp(_P_WAIT, COMMAND_INT, args);}}
static void main(){int * data;data=NULL;data=new int;main_sink(&data);}void main_sink(void * void_data_ptr){int * * data_ptr=(int * *)void_data_ptr;int * data=(*data_ptr);delete data;}
void b_main_sink(long long * data);static void main(){long long * data;data=(long long *)calloc(100, sizeof(long long));b_main_sink(data);}void c_main_sink(long long * data);void b_main_sink(long long * data){c_main_sink(data);}void d_main_sink(long long * data);void c_main_sink(long long * data){d_main_sink(data);}void e_main_sink(long long * data);void d_main_sink(long long * data){e_main_sink(data);}void e_main_sink(long long * data){if (data!=NULL){data[0]=5L;printLongLongLine(data[0]);free(data);}}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}main_data=data;main_sink();}void main_sink(){int data=main_data;{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main_sink(twoints * data){}static void main(){twoints * data;data=NULL;{twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine(&data[0]);}main_sink(data);}
static void main(){{HANDLE hFile;wchar_t * filename=L"C:\\temp\\file.txt";hFile=CreateFileW( filename, GENERIC_READ, FILE_SHARE_READ, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile==INVALID_HANDLE_VALUE){printLine("File could not be created");}else{printLine("File created successfully");CloseHandle(hFile);}}}
char * main_source(char * data);static void main(){char * data;data=new char[100];data=main_source(data);{char dest[50]="";strcpy(dest, data);printLine(data);delete [] data;}}char * main_source(char * data){return data;}
void b_main_sink(char * data);static void main(){char * data;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}b_main_sink(data);}void b_main_sink(char * data){{char dest[100];strncpy(dest, data, strlen(dest));dest[100-1]='\0';printLine(dest);}}
static void main(){unsigned int data;data=0;data=(unsigned int)RAND32();b_main_sink(data);}void b_main_sink(unsigned int data){c_main_sink(data);}void c_main_sink(unsigned int data){d_main_sink(data);}void d_main_sink(unsigned int data){{unsigned int result=-1;if (data <=(UINT_MAX/2)){result=data * 2;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=NULL;{char * data=*data_ptr1;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}}{char * data=*data_ptr2;{char src[100];strcpy(data, src);printLine(data);}}}
static int main_source(int data){data=100-1;return data;}static void main(){int data;data=-1;data=main_source(data);{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
static void main(){int data;_union_type my_union;data=-1;data=5;my_union.a=data;{int data=my_union.b;{int result=data * data;printIntLine(result);}}}
static void main(){char * data;data=NULL;data=NULL;data=(char *)realloc(data, 100*sizeof(char));main_sink(data);}void main_sink(char * data){free(data);}
static void main_sink(int * data){printIntLine(data[0]);}static void main(){int * data;void (*func_ptr) (int *)=main_sink;data=NULL;data=new int[100];{size_t i;for(i=0;i < 100;i++){data[i]=5;}}func_ptr(data);}
short b_main_source(short data);static void main(){short data;data=-1;data=b_main_source(data);{char c=(char)data;printHexCharLine(c);}}short b_main_source(short data){data=CHAR_MAX-5;return data;}
static void main_sink(twoints * data){free(data);}static void main(){twoints * data;void (*func_ptr) (twoints *)=main_sink;data=NULL;data=NULL;data=(twoints *)realloc(data, 100*sizeof(twoints));func_ptr(data);}
static void main(){struct _twoints * data;data=NULL;data=new struct _twoints[100];data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);main_sink(data);}void main_sink(struct _twoints * data){delete[] data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}wchar_t * b_main_source(wchar_t * data){data=L"P";return data;}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));data=data_buf;}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);printWLine(data);free(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, data);printWLine(dest);}}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");{wchar_t * data_copy=data;wchar_t * data=data_copy;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){_wsystem(data);}
static void main_sink(char * data){EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;strcat(data, "*.*");func_ptr(data);}
void b_main_sink(char * data);static void main(){char * data;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{size_t i;char dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){printf(data);}
static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));data[0]=5L;printLongLongLine(data[0]);b_main_sink(data);}void b_main_sink(long long * data){c_main_sink(data);}void c_main_sink(long long * data){free(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"15");b_main_sink(data);}void b_main_sink(wchar_t * data){{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main(){int count;void (*func_ptr) (int)=b_main_sink;count=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;count=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}func_ptr(count);}void b_main_sink(int count){{size_t i=0;if (count > 0 && count <=20){for (i=0;i < (size_t)count;i++){printLine("Hello");}}}}
static void main(){char * data;data=NULL;data=(char *)calloc(100, sizeof(char));strcpy(data, "A String");printLine(data);free(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=(wchar_t *)malloc(100);b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){if (data!=NULL){wcscpy(data, L"Initialize");printWLine(data);free(data);}}
static int main_source(int data){data=20;return data;}static void main(){int data;data=-1;data=main_source(data);{size_t i;int *b;b=(int*)malloc(data * sizeof(int));for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);free(b);}}
static void main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}main_sink(data);}
static void main(){int * data;int * data_array[5];data=NULL;data=(int *)malloc(100*sizeof(int));data_array[2]=data;main_sink(data_array);}void main_sink(int * data_array[]){int * data=data_array[2];free(data);}
static void main(){twointsclass * data;data=NULL;data=(twointsclass *)calloc(100, sizeof(twointsclass));main_sink(&data);}void main_sink(twointsclass * * data_ptr){twointsclass * data=*data_ptr;free(data);}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char data_buf[100];data=data_buf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{char src[100];strcat(data, src);printLine(data);}}
static void main(){unsigned char data;_union_type my_union;data=' ';data=5;my_union.a=data;{unsigned char data=my_union.b;{unsigned char result=data * data;printHexUnsignedCharLine(result);}}}
static const int *helper_good(){static Foo foo;*/return foo.get_x();}static void main(){printIntLine(*helper_good());}
void main_sink();static void main(){char * data;data=NULL;data=new char[100];_main_data=data;main_sink();}void main_sink(){char * data=_main_data;{char dest[100];memset(dest, 'C', 100-1);memmove(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);delete [] data;}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;{int data=*data_ptr1;data=7;}{int data=*data_ptr2;{wchar_t data_buf[10]=L"AAAAAAAAA";if (data >=0){printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t src[100];wcsncpy(data, src, 100);printWLine(data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){e_main_sink(data);}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf("%s", args);va_end(args);}}void e_main_sink(char * data){main_vasink(data, data);}
void b_main_sink();static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main_sink(FILE * data){fclose(data);}static void main(){FILE * data;data=fopen("GoodSource_fopen.txt", "w+");main_sink(data);}
static void main_sink(){int data=_main_data;{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than the length of the source string or too large");}}}static void main(){int data;data=-1;fscanf (stdin, "%d", &data);_main_data=data;main_sink();}
void _main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_sink(data);}
static void main(){int data;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];wmemset(data, L'A', 100-1);data[100-1]=L'\0';delete [] data;main_sink_b(data);}void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_d(wchar_t * data){}
static void main(){short data;data=-1;data=CHAR_MAX-5;{char c=(char)data;printHexCharLine(c);}}
static void main_sink(char data){{char result=data * 2;printHexCharLine(result);}}static void main(){char data;void (*func_ptr) (char)=main_sink;data=' ';data=5;func_ptr(data);}
static void main(){int data;data=b_main_source(data);{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}int b_main_source(int data){data=RAND32();return data;}
static char * main_source(char * data){strcat(data, "*.*");return data;}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
static void main(){int data;data=-1;data=5;{int data_copy=data;int data=data_copy;{int result=data * data;printIntLine(result);}}}
static void main_sink(){wchar_t * data=_main_data;{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));printWLine(data);}}static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;_main_data=data;main_sink();}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(L"%s", args);va_end(args);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *, ...)=main_vasink;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}printWLine(data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){if (strstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
static void main(){char * data;data=NULL;data=new char;delete data;}
static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}{wchar_t dest[100];wcscpy(dest, data);printWLine(dest);}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;{wchar_t * data=*data_ptr1;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");}{wchar_t * data=*data_ptr2;{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}}
static void main(){char * data;char * data_array[5];char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];fprintf(stdout, data);}
static void main_sink(short data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}static void main(){short data;void (*func_ptr) (short)=main_sink;data=0;data=100-1;func_ptr(data);}
void b_main_sink(int data);static void main(){int data;data=-1;data=100-1;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[250]="PATH=";data=data_buf;{char * data=*data_ptr1;strcat(data, NEW_PATH);}{char * data=*data_ptr2;PUTENV(data);}}
static void main_sink(){FILE * data=_main_data;if (data!=NULL){fclose(data);}}static void main(){FILE * data;data=NULL;data=fopen("BadSource_fopen.txt", "w+");_main_data=data;main_sink();}
static void main_sink(){char * data=_main_data;if (strstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;_main_data=data;main_sink();}
static void main(){char * data;data=NULL;data=(char *)malloc((10+1)*sizeof(char));{char data_src[10+1]=SRC_STRING;strncpy(data, data_src, strlen(data_src));printLine(data);free(data);}}
static void main(){int data;data=-1;data=main_source(data);{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}int main_source(int data){data=20;return data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t src[100];wcsncat(data, src, 100);printWLine(data);}}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;my_union.a=data;{wchar_t * data=my_union.b;{wchar_t src[100];wcsncpy(data, src, 100);printWLine(data);}}}
static void main_sink(){char * data=main_data;delete data;}static void main(){char * data;data=NULL;data=new char;main_data=data;main_sink();}
static void main_sink(){wchar_t * data=_main_data;if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}_main_data=data;main_sink();}
static void main(){unsigned char data;unsigned char data_array[5];data=' ';data=5;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(unsigned char data_array[]){unsigned char data=data_array[2];{unsigned char result=data * 2;printHexUnsignedCharLine(result);}}
static void main(){wchar_t * data;wchar_t * &data_ref=data;data=NULL;data=new wchar_t;{wchar_t * data=data_ref;delete data;}}
static void main_sink(char * data){if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;data=PASSWORD;func_ptr(data);}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=b_main_source(data);{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));printWLine(data);free(data);}}wchar_t * b_main_source(wchar_t * data){data=(wchar_t *)malloc(100*sizeof(wchar_t));return data;}
static void main(){struct _twoints * data;data=NULL;data=new struct _twoints;data->a=0;data->b=0;printStructLine((twoints *)data);main_sink_b(data);}void main_sink_b(struct _twoints * data){main_sink_c(data);}void main_sink_c(struct _twoints * data){main_sink_d(data);}void main_sink_d(struct _twoints * data){main_sink_e(data);}void main_sink_e(struct _twoints * data){delete data;}
void b_main_sink(short * data);static void main(){short data;data=0;data=100-1;b_main_sink(&data);}void b_main_sink(short * data_ptr){short data=*data_ptr;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t dest[100];wmemset(dest, L'C', 100-1);memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
void _main_sink(wchar_t * data){_wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_sink(data);}
static void main(){{char data_buf[100]="";char * data=data_buf;strcpy(data, "abcdefghijklmnopqrstuvwxyz");memmove(data+6, data+4, 10*sizeof(char));printLine(data);}}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;data=b_main_source(data);{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}wchar_t * b_main_source(wchar_t * data){wcscat(data, L"file.txt");return data;}
void b_main_sink(short data);static void main(){short data;data=0;data=100-1;b_main_sink(data);}void c_main_sink(short data);void b_main_sink(short data){c_main_sink(data);}void d_main_sink(short data);void c_main_sink(short data){d_main_sink(data);}void d_main_sink(short data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=NULL;{char * data=*data_ptr1;data=new char;delete data;}{char * data=*data_ptr2;}}
static void main(){{char * data;char * * pointer=(char * *)malloc(sizeof(char *));data="string";{char * data=*pointer;printLine(data);}free(pointer);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"C:\\Windows\\System32\\winsrv.dll");{HMODULE hModule;hModule=LoadLibraryW(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
static void main_source(char * &data){data=new char[100];}static void main(){char * data;data=NULL;main_source(data);delete [] data;}
static void main(){wchar_t * data;data=NULL;data=NULL;data=(wchar_t *)realloc(data, 100*sizeof(wchar_t));main_sink_b(data);}void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){free(data);}
static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t dest[100];wmemset(dest, L'C', 100-1);memmove(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}}
static void main(){int data;data=7;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);{wchar_t data_buf[10]=L"AAAAAAAAA";if (data >=0){printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main(){wchar_t * data;struct_type my_struct;data=NULL;data=new wchar_t[100];delete [] data;my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){wchar_t * data=my_struct.a;}
static void main(){char * data;char data_buf[100]="";data=data_buf;if(global_returns_t_or_f()){strcpy(data, "C:\\Windows\\System32\\winsrv.dll");}else{strcpy(data, "C:\\Windows\\System32\\winsrv.dll");}{HMODULE hModule;hModule=LoadLibraryA(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
static void main(){twoints * data;data=NULL;data=NULL;data=(twoints *)realloc(data, 100*sizeof(twoints));data[0].a=0;data[0].b=0;printStructLine(&data[0]);free(data);}
static void main(){char data;_struct_type my_struct;data=' ';data=(char)rand();my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char data=my_struct.a;{char result=-1;if (data <=(CHAR_MAX/2)){result=data * 2;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main_sink(){short data=_main_data;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}static void main(){short data;data=0;data=100-1;_main_data=data;main_sink();}
static void main(){char * data;_struct_type my_struct;data=NULL;data=NULL;data=(char *)realloc(data, 100*sizeof(char));strcpy(data, "A String");printLine(data);my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;free(data);}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
static char * main_source(char * data){strcat(data, "*.*");return data;}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
static void main(){{wchar_t * data;wchar_t * * pointer=(wchar_t * *)malloc(sizeof(wchar_t *));data=L"string";{wchar_t * data=*pointer;printWLine(data);}free(pointer);}}
static void main(){{char dst[DST_SZ];memcpy(dst, COPY_STR, (DST_SZ-1)*sizeof(char));dst[DST_SZ-1]='\0';printLine(dst);}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=100-1;}{int data=*data_ptr2;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}}
void b_main_sink(void * void_data_ptr);static void main(){short data;data=-1;data=CHAR_MAX-5;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){short * data_ptr=(short *)void_data_ptr;short data=(*data_ptr);{char c=(char)data;printHexCharLine(c);}}
static void main_sink(wchar_t * data){if (wcsstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;func_ptr(data);}
static void main(){char * data;data=new char[100];{char * data_copy=data;char * data=data_copy;{char dest[50]="";strcpy(dest, data);printLine(data);delete [] data;}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;b_main_sink(data);}void b_main_sink(char * data){{char src[100];strcpy(data, src);printLine(data);}}
static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));free(data);}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;{wchar_t * data=*data_ptr1;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");}{wchar_t * data=*data_ptr2;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}}
void b_main_sink(_struct_type my_struct);static void main(){FILE * data;_struct_type my_struct;data=NULL;data=fopen("file.txt", "w+");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){FILE * data=my_struct.a;if (data!=NULL){fclose(data);}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;{int data=*data_ptr1;data=7;}{int data=*data_ptr2;{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{int i, n, v;if (swscanf(data, L"%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static void main_sink(){twointsclass * data=main_data;delete data;}static void main(){twointsclass * data;data=NULL;data=new twointsclass;data->a=0;data->b=0;printIntLine(data->a);printIntLine(data->b);main_data=data;main_sink();}
void b_main_sink(char * data);static void main(){char * data;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{char src[100];strcpy(data, src);printLine(data);}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t;main_sink_b(data);}void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_d(wchar_t * data){main_sink_e(data);}void main_sink_e(wchar_t * data){delete data;}
static void main(){unsigned int data;data=0;data=5;b_main_sink(data);}void b_main_sink(unsigned int data){{unsigned int result=data+1;printUnsignedLine(result);}}
void b_main_sink(void * void_data_ptr);static void main(){int * data;{int * data_buf=(int *)malloc(100*sizeof(int));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * * data_ptr=(int * *)void_data_ptr;int * data=(*data_ptr);printIntLine(data[0]);free(data);}
static void main(){int data;data=-1;data=20;{int data_copy=data;int data=data_copy;{size_t i;int *b;b=(int*)malloc(data * sizeof(int));for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);free(b);}}}
void b_main_sink();static void main(){short data;data=0;data=100-1;_main_data=data;b_main_sink();}void b_main_sink(){short data=_main_data;{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");func_ptr(data);}void b_main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
void main_sink(wchar_t * * data);static void main(){wchar_t * data;data=new wchar_t[100];main_sink(&data);}void main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{wchar_t dest[50]=L"";memmove(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);delete [] data;}}
static void main(){char * data;char * &data_ref=data;data=NULL;data=new char[100];{char * data=data_ref;{char src[100];strcat(data, src);printLine(data);delete [] data;}}}
void main_source(wchar_t * &data);static void main(){wchar_t * data;data=NULL;main_source(data);{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));printWLine(data);delete [] data;}}void main_source(wchar_t * &data){data=new wchar_t[100];}
void b_main_sink(short * data);static void main(){short data;data=0;data=100-1;b_main_sink(&data);}void b_main_sink(short * data_ptr){short data=*data_ptr;{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
void b_main_sink(short * data);static void main(){short data;data=0;data=100-1;b_main_sink(&data);}void b_main_sink(short * data_ptr){short data=*data_ptr;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
static void main(){int count;void (*func_ptr) (int)=b_main_sink;count=-1;count=20;func_ptr(count);}void b_main_sink(int count){{size_t i=0;for (i=0;i < (size_t)count;i++){printLine("Hello");}}}
static void main(){char data;char *data_ptr1=&data;char *data_ptr2=&data;data=' ';{char data=*data_ptr1;data=5;}{char data=*data_ptr2;{char result=data * 2;printHexCharLine(result);}}}
static wchar_t * main_source(wchar_t * data){data=PASSWORD;return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);if (wcsncmp(PASSWORD, data, wcslen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char data_buf[100]="";data=data_buf;strcat(data, "*.*");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
void b_main_sink(FILE * data);static void main(){FILE * data;void (*func_ptr) (FILE *)=b_main_sink;data=NULL;data=WFOPEN(L"file.txt", L"w+");func_ptr(data);}void b_main_sink(FILE * data){if (data!=NULL){fclose(data);}}
static void main(){short data;data=0;data=100-1;{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
static void main(){char * data;data=NULL;if(global_returns_t_or_f()){data=new char[100];}else{data=new char[100];}if(global_returns_t_or_f()){delete [] data;}else{delete [] data;}}
void b_main_sink(_struct_type my_struct);static void main(){int data;_struct_type my_struct;data=-1;data=CHAR_MAX-5;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{short s=(short)data;printf("%hd\n", s);}}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}func_ptr(data);}void b_main_sink(wchar_t * data){{int i, n, v;if (swscanf(data, L"%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static void main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}func_ptr(data);}
static void main_sink(long long * data){free(data);}static void main(){long long * data;void (*func_ptr) (long long *)=main_sink;data=NULL;data=(long long *)malloc(100*sizeof(long long));func_ptr(data);}
char * b_main_source(char * data);static void main(){char * data;data=(char *)malloc(100*sizeof(char));data=b_main_source(data);{char dest[50]="";memmove(dest, data, strlen(data)*sizeof(char));printLine(data);free(data);}}char * b_main_source(char * data){return data;}
static void main(){twointsclass * data;union_type my_union;data=NULL;{twointsclass * tmp=new twointsclass;tmp->a=0;tmp->b=0;data=tmp;}my_union.a=data;{twointsclass * data=my_union.b;printIntLine(data[0].a);}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}{twointsclass * data_copy=data;twointsclass * data=data_copy;printIntLine(data[0].a);}}
static void main(){int count;count=-1;count=20;b_main_sink(&count);}void b_main_sink(int * count_ptr){int count=*count_ptr;{size_t i=0;for (i=0;i < (size_t)count;i++){printLine("Hello");}}}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, "%s", args);va_end(args);}}static void main(){char * data;void (*func_ptr) (char *, ...)=main_vasink;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}func_ptr(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;if (wcsncmp(PASSWORD, data, wcslen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){wchar_t * data;wchar_t * &data_ref=data;data=NULL;data=new wchar_t[100];{wchar_t * data=data_ref;{wchar_t src[100];wcscat(data, src);printWLine(data);delete [] data;}}}
static void main(){long long * data;data=NULL;data=(long long *)calloc(100, sizeof(long long));main_sink(&data);}void main_sink(void * void_data_ptr){long long * * data_ptr=(long long * *)void_data_ptr;long long * data=(*data_ptr);free(data);}
static void main_sink(twointsclass * data){free(data);}static void main(){twointsclass * data;void (*func_ptr) (twointsclass *)=main_sink;data=NULL;data=NULL;data=(twointsclass *)realloc(data, 100*sizeof(twointsclass));func_ptr(data);}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"15");func_ptr(data);}void b_main_sink(wchar_t * data){{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{wchar_t dest[100];wmemset(dest, L'C', 100-1);memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main_sink(int * data){printIntLine(data[0]);}static void main(){int * data;data=NULL;data=(int *)malloc(100*sizeof(int));{size_t i;for(i=0;i < 100;i++){data[i]=5;}}main_sink(data);}
int * b_main_source(int * data);static void main(){int * data;data=b_main_source(data);printIntLine(data[0]);free(data);}int * b_main_source(int * data){{int * data_buf=(int *)malloc(100*sizeof(int));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}return data;}
static wchar_t * main_source(wchar_t * data){data=(wchar_t *)calloc(100, sizeof(wchar_t));return data;}static void main(){wchar_t * data;data=main_source(data);if (data!=NULL){wcscpy(data, L"Initialize");printWLine(data);free(data);}}
static void main(){twoints * data;data=new twoints[10];if(global_returns_t_or_f()){{int i;for(i=0;i<10;i++){data[i].a=i;data[i].b=i;}}}else{{int i;for(i=0;i<10;i++){data[i].a=i;data[i].b=i;}}}if(global_returns_t_or_f()){{int i;for(i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}delete [] data;}else{{int i;for(i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}delete [] data;}}
static void main(){int data;data=-1;data=5;_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{int result=data * 2;printIntLine(result);}}
static void main(){if(global_returns_t_or_f()){{HWINSTA hWStation;char * wStationName="WindowsStationExample";hWStation=CreateWindowStationA( wStationName, 0, GENERIC_READ, NULL);if (hWStation==NULL){printLine("Windows station could not be created");}else{printLine("Windows Station created successfully");CloseWindowStation(hWStation);}}}else{{HWINSTA hWStation;char * wStationName="WindowsStationExample";hWStation=CreateWindowStationA( wStationName, 0, GENERIC_READ, NULL);if (hWStation==NULL){printLine("Windows station could not be created");}else{printLine("Windows Station created successfully");CloseWindowStation(hWStation);}}}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=100-1;}{int data=*data_ptr2;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}}
static wchar_t * main_source(wchar_t * data){{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main_sink(char * data){free(data);}static void main(){char * data;data=NULL;data=NULL;data=(char *)realloc(data, 100*sizeof(char));main_sink(data);}
static void main(){int data;int &data_ref=data;data=-1;data=20;{int data=data_ref;{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *, ...)=b_main_vasink;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}void b_main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(L"%s", args);va_end(args);}}
void main_source(char * &data);static void main(){char * data;data=new char[100];main_source(data);{char dest[50]="";strncat(dest, data, strlen(data));printLine(data);delete [] data;}}void main_source(char * &data){}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]=L'\0';printWLine(data);}}
static void main(){int * data;data=NULL;data=new int;printIntLine(*data);}
static void main(){int data;data=-1;data=20;b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}
void b_main_sink(long long * data);static void main(){long long * data;data=(long long *)malloc(100);b_main_sink(data);}void b_main_sink(long long * data){if (data!=NULL){data[0]=5L;printLongLongLine(data[0]);free(data);}}
void _main_sink(char * data){{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");_main_sink(data);}
void b_main_sink(int * data_array[]);static void main(){int * data;int * data_array[5];int * data_badbuf=(int *)ALLOCA(50*sizeof(int));int * data_goodbuf=(int *)ALLOCA(100*sizeof(int));data=data_goodbuf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int * data_array[]){int * data=data_array[2];{memmove(data, src, 100*sizeof(int));printIntLine(data[0]);}}
static void main_sink(int data){{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}static void main(){int data;data=7;main_sink(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}{wchar_t * data_copy=data;wchar_t * data=data_copy;if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}}
static void main(){char * data;char data_buf[100];data=data_buf;if(global_returns_t_or_f()){}else{}{char src[100];strcat(data, src);printLine(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"15");{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
void b_main_sink(_struct_type my_struct);static void main(){int * data;_struct_type my_struct;{int * data_buf=(int *)malloc(100*sizeof(int));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int * data=my_struct.a;printIntLine(data[0]);free(data);}
static void main(){int data;int &data_ref=data;data=-1;data=20;{int data=data_ref;{size_t a,i;int *b;b=(int*)new char[a];for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);delete [] b;}}}
static void main(){long long * data;long long * *data_ptr1=&data;long long * *data_ptr2=&data;data=NULL;{long long * data=*data_ptr1;data=new long long[100];}{long long * data=*data_ptr2;delete [] data;}}
void b_main_sink();static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}{wchar_t * data_copy=data;wchar_t * data=data_copy;{size_t i;wchar_t dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);}}}
static void main_sink(){char data=_main_data;{char result=0;if (data > CHAR_MIN){result=data-1;printHexCharLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}static void main(){char data;data=' ';data=CHAR_MIN;_main_data=data;main_sink();}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "15");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{int i, n, v;if (sscanf(data, "%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main(){unsigned char data;data=' ';if(global_returns_t_or_f()){data=5;}else{data=5;}if(global_returns_t_or_f()){{unsigned char result=data+1;printHexUnsignedCharLine(result);}}else{{unsigned char result=data+1;printHexUnsignedCharLine(result);}}}
static void main(){char * data;data=NULL;data=new char[100];delete [] data;}
static void main_source(twointsclass * &data){data=new twointsclass;data->a=1;data->b=2;delete data;}static void main(){twointsclass * data;data=NULL;main_source(data);}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';{wchar_t * data=*data_ptr1;data=data_buf;}{wchar_t * data=*data_ptr2;{wchar_t dest[100];wcsncpy(dest, data, wcslen(dest));dest[100-1]=L'\0';printWLine(dest);}}}
void b_main_sink(char * data);static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{size_t i, dest_sz;char dest[100];memset(dest, 'C', 100-1);dest_sz=strlen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);}}
static int main_source(int data){data=OPEN("BadSource_open.txt", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);return data;}static void main(){int data;data=-1;data=main_source(data);if (data!=-1){CLOSE(data);}}
static char * main_source(char * data){strcpy(data, "fixedstringtest");return data;}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf(data, args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);main_vasink(data, data);}
static void main(){long long * data;{long long * data_buf=new long long[100];{size_t i;for (i=0;i < 100;i++){data_buf[i]=5L;}}data=data_buf;}{long long * data_copy=data;long long * data=data_copy;printLongLongLine(data[0]);delete [] data;}}
static void main(){double * data;double * &data_ref=data;data=new double[10];{int i;for(i=0;i<10;i++){data[i]=(double)i;}}{double * data=data_ref;{int i;for(i=0;i<10;i++){printDoubleLine(data[i]);}}delete [] data;}}
static void main(){FILE * data;void (*func_ptr) (FILE *)=b_main_sink;data=fopen("GoodSource_fopen.txt", "w+");func_ptr(data);}void b_main_sink(FILE * data){fclose(data);}
static void main(){char * data;data=NULL;data=main_source(data);delete data;}char * main_source(char * data){data=new char;return data;}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));free(data);}
static void main(){char data;data=' ';if(global_returns_t_or_f()){data=5;}else{data=5;}if(global_returns_t_or_f()){{char result=data * data;printHexCharLine(result);}}else{{char result=data * data;printHexCharLine(result);}}}
static void main(){long long * data;struct_type my_struct;data=NULL;data=new long long[100];my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){long long * data=my_struct.a;delete [] data;}
static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;if(global_returns_t_or_f()){}else{}{char dest[50]="";strncpy(dest, data, strlen(data));printLine(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(wchar_t * data){if (wcsncmp(PASSWORD, data, wcslen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){wchar_t * data;data=NULL;wchar_t data_good;data=&data_good;printHexCharLine((char)*data);main_sink(data);}void main_sink(wchar_t * data){}
static wchar_t * main_source(wchar_t * data){{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}return data;}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, L"%s", args);va_end(args);printWLine(dest);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);main_vasink(data, data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, L"%s", args);va_end(args);}}void d_main_sink(wchar_t * data){main_vasink(data, data);}
static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));{size_t i;for(i=0;i < 100;i++){data[i]=5L;}}free(data);b_main_sink(data);}void b_main_sink(long long * data){c_main_sink(data);}void c_main_sink(long long * data){}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;main_sink(data);}void main_sink(twointsclass * data){delete data;}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){int data;data=7;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}{wchar_t dest[100];memmove(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char src[100];memmove(data, src, 100*sizeof(char));printLine(data);}}
void b_main_sink();static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{char dest[100];memmove(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
static void main(){char * data;char * &data_ref=data;data=NULL;data=new char[100];delete [] data;{char * data=data_ref;}}
static void main(){int data;_struct_type my_struct;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{char data_buf[10]="AAAAAAAAA";{printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;if(global_returns_t_or_f()){strcat(data, "*.*");}else{strcat(data, "*.*");}EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;printf(data);}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}main_sink(&data);}void main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}}{wchar_t * data=*data_ptr2;if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}}
static void main(){int data;data=-1;data=5;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){{int result=data-1;printIntLine(result);}}
static void main(){int data;data=-1;fscanf (stdin, "%d", &data);main_sink_b(data);}void main_sink_b(int data){main_sink_c(data);}void main_sink_c(int data){main_sink_d(data);}void main_sink_d(int data){main_sink_e(data);}void main_sink_e(int data){{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){long long * data;data=NULL;data=main_source(data);delete [] data;}long long * main_source(long long * data){data=new long long[100];return data;}
static void main(){int * data;data=NULL;data=new int;main_data=data;main_sink();}void main_sink(){int * data=main_data;delete data;}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]="";data=data_buf;{char * data=*data_ptr1;strcat(data, "*.*");}{char * data=*data_ptr2;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnvp(_P_WAIT, COMMAND_INT, args);}}}
static void main_sink(){char data=_main_data;{char result=data * 2;printHexCharLine(result);}}static void main(){char data;data=' ';data=5;_main_data=data;main_sink();}
static void main(){long long * data;{long long * data_buf=new long long[100];{size_t i;for (i=0;i < 100;i++){data_buf[i]=5L;}}data=data_buf;}printLongLongLine(data[0]);delete [] data;}
static void main_sink(){char * data=_main_data;{int i, n, v;if (sscanf(data, "%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}_main_data=data;main_sink();}
static void main_sink(){char * data=_main_data;{int i, n, v;if (sscanf(data, "%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "15");_main_data=data;main_sink();}
static void main(){char * data;data=NULL;data=new char[100];main_sink_b(data);}void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){delete [] data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;printf(data);}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=ASSERT_VALUE+1;}{int data=*data_ptr2;assert(data > ASSERT_VALUE);}}
static wchar_t * main_source(wchar_t * data){data=(wchar_t *)malloc(100*sizeof(wchar_t));return data;}static void main(){wchar_t * data;data=NULL;data=main_source(data);{wchar_t src[100];_snwprintf(data, 100, L"%s", src);printWLine(data);free(data);}}
static void main(){char data;data=' ';fscanf (stdin, "%c", &data);_main_data=data;b_main_sink();}void b_main_sink(){char data=_main_data;{char result=0;if (data > CHAR_MIN){result=data-1;printHexCharLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static void main(){twoints * data;union_type my_union;data=NULL;data=new twoints[100];{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}my_union.a=data;{twoints * data=my_union.b;printStructLine(&data[0]);}}
static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;strcat(data, "*.*");my_union.a=data;{char * data=my_union.b;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}}
static void main(){int data;data=RAND32();b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){char * data;data=NULL;data=(char *)calloc(100, sizeof(char));strcpy(data, "A String");printLine(data);free(data);}
static void main(){int * data;data=NULL;data=main_source(data);free(data);}int * main_source(int * data){data=(int *)malloc(100*sizeof(int));return data;}
void b_main_sink(short data);static void main(){short data;data=0;data=100-1;b_main_sink(data);}void b_main_sink(short data){{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;func_ptr(data);}void b_main_sink(wchar_t * data){{wchar_t dest[50]=L"";memmove(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);}}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;data=(wchar_t *)malloc(100);b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);if (data!=NULL){wcscpy(data, L"Initialize");printWLine(data);free(data);}}
static void main(){long long * data;void (*func_ptr) (long long *)=main_sink;data=NULL;data=new long long[100];func_ptr(data);}void main_sink(long long * data){delete [] data;}
static void main_sink(HANDLE data){CloseHandle(data);}static void main(){HANDLE data;void (*func_ptr) (HANDLE)=main_sink;data=CreateFile("GoodSource_w32CreateFile.txt", (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);func_ptr(data);}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, L"%s", data);printWLine(dest);}}
static wchar_t * main_source(wchar_t * data){wcscat(data, L"*.*");return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);_wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
void _main_sink(char * data){system(data);}static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, GOOD_OS_COMMAND);_main_sink(data);}
static void main(){twoints * data;void (*func_ptr) (twoints *)=main_sink;data=NULL;data=new twoints;func_ptr(data);}void main_sink(twoints * data){delete data;}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}
static float main_source(float data){data=7.0F;return data;}static void main(){float data;data=0.0F;data=main_source(data);printDoubleLine((double)(100.0/data));}
void b_main_sink(char * * data);static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{size_t i;char dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);}}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");my_union.a=data;{wchar_t * data=my_union.b;EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t dest[100];memmove(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;func_ptr(data);}void b_main_sink(wchar_t * data){{wchar_t src[100];wcsncpy(data, src, 100);printWLine(data);}}
static void main(){twoints * data;data=NULL;data=new twoints[100];{twoints * data_copy=data;twoints * data=data_copy;delete [] data;}}
static void main_sink(){int data=_main_data;{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than the length of the source string or too large");}}}static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}_main_data=data;main_sink();}
static void main_sink(wchar_t * data){delete data;}static void main(){wchar_t * data;data=NULL;data=new wchar_t;printHexCharLine((char)*data);main_sink(data);}
static void main(){struct _twoints * data;data=NULL;data=NULL;data=(struct _twoints *)realloc(data, 100*sizeof(struct _twoints));data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);free(data);}
static void main_sink(int data){{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}main_sink(data);}
static void main(){list<int> data;data.push_back(100);data.push_back(0);main_sink_b(data);}void main_sink_b(list<int> data){main_sink_c(data);}void main_sink_c(list<int> data){main_sink_d(data);}void main_sink_d(list<int> data){{list<int>::iterator i;cout << "The list contains: ";for( i=data.begin();i!=data.end();i++){cout << " " << *i;}cout << endl;}}
static void main_sink(int * data){}static void main(){int * data;data=NULL;data=new int;delete data;main_sink(data);}
static void main(){char * data;data=NULL;main_source(data);free(data);}void main_source(char * &data){data=(char *)calloc(100, sizeof(char));}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf("%s", args);va_end(args);}}static void main_sink(){char * data=_main_data;main_vasink(data, data);}static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}_main_data=data;main_sink();}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char src[100];strcpy(data, src);printLine(data);}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;data=new wchar_t[100];{wchar_t * data=*data_ptr1;}{wchar_t * data=*data_ptr2;{wchar_t dest[50]=L"";_snwprintf(dest, wcslen(data), L"%s", data);printWLine(data);delete [] data;}}}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}func_ptr(data);}void b_main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");{char * data_copy=data;char * data=data_copy;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnvp(_P_WAIT, COMMAND_INT, args);}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink();static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{wchar_t data_src[10+1]=SRC_STRING;wcsncpy(data, data_src, wcslen(data_src));printWLine(data);free(data);}}
void b_main_sink(wchar_t * password);static void main(){wchar_t * password;wchar_t password_buf[100]=L"";password=password_buf;wcscpy(password, L"Password1234!");b_main_sink(password);}void c_main_sink(wchar_t * password);void b_main_sink(wchar_t * password){c_main_sink(password);}void d_main_sink(wchar_t * password);void c_main_sink(wchar_t * password){d_main_sink(password);}void d_main_sink(wchar_t * password){{HANDLE pHandle;wchar_t * username=L"User";wchar_t * domain=L"Domain";if (LogonUserW( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}
static void main_sink(wchar_t * data){PUTENV(data);}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[250]=L"PATH=";data=data_buf;wcscat(data, NEW_PATH);func_ptr(data);}
static void main(){long long * data;long long * &data_ref=data;data=NULL;long long data_good;data=&data_good;printLongLongLine(*data);{long long * data=data_ref;}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}char * b_main_source(char * data){{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}return data;}
static void main_sink(int * data){if (data!=NULL){data[0]=5;printIntLine(data[0]);free(data);}}static void main(){int * data;void (*func_ptr) (int *)=main_sink;data=(int *)realloc(data, 100);func_ptr(data);}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;data=PASSWORD;}{wchar_t * data=*data_ptr2;if (wcsstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}}
static void main(){long long * data;data=NULL;data=new long long[100];delete [] data;main_sink_b(data);}void main_sink_b(long long * data){main_sink_c(data);}void main_sink_c(long long * data){main_sink_d(data);}void main_sink_d(long long * data){}
static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;{wchar_t src[100];wcscat(data, src);printWLine(data);}}
static void main_sink(char * data){delete data;}static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;data=new char;func_ptr(data);}
void b_main_sink(int * data);static void main(){int * data;data=NULL;data=(int *)malloc(10*sizeof(int));b_main_sink(data);}void c_main_sink(int * data);void b_main_sink(int * data){c_main_sink(data);}void c_main_sink(int * data){{int data_src[10]={0};memmove(data, data_src, 10*sizeof(int));printIntLine(data[0]);free(data);}}
static void main(){unsigned int data;data=0;fscanf (stdin, "%u", &data);b_main_sink(data);}void b_main_sink(unsigned int data){c_main_sink(data);}void c_main_sink(unsigned int data){d_main_sink(data);}void d_main_sink(unsigned int data){e_main_sink(data);}void e_main_sink(unsigned int data){{unsigned int result=0;if (data > 0){result=data-1;printUnsignedLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{wchar_t src[100];wcsncpy(data, src, 100);printWLine(data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data="P";_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf("%s", args);va_end(args);}}static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]="";data=data_buf;{char * data=*data_ptr1;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}}{char * data=*data_ptr2;main_vasink(data, data);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
void b_main_sink();static void main(){short data;data=0;data=100-1;_main_data=data;b_main_sink();}void b_main_sink(){short data=_main_data;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
static void main(){int * data;data=NULL;if(global_returns_t_or_f()){data=(int *)calloc(100, sizeof(int));}else{data=(int *)calloc(100, sizeof(int));}if(global_returns_t_or_f()){free(data);}else{free(data);}}
void _main_sink(char * data){{char dest[50]="";_snprintf(dest, strlen(data), "%s", data);printLine(data);}}static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;_main_sink(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, data, args);va_end(args);}}void e_main_sink(wchar_t * data){main_vasink(data, data);}
static void main(){long long * data;union_type my_union;data=NULL;data=new long long;printLongLongLine(*data);my_union.a=data;{long long * data=my_union.b;delete data;}}
static char * main_source(char * data){strcat(data, "*.*");return data;}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
void b_main_sink(void * void_data_ptr);static void main(){int * data;data=NULL;{int tmp=5;data=&tmp;}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * * data_ptr=(int * *)void_data_ptr;int * data=(*data_ptr);printIntLine(*data);}
static void main(){char * data;_union_type my_union;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;my_union.a=data;{char * data=my_union.b;{char src[100];strcat(data, src);printLine(data);}}}
static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;{char dest[100];memmove(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}wchar_t * b_main_source(wchar_t * data){wcscpy(data, L"15");return data;}
static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}void b_main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){twoints * data;struct_type my_struct;data=NULL;data=new twoints[100];my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){twoints * data=my_struct.a;delete [] data;}
static void main(){int data;int &data_ref=data;data=-1;data=20;{int data=data_ref;{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}}
static void main(){char * password;char * *password_ptr1=&password;char * *password_ptr2=&password;char password_buf[100]="";password=password_buf;{char * password=*password_ptr1;{size_t password_len=0;fgets(password, 100, stdin);password_len=strlen(password);if (password_len > 0){password[password_len-1]='\0';}}}{char * password=*password_ptr2;{HANDLE pHandle;char * username="User";char * domain="Domain";if (LogonUserA( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=NULL;data=new wchar_t;delete data;func_ptr(data);}void main_sink(wchar_t * data){}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}{int data_copy=data;int data=data_copy;{int result=-1;if (data < INT_MAX){result=data+1;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
static void main(){int data;if(global_returns_t_or_f()){data=7;}else{data=7;}if(global_returns_t_or_f()){{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}else{{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}}
static void main_sink(int data){{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}static void main(){int data;data=-1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}main_sink(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}void b_main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void main_sink();static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}_main_data=data;main_sink();}void main_sink(){wchar_t * data=_main_data;{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_t_or_f()){wcscat(data, L"*.*");}else{wcscat(data, L"*.*");}{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"C:\\Windows\\System32\\winsrv.dll");{wchar_t * data_copy=data;wchar_t * data=data_copy;{HMODULE hModule;hModule=LoadLibraryW(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}}
void main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_sink(data);}void main_sink(wchar_t * data){{wchar_t src[100];wcsncat(data, src, 100);printWLine(data);delete [] data;}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}}{wchar_t * data=*data_ptr2;wprintf(L"%s\n", data);}}
void b_main_sink(short * data);static void main(){short data;data=0;data=100-1;b_main_sink(&data);}void b_main_sink(short * data_ptr){short data=*data_ptr;{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");{char dest[100]="";SNPRINTF(dest, 100-1, data);printLine(dest);}}
void _main_sink(wchar_t * password){{HANDLE pHandle;wchar_t * username=L"User";wchar_t * domain=L"Domain";if (LogonUserW( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}static void main(){wchar_t * password;wchar_t password_buf[100]=L"";password=password_buf;{size_t password_len=0;fgetws(password, 100, stdin);password_len=wcslen(password);if (password_len > 0){password[password_len-1]=L'\0';}}_main_sink(password);}
static void main(){char * data;void (*func_ptr) (char *, ...)=b_main_vasink;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}func_ptr(data);}void b_main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, "%s", args);va_end(args);}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;data->a=1;data->b=2;{twointsclass * data_copy=data;twointsclass * data=data_copy;printIntLine(data->a);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;data=NULL;{wchar_t * data=*data_ptr1;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}}{wchar_t * data=*data_ptr2;{size_t i;wchar_t dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);}}}
static void main(){char * data;char * data_array[5];data=NULL;data=new char[100];delete [] data;data_array[2]=data;main_sink(data_array);}void main_sink(char * data_array[]){char * data=data_array[2];}
static void main_sink(int * data){printIntLine(data[0]);free(data);}static void main(){int * data;void (*func_ptr) (int *)=main_sink;{int * data_buf=(int *)malloc(100*sizeof(int));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}func_ptr(data);}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{wchar_t data_src[10+1]=SRC_STRING;wcsncpy(data, data_src, wcslen(data_src));printWLine(data);free(data);}}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}func_ptr(data);}void b_main_sink(wchar_t * data){{int i, n, v;if (swscanf(data, L"%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static wchar_t * main_source(wchar_t * data){{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}return data;}static void main(){wchar_t * data;data=NULL;data=main_source(data);{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}
static void main(){int data;data=-1;fscanf (stdin, "%d", &data);{int data_copy=data;int data=data_copy;{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}}
static void main(){int data;data=-1;if(global_returns_t_or_f()){data=10000;}else{data=10000;}if(global_returns_t_or_f()){{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than the length of the source string or too large");}}}else{{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than the length of the source string or too large");}}}}
static void main(){char data;char data_array[5];data=' ';data=(char)rand();data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char data_array[]){char data=data_array[2];{char result=0;if (data > CHAR_MIN){result=data-1;printHexCharLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
void b_main_sink(long long * data_array[]);static void main(){long long * data;long long * data_array[5];{long long * data_buf=(long long *)malloc(100*sizeof(long long));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5L;}}data=data_buf;}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(long long * data_array[]){long long * data=data_array[2];printLongLongLine(data[0]);free(data);}
static void main(){int data;data=-1;data=10000;b_main_sink(data);}void b_main_sink(int data){{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){struct _twoints * data;data=NULL;data=(struct _twoints *)calloc(100, sizeof(struct _twoints));data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);b_main_sink(data);}void b_main_sink(struct _twoints * data){free(data);}
static void main_sink(){char * data=main_data;delete data;}static void main(){char * data;data=NULL;data=new char;main_data=data;main_sink();}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");{char * data_copy=data;char * data=data_copy;printf(data);}}
void main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}data_array[2]=data;main_sink(data_array);}void main_sink(char * data_array[]){char * data=data_array[2];{char src[100];strncpy(data, src, 100);data[100-1]='\0';printLine(data);}}
static void main(){unsigned int data;data=0;data=5;b_main_sink(data);}void b_main_sink(unsigned int data){c_main_sink(data);}void c_main_sink(unsigned int data){d_main_sink(data);}void d_main_sink(unsigned int data){e_main_sink(data);}void e_main_sink(unsigned int data){{unsigned int result=data * 2;printUnsignedLine(result);}}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, data, args);va_end(args);}}static void main_sink(){wchar_t * data=_main_data;main_vasink(data, data);}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");_main_data=data;main_sink();}
void b_main_sink(int * data);static void main(){int data;data=-1;data=CHAR_MAX-5;b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{short s=(short)data;printf("%hd\n", s);}}
static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}void b_main_sink(int data){{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than the length of the source string or too large");}}}
static void main_sink(char * data){delete data;}static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;data=new char;func_ptr(data);}
static void main(){wchar_t * data;data=NULL;data=new wchar_t;delete data;main_data=data;main_sink();}void main_sink(){wchar_t * data=main_data;}
static void main_sink(int data){{size_t i;int *b;b=(int*)malloc(data * sizeof(int));for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);free(b);}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=20;func_ptr(data);}
static void main_vasinkb(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, data, args);va_end(args);printLine(dest);}}static void main_vasinkg(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, "%s", args);va_end(args);printLine(dest);}}static void main(){char * data;char data_buf[100]="";data=data_buf;if(global_returns_t_or_f()){{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}}else{{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}}if(global_returns_t_or_f()){main_vasinkg(data, data);}else{main_vasinkg(data, data);}}
static void main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnv(_P_WAIT, COMMAND_INT_PATH, args);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");func_ptr(data);}
void b_main_sink(char * data);static void main(){char * data;data=NULL;data="Good";b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){printf("%s\n", data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;wprintf(L"%s\n", data);}
static void main(){long long * data;long long * *data_ptr1=&data;long long * *data_ptr2=&data;data=NULL;{long long * data=*data_ptr1;data=new long long;delete data;}{long long * data=*data_ptr2;}}
static void main(){int data;union_type my_union;data=-1;data=RAND32();my_union.a=data;{int data=my_union.b;{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}}
static void main(){long long * data;_union_type my_union;{long long * data_buf=(long long *)malloc(100*sizeof(long long));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5L;}}data=data_buf;}my_union.a=data;{long long * data=my_union.b;printLongLongLine(data[0]);free(data);}}
static void main(){int data;data=-1;fscanf (stdin, "%d", &data);{int result=-1;if (data < INT_MAX){result=data+1;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){int data;_struct_type my_struct;data=-1;data=10000;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than the length of the source string or too large");}}}
void b_main_sink(int data);static void main(){int data;data=-1;data=100-1;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void d_main_sink(int data);void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
static void main_sink(wchar_t * data){}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=NULL;{wchar_t data_goodbuf[100];data=data_goodbuf;wcscpy(data, L"A String");printWLine(data);}func_ptr(data);}
static void main(){twointsclass * data;data=NULL;data=(twointsclass *)malloc(100*sizeof(twointsclass));main_data=data;main_sink();}void main_sink(){twointsclass * data=main_data;free(data);}
static void main_sink(wchar_t * data){printWLine(data);free(data);}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));data=data_buf;}func_ptr(data);}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){int * data;data=new int[10];{int i;for(i=0;i<10;i++){data[i]=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}delete [] data;}
void b_main_sink(char * password);static void main(){char * password;char password_buf[100]="";password=password_buf;{size_t password_len=0;fgets(password, 100, stdin);password_len=strlen(password);if (password_len > 0){password[password_len-1]='\0';}}b_main_sink(password);}void b_main_sink(char * password){{HANDLE pHandle;char * username="User";char * domain="Domain";if (LogonUserA( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}
static void main(){int * data;int * &data_ref=data;data=NULL;data=new int[100];{int * data=data_ref;delete [] data;}}
static void main(){char * data;union_type my_union;data=NULL;data=new char[100];my_union.a=data;{char * data=my_union.b;{char src[100];strncat(data, src, 100);printLine(data);delete [] data;}}}
static void main_sink(char * data){printf(data);}static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");main_sink(data);}
void main_sink(twointsclass * data_array[]);static void main(){twointsclass * data;twointsclass * data_array[5];{twointsclass * data_buf=new twointsclass[100];{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}data_array[2]=data;main_sink(data_array);}void main_sink(twointsclass * data_array[]){twointsclass * data=data_array[2];printIntLine(data[0].a);delete [] data;}
static void main(){twointsclass * data;twointsclass * &data_ref=data;twointsclass data_uninit_array[10];data=data_uninit_array;for(int i=0;i<10;i++){data[i].a=i;data[i].b=i;}{twointsclass * data=data_ref;for(int i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}}
static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;{char src[100];memcpy(data, src, 100*sizeof(char));printLine(data);}}
char * b_main_source(char * data);static void main(){char * data;char data_buf[250]="PATH=";data=data_buf;data=b_main_source(data);PUTENV(data);}char * b_main_source(char * data){strcat(data, NEW_PATH);return data;}
void b_main_sink(void * void_data_ptr);static void main(){FILE * data;data=NULL;data=fopen("BadSource_fopen.txt", "w+");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){FILE * * data_ptr=(FILE * *)void_data_ptr;FILE * data=(*data_ptr);if (data!=NULL){fclose(data);}}
static void main_sink(){char * data=_main_data;{char src[100];memmove(data, src, 100*sizeof(char));printLine(data);free(data);}}static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));_main_data=data;main_sink();}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}{char * data_copy=data;char * data=data_copy;fprintf(stdout, "%s\n", data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){int data;_union_type my_union;data=-1;data=ASSERT_VALUE+1;my_union.a=data;{int data=my_union.b;assert(data > ASSERT_VALUE);}}
static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;data=PASSWORD;my_union.a=data;{char * data=my_union.b;if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){if (wcsstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
static wchar_t * main_source(wchar_t * data){wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");return data;}static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;data=main_source(data);{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){int data;data=-1;data=20;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}
static void main(){long long * data;data=NULL;data=new long long[100];main_sink(data);}void main_sink(long long * data){delete [] data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{char dest[100]="";SNPRINTF(dest, 100-1, "%s", data);printLine(dest);}}
static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char dest[100]="";SNPRINTF(dest, 100-1, "%s", data);printLine(dest);}}
static void main(){long long * data;data=NULL;{long long data_goodbuf[100];data=data_goodbuf;data[0]=5L;printLongLongLine(data[0]);}b_main_sink(&data);}void b_main_sink(long long * * data_ptr){long long * data=*data_ptr;}
static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));{char * data_copy=data;char * data=data_copy;free(data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];main_sink(&data);}void main_sink(twointsclass * * data_ptr){twointsclass * data=*data_ptr;delete [] data;}
static void main(){twoints * data;data=NULL;if(global_returns_t_or_f()){data=(twoints *)malloc(100*sizeof(twoints));}else{data=(twoints *)malloc(100*sizeof(twoints));}{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printStructLine(&data[0]);free(data);}}}
static void main(){unsigned char data;unsigned char *data_ptr1=&data;unsigned char *data_ptr2=&data;data=' ';{unsigned char data=*data_ptr1;fscanf (stdin, "%hc", &data);}{unsigned char data=*data_ptr2;{unsigned char result=-1;if (data < UCHAR_MAX){result=data+1;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=NULL;{char * data=*data_ptr1;data=new char[100];}{char * data=*data_ptr2;{char src[100];strncat(data, src, 100);printLine(data);delete [] data;}}}
static void main_sink(){int * data=main_data;}static void main(){int * data;data=NULL;data=new int;delete data;main_data=data;main_sink();}
void b_main_sink(char * * data);static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char dest[100];memcpy(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
static void main(){long long * data;data=NULL;if(global_returns_t_or_f()){data=new long long[100];}else{data=new long long[100];}if(global_returns_t_or_f()){delete [] data;}else{delete [] data;}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
int b_main_source(int data);static void main(){int data;data=-1;data=b_main_source(data);{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}int b_main_source(int data){data=100-1;return data;}
void b_main_sink(char * * data);static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char src[100];strcpy(data, src);printLine(data);}}
static void main(){twointsclass * data;data=NULL;main_source(data);free(data);}void main_source(twointsclass * &data){data=(twointsclass *)malloc(100*sizeof(twointsclass));}
static void main(){{HANDLE hMutex=NULL;hMutex=CreateMutexW(NULL, FALSE, NULL);if (hMutex==NULL){exit(1);}if (GetLastError()==ERROR_ALREADY_EXISTS){exit(1);}CloseHandle(hMutex);}}
static void main(){int * data;data=NULL;data=new int;main_sink(data);}void main_sink(int * data){delete data;}
static void main(){int count;count=-1;count=20;b_main_sink(count);}void b_main_sink(int count){{size_t i=0;FILE *file=NULL;const char *filename="output_bad.txt";file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}
static FILE * main_source(FILE * data){data=WFOPEN(L"file.txt", L"w+");return data;}static void main(){FILE * data;data=NULL;data=main_source(data);if (data!=NULL){fclose(data);}}
static void main(){twoints * data;data=NULL;data=new twoints;main_data=data;main_sink();}void main_sink(){twoints * data=main_data;delete data;}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=b_main_source(data);{wchar_t src[100];wcscpy(data, src);printWLine(data);free(data);}}wchar_t * b_main_source(wchar_t * data){data=(wchar_t *)malloc(100*sizeof(wchar_t));return data;}
static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));main_data=data;main_sink();}void main_sink(){long long * data=main_data;free(data);}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){system(data);}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}my_struct.a=data;b_main_sink(my_struct);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(L"%s", args);va_end(args);}}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;main_vasink(data, data);}
void b_main_sink(twoints * data);static void main(){twoints * data;twoints data_badbuf[50];twoints data_goodbuf[100];data=data_goodbuf;b_main_sink(data);}void b_main_sink(twoints * data){{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memcpy(data, src, 100*sizeof(twoints));printStructLine(&data[0]);}}
static void main(){wchar_t * data;data=L"string";b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);printWLine(data);}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=NULL;{char * data=*data_ptr1;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}}{char * data=*data_ptr2;{char src[100];memmove(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;if (wcsstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;main_sink(data);}void main_sink(twointsclass * data){delete data;}
void b_main_sink(twoints * data);static void main(){twoints * data;twoints * data_badbuf=(twoints *)ALLOCA(50*sizeof(twoints));twoints * data_goodbuf=(twoints *)ALLOCA(100*sizeof(twoints));data=data_goodbuf;b_main_sink(data);}void c_main_sink(twoints * data);void b_main_sink(twoints * data){c_main_sink(data);}void d_main_sink(twoints * data);void c_main_sink(twoints * data){d_main_sink(data);}void d_main_sink(twoints * data){{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memcpy(data, src, 100*sizeof(twoints));printStructLine(&data[0]);}}
static void main(){char * data;data=NULL;data=new char[100];delete [] data;}
static void main_source(twoints * &data){{twoints * data_buf=new twoints[100];{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}}static void main(){twoints * data;main_source(data);printStructLine(&data[0]);delete [] data;}
static void main(){long long * data;data=NULL;data=new long long;{long long * data_copy=data;long long * data=data_copy;delete data;}}
static void main(){short data;data=0;data=100-1;{short data_copy=data;short data=data_copy;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}}
static void main(){char * data;char * &data_ref=data;data=NULL;data=(char *)calloc(100, sizeof(char));{char * data=data_ref;free(data);}}
static void main(){char * data;char * data_array[5];data=NULL;{char mystring[]="mystring";data=strdup(mystring);printLine(data);}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];free(data);}
static void main(){int data;data=-1;if(global_returns_t_or_f()){data=20;}else{data=20;}if(global_returns_t_or_f()){{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}else{{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}}
void b_main_sink();static void main(){short data;data=0;data=100-1;_main_data=data;b_main_sink();}void b_main_sink(){short data=_main_data;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
static void main(){int data;data=-1;if(global_returns_t_or_f()){data=20;}else{data=20;}if(global_returns_t_or_f()){{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}else{{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t dest[50]=L"";memcpy(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);free(data);}}
static void main(){unsigned int data;data=0;fscanf (stdin, "%u", &data);b_main_sink(data);}void b_main_sink(unsigned int data){c_main_sink(data);}void c_main_sink(unsigned int data){d_main_sink(data);}void d_main_sink(unsigned int data){{unsigned int result=-1;if (data <=(unsigned int)sqrt((unsigned int)UINT_MAX)){result=data * data;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){unsigned int data;data=0;data=(unsigned int)RAND32();b_main_sink(data);}void b_main_sink(unsigned int data){c_main_sink(data);}void c_main_sink(unsigned int data){d_main_sink(data);}void d_main_sink(unsigned int data){e_main_sink(data);}void e_main_sink(unsigned int data){{unsigned int result=-1;if (data <=(unsigned int)sqrt((unsigned int)UINT_MAX)){result=data * data;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){unsigned char data;data=' ';fscanf (stdin, "%hc", &data);b_main_sink(&data);}void b_main_sink(void * void_data_ptr){unsigned char * data_ptr=(unsigned char *)void_data_ptr;unsigned char data=(*data_ptr);{unsigned char result=-1;if (data <=(unsigned char)sqrt((unsigned char)UCHAR_MAX)){result=data * data;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{int i, n, v;if (swscanf(data, L"%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;if(global_returns_t_or_f()){wcscat(data, L"file.txt");}else{wcscat(data, L"file.txt");}{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){int data;int data_array[5];data=-1;data=5;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{int result=data-1;printIntLine(result);}}
static void main_sink(){wchar_t * data=_main_data;{wchar_t dest[50]=L"";memcpy(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);}}static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;_main_data=data;main_sink();}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, data);printWLine(dest);}}}
static void main(){HANDLE data;data=CreateFile("GoodSource_w32CreateFile.txt", (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);b_main_sink(&data);}void b_main_sink(void * void_data_ptr){HANDLE * data_ptr=(HANDLE *)void_data_ptr;HANDLE data=(*data_ptr);CloseHandle(data);}
static void main(){int data;data=7;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){{wchar_t data_buf[10]=L"AAAAAAAAA";if (data >=0){printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main(){char * data;union_type my_union;data=NULL;data=(char *)malloc(100*sizeof(char));my_union.a=data;{char * data=my_union.b;free(data);}}
static void main_sink(){char * data=_main_data;{char dest[50]="";strcpy(dest, data);printLine(data);}}static void main(){char * data;char data_buf[100];data=data_buf;_main_data=data;main_sink();}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}_main_data=data;b_main_sink();}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, "%s", args);va_end(args);}}void b_main_sink(){char * data=_main_data;main_vasink(data, data);}
static void main(){int data;data=-1;data=b_main_source(data);{char * char_string;if (data > 0){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than 0");}}}int b_main_source(int data){data=20;return data;}
static void main(){twoints * data;union_type my_union;data=NULL;data=new twoints;data->a=0;data->b=0;printStructLine(data);my_union.a=data;{twoints * data=my_union.b;delete data;}}
static char * main_source(char * data){return data;}static void main(){char * data;data=(char *)malloc(100*sizeof(char));data=main_source(data);{char dest[50]="";strcpy(dest, data);printLine(data);free(data);}}
static void main(){twointsclass * data;void (*func_ptr) (twointsclass *)=main_sink;data=NULL;data=new twointsclass;func_ptr(data);}void main_sink(twointsclass * data){delete data;}
static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];if(global_returns_t_or_f()){data=data_goodbuf;}else{data=data_goodbuf;}{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));printWLine(data);}}
static void main(){int * data;data=NULL;data=new int;main_sink_b(data);}void main_sink_b(int * data){main_sink_c(data);}void main_sink_c(int * data){main_sink_d(data);}void main_sink_d(int * data){main_sink_e(data);}void main_sink_e(int * data){delete data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);{char dest[100]="";SNPRINTF(dest, 100-1, data);printLine(dest);}}char * b_main_source(char * data){strcpy(data, "fixedstringtest");return data;}
static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}printStructLine(&data[0]);}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));data=b_main_source(data);{wchar_t dest[50]=L"";memcpy(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);free(data);}}wchar_t * b_main_source(wchar_t * data){return data;}
void _main_sink(wchar_t * data){{size_t i;wchar_t dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);}}static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}_main_sink(data);}
void b_main_sink(int data);static void main(){int data;data=-1;data=100-1;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{size_t i;char dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);}}
static void main_sink(int data){{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}static void main(){int data;data=-1;data=20;main_sink(data);}
static void main_sink(int data){{int result=-1;if (data <=(int)sqrt((int)INT_MAX)){result=data * data;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}static void main(){int data;data=-1;data=RAND32();main_sink(data);}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{wchar_t src[100];wcsncat(data, src, 100);printWLine(data);free(data);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));data[0]=L'\0';{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{size_t i;for (i=0;i < wcslen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=20;}{int data=*data_ptr2;{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}}
static void main_sink(int data){{int result=data-1;printIntLine(result);}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=5;func_ptr(data);}
static void main_sink(){int data=_main_data;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}static void main(){int data;data=-1;data=100-1;_main_data=data;main_sink();}
static void main(){char * data;char data_buf[100]="";data=data_buf;if(global_returns_t_or_f()){data="P";}else{data="P";}if(global_returns_t_or_f()){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}else{if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}}
static void main_sink(){wchar_t * data=_main_data;{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");_main_data=data;main_sink();}
static void main(){struct _twoints * data;struct _twoints * *data_ptr1=&data;struct _twoints * *data_ptr2=&data;data=NULL;{struct _twoints * data=*data_ptr1;data=new struct _twoints;data->a=0;data->b=0;printStructLine((twoints *)data);}{struct _twoints * data=*data_ptr2;delete data;}}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];data=(char *)malloc(100*sizeof(char));data[0]='\0';{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{size_t i;for (i=0;i < strlen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}
static void main(){double * data;data=(double *)malloc(10*sizeof(double));{int i;for(i=0;i<10;i++){data[i]=(double)i;}}{int i;for(i=0;i<10;i++){printDoubleLine(data[i]);}}}
FILE * b_main_source(FILE * data);static void main(){FILE * data;data=NULL;data=b_main_source(data);if (data!=NULL){fclose(data);}}FILE * b_main_source(FILE * data){data=fopen("BadSource_fopen.txt", "w+");return data;}
static void main(){int data;data=-1;data=20;b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}
static void main_sink(char * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");func_ptr(data);}
static void main(){char * data;data=NULL;{char mystring[]="mystring";data=strdup(mystring);}free(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(wchar_t * data){if (wcsncmp(PASSWORD, data, wcslen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static char * main_source(char * data){return data;}static void main(){char * data;data=(char *)malloc(100*sizeof(char));data=main_source(data);{char dest[50]="";_snprintf(dest, strlen(data), "%s", data);printLine(data);free(data);}}
void b_main_sink(float data);static void main(){float data;data=0.0F;data=7.0F;b_main_sink(data);}void c_main_sink(float data);void b_main_sink(float data){c_main_sink(data);}void d_main_sink(float data);void c_main_sink(float data){d_main_sink(data);}void e_main_sink(float data);void d_main_sink(float data){e_main_sink(data);}void e_main_sink(float data){printDoubleLine((double)(100.0/data));}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");{char * data_copy=data;char * data=data_copy;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}}
static void main(){wchar_t data;data=L'W';printf("%02lx\n", data);}
void b_main_sink(int data);static void main(){int data;data=-1;data=OPEN("BadSource_open.txt", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);b_main_sink(data);}void b_main_sink(int data){if (data!=-1){CLOSE(data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(char * data){if (strstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
static void main_sink(){char * data=main_data;free(data);}static void main(){char * data;data=NULL;data=NULL;data=(char *)realloc(data, 100*sizeof(char));main_data=data;main_sink();}
static void main_source(twointsclass * &data){for(int i=0;i<(10/2);i++){data[i].a=i;data[i].b=i;}}static void main(){twointsclass * data;twointsclass data_uninit_array[10];data=data_uninit_array;main_source(data);for(int i=0;i<10;i++){data[i].a=i;data[i].b=i;}for(int i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}
static void main(){twoints * data;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){twoints * * data_ptr=(twoints * *)void_data_ptr;twoints * data=(*data_ptr);data=(twoints *)malloc(sizeof(twoints));data->a=5;data->b=6;printIntLine(data->a);printIntLine(data->b);}
static void main(){unsigned char data;data=' ';data=5;b_main_sink(&data);}void b_main_sink(unsigned char * data_ptr){unsigned char data=*data_ptr;{unsigned char result=data * 2;printHexUnsignedCharLine(result);}}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t data_src[10+1]=SRC_STRING;wcscpy(data, data_src);printWLine(data);free(data);}}}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"C:\\Windows\\System32\\winsrv.dll");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{HMODULE hModule;hModule=LoadLibraryW(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;data=NULL;{wchar_t * data=*data_ptr1;{wchar_t data_goodbuf[100];data=data_goodbuf;wcscpy(data, L"a string");printWLine(data);}}{wchar_t * data=*data_ptr2;}}
static void main_sink(wchar_t * data){{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");func_ptr(data);}
static void main_sink(){char * data=_main_data;{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");_main_data=data;main_sink();}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
void b_main_sink();static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{wchar_t dest[50]=L"";wcsncpy(dest, data, wcslen(data));printWLine(data);}}
static void main(){long long * data;data=NULL;data=new long long;main_data=data;main_sink();}void main_sink(){long long * data=main_data;printLongLongLine(*data);}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=(char *)malloc(100*sizeof(char));{char * data=*data_ptr1;}{char * data=*data_ptr2;{char dest[50]="";memcpy(dest, data, strlen(data)*sizeof(char));printLine(data);free(data);}}}
static void main(){twointsclass * data;twointsclass * &data_ref=data;twointsclass data_uninit_array[10];data=data_uninit_array;{twointsclass * data=data_ref;for(int i=0;i<10;i++){data[i].a=i;data[i].b=i;}for(int i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}}
static void main(){{if (fwrite((char *)"string", sizeof(char), strlen("string"), stdout)!=strlen("string")){printLine("fwrite failed!");}}}
static void main(){wchar_t * data;wchar_t * data_array[5];data=NULL;data=new wchar_t;delete data;data_array[2]=data;main_sink(data_array);}void main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];}
static void main_sink(){wchar_t * data=main_data;{wchar_t dest[50]=L"";wcsncat(dest, data, wcslen(data));printWLine(data);delete [] data;}}static void main(){wchar_t * data;data=new wchar_t[100];main_data=data;main_sink();}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){int * data;int * *data_ptr1=&data;int * *data_ptr2=&data;data=NULL;{int * data=*data_ptr1;data=new int[100];}{int * data=*data_ptr2;delete [] data;}}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=b_main_source(data);{wchar_t data_src[10+1]=SRC_STRING;memcpy(data, data_src, wcslen(data_src)*sizeof(wchar_t));printWLine(data);free(data);}}wchar_t * b_main_source(wchar_t * data){data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));return data;}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];delete [] data;main_sink_b(data);}void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_c(twointsclass * data){}
static void main(){int data;data=b_main_source(data);{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}int b_main_source(int data){data=7;return data;}
void main_sink();static void main(){char * data;data=NULL;data=new char[100];_main_data=data;main_sink();}void main_sink(){char * data=_main_data;{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}printLine(data);delete [] data;}}
static void main(){int data;_struct_type my_struct;data=-1;data=INT_MAX;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{int result=-1;if (data < INT_MAX){result=data+1;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){twointsclass * data;data=NULL;twointsclass data_good;data=&data_good;data->a=0;data->b=0;printIntLine(data->a);printIntLine(data->b);main_sink(&data);}void main_sink(twointsclass * * data_ptr){twointsclass * data=*data_ptr;}
static void main(){int data;int data_array[5];data=OPEN("BadSource_open.txt", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);CLOSE(data);data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];}
short b_main_source(short data);static void main(){short data;data=0;data=b_main_source(data);{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}short b_main_source(short data){data=100-1;return data;}
void main_sink(struct_type my_struct);static void main(){wchar_t * data;struct_type my_struct;data=new wchar_t[100];my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){wchar_t * data=my_struct.a;{wchar_t dest[50]=L"";wcscat(dest, data);printWLine(data);delete [] data;}}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"C:\\Windows\\System32\\winsrv.dll");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{HMODULE hModule;hModule=LoadLibraryW(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
static void main_sink(char * data){if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;main_sink(data);}
static void main(){char data;data=' ';if(global_returns_t_or_f()){data=5;}else{data=5;}if(global_returns_t_or_f()){{char result=data * 2;printHexCharLine(result);}}else{{char result=data * 2;printHexCharLine(result);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, L"%s", args);va_end(args);printWLine(dest);}}void e_main_sink(wchar_t * data){main_vasink(data, data);}
static void main(){long long * data;data=NULL;{long long data_goodbuf[100];data=data_goodbuf;data[0]=5L;printLongLongLine(data[0]);}main_sink(data);}void main_sink(long long * data){}
static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}printLine(data);}}
static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];if(global_returns_t_or_f()){data=data_goodbuf;}else{data=data_goodbuf;}{char src[100];memmove(data, src, 100*sizeof(char));printLine(data);}}
void b_main_sink(short data);static void main(){short data;data=0;data=100-1;b_main_sink(data);}void c_main_sink(short data);void b_main_sink(short data){c_main_sink(data);}void d_main_sink(short data);void c_main_sink(short data){d_main_sink(data);}void e_main_sink(short data);void d_main_sink(short data){e_main_sink(data);}void e_main_sink(short data){{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
static void main_sink(char * data){{char dest[100];strncpy(dest, data, strlen(dest));dest[100-1]='\0';printLine(dest);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}func_ptr(data);}
void main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}data_array[2]=data;main_sink(data_array);}void main_sink(char * data_array[]){char * data=data_array[2];{char dest[100];strcpy(dest, data);printLine(dest);}}
static void main(){char * data;data=NULL;data=new char;{char * data_copy=data;char * data=data_copy;delete data;}}
void b_main_sink();static void main(){int data;data=-1;data=100-1;_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
static void main(){int data;data=5;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);printIntLine(data);}
static void main(){signal(SIGINT, helper_good);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(data);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, L"%s", args);va_end(args);}}void b_main_sink(wchar_t * data){main_vasink(data, data);}
static void main(){int data;_struct_type my_struct;data=-1;data=5;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{int result=data+1;printIntLine(result);}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';{char * data=*data_ptr1;data=data_buf;}{char * data=*data_ptr2;{char dest[100];memmove(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}}
static void main_sink(wchar_t * data){{wchar_t dest[100];memcpy(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;func_ptr(data);}
void b_main_sink(int * data_array[]);static void main(){int * data;int * data_array[5];data=NULL;data=(int *)malloc(10*sizeof(int));data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int * data_array[]){int * data=data_array[2];{int data_src[10]={0};memcpy(data, data_src, 10*sizeof(int));printIntLine(data[0]);free(data);}}
static void main(){unsigned char data;data=' ';data=5;b_main_sink(data);}void b_main_sink(unsigned char data){c_main_sink(data);}void c_main_sink(unsigned char data){{unsigned char result=data+1;printHexUnsignedCharLine(result);}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main_sink(wchar_t * data){{wchar_t src[100];wcscat(data, src);printWLine(data);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;func_ptr(data);}
static void main_sink(){char * data=_main_data;{size_t i;char dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);}}static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;_main_data=data;main_sink();}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);{char dest[100]="";SNPRINTF(dest, 100-1, "%s", data);printLine(dest);}}char * b_main_source(char * data){{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}return data;}
static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];if(global_returns_t_or_f()){data=data_goodbuf;}else{data=data_goodbuf;}{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));printWLine(data);}}
static void main(){{wchar_t * data=SRC_STR;wchar_t dst[100]=L"";wchar_t * end=wcschr(data, L'/');wcsncpy(dst, data, end-data);printWLine(dst);}}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
void b_main_sink(twoints * data);static void main(){twoints * data;data=(twoints *)realloc(data, 100);b_main_sink(data);}void c_main_sink(twoints * data);void b_main_sink(twoints * data){c_main_sink(data);}void d_main_sink(twoints * data);void c_main_sink(twoints * data){d_main_sink(data);}void e_main_sink(twoints * data);void d_main_sink(twoints * data){e_main_sink(data);}void e_main_sink(twoints * data){if (data!=NULL){data[0].a=1;data[0].b=1;printStructLine(&data[0]);free(data);}}
static void main_sink(){char * data=_main_data;fprintf(stdout, data);}static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");_main_data=data;main_sink();}
static void main(){int data;data=7;b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static short main_source(short data){data=CHAR_MAX-5;return data;}static void main(){short data;data=-1;data=main_source(data);{char c=(char)data;printHexCharLine(c);}}
static void main(){int * data;data=NULL;data=new int[100];{memmove(data, src, 100*sizeof(int));printIntLine(data[0]);delete [] data;}}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}my_struct.a=data;b_main_sink(my_struct);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, L"%s", args);va_end(args);}}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;main_vasink(data, data);}
static void main_sink(){char * password=_main_data;{HANDLE pHandle;char * username="User";char * domain="Domain";if (LogonUserA( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}static void main(){char * password;char password_buf[100]="";password=password_buf;{size_t password_len=0;fgets(password, 100, stdin);password_len=strlen(password);if (password_len > 0){password[password_len-1]='\0';}}_main_data=password;main_sink();}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(&data);}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf(data, args);va_end(args);}}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);main_vasink(data, data);}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;b_main_sink(data);}void b_main_sink(char * data){{char dest[100];memmove(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}
static helper_main(void){return 5;}static void main(){int data=helper_main();printIntLine(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"15");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{size_t i;wchar_t dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);}}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{wchar_t dest[50]=L"";_snwprintf(dest, wcslen(data), L"%s", data);printWLine(data);}}
static void main(){twoints * data;twoints * data_badbuf=(twoints *)ALLOCA(50*sizeof(twoints));twoints * data_goodbuf=(twoints *)ALLOCA(100*sizeof(twoints));if(global_returns_t_or_f()){data=data_goodbuf;}else{data=data_goodbuf;}{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printStructLine(&data[0]);}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){_spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
char * b_main_source(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);_spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}char * b_main_source(char * data){strcat(data, "*.*");return data;}
static void main_sink(){char * data=main_data;free(data);}static void main(){char * data;data=NULL;{char mystring[]="mystring";data=strdup(mystring);}main_data=data;main_sink();}
static int main_source(int data){data=ASSERT_VALUE+1;return data;}static void main(){int data;data=-1;data=main_source(data);assert(data > ASSERT_VALUE);}
static void main_sink(wchar_t * data){fwprintf(stdout, L"%s\n", data);}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}main_sink(data);}
static void main(){{if (REMOVE(L"removemebad.txt")!=0){printLine("wremove failed!");exit(1);}}}
static void main(){int * data;struct_type my_struct;data=NULL;data=new int;my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){int * data=my_struct.a;delete data;}
void b_main_sink();static void main(){long long * data;data=(long long *)realloc(data, 100);_bad_data_for_good_sink=data;b_main_sink();}void b_main_sink(){long long * data=_bad_data_for_good_sink;if (data!=NULL){data[0]=5L;printLongLongLine(data[0]);free(data);}}
static void main(){void * data;_union_type my_union;data=NULL;data=CHAR_STRING;my_union.a=data;{void * data=my_union.b;{size_t data_len=strlen((char *)data);void * data_dest=(void *)calloc(data_len+1, 1);memcpy(data_dest, data, (data_len+1));printLine((char *)data_dest);free(data_dest);}}}
static void main(){int * data;data=NULL;{int data_goodbuf[100];data=data_goodbuf;data[0]=5;printIntLine(data[0]);}b_main_sink(&data);}void b_main_sink(int * * data_ptr){int * data=*data_ptr;}
void b_main_sink();static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{size_t i;char dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);}}
static void main_sink(int data){{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}static void main(){int data;data=-1;data=20;main_sink(data);}
static void main(){twoints * data;void (*func_ptr) (twoints *)=b_main_sink;data=NULL;data=(twoints *)calloc(100, sizeof(twoints));data[0].a=0;data[0].b=0;printStructLine(&data[0]);func_ptr(data);}void b_main_sink(twoints * data){free(data);}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;{wchar_t * data=*data_ptr1;wcscat(data, L"file.txt");}{wchar_t * data=*data_ptr2;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_t_or_f()){wcscat(data, L"*.*");}else{wcscat(data, L"*.*");}EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);_wsystem(data);}wchar_t * b_main_source(wchar_t * data){wcscpy(data, GOOD_OS_COMMAND);return data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}char * b_main_source(char * data){data=PASSWORD;return data;}
static void main(){wchar_t * password;wchar_t password_buf[100]=L"";password=password_buf;if(global_returns_t_or_f()){{size_t password_len=0;fgetws(password, 100, stdin);password_len=wcslen(password);if (password_len > 0){password[password_len-1]=L'\0';}}}else{{size_t password_len=0;fgetws(password, 100, stdin);password_len=wcslen(password);if (password_len > 0){password[password_len-1]=L'\0';}}}{HANDLE pHandle;wchar_t * username=L"User";wchar_t * domain=L"Domain";if (LogonUserW( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}
static void main(){char * data;union_type my_union;data=NULL;data=new char;my_union.a=data;{char * data=my_union.b;delete data;}}
static void main(){{twoints * data;twoints * * pointer=(twoints * *)ALLOCA(sizeof(twoints *));data=(twoints *)malloc(sizeof(twoints));data->a=5;data->b=6;{twoints * data=*pointer;printIntLine(data->a);printIntLine(data->b);}}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;data=NULL;{wchar_t * data=*data_ptr1;data=new wchar_t[100];}{wchar_t * data=*data_ptr2;{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));printWLine(data);delete [] data;}}}
static void main_sink(){wchar_t * data=_main_data;{wchar_t src[100];wcscpy(data, src);printWLine(data);}}static void main(){wchar_t * data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;_main_data=data;main_sink();}
static void main(){void * data;data=NULL;data=WIDE_STRING;b_main_sink(data);}void b_main_sink(void * data){c_main_sink(data);}void c_main_sink(void * data){d_main_sink(data);}void d_main_sink(void * data){e_main_sink(data);}void e_main_sink(void * data){{size_t data_len=wcslen((wchar_t *)data);void * data_dest=(void *)calloc(data_len+1, sizeof(wchar_t));memcpy(data_dest, data, (data_len+1)*sizeof(wchar_t));printWLine((wchar_t *)data_dest);free(data_dest);}}
static void main(){list<int> data;data=main_source(data);{list<int>::iterator i;cout << "The list contains: ";for( i=data.begin();i!=data.end();i++){cout << " " << *i;}cout << endl;}}list<int> main_source(list<int> data){data.push_back(100);data.push_back(0);return data;}
static void main(){int * data;data=NULL;data=(int *)malloc(100*sizeof(int));{size_t i;for(i=0;i < 100;i++){data[i]=5;}}b_main_sink(&data);}void b_main_sink(int * * data_ptr){int * data=*data_ptr;printIntLine(data[0]);}
static void main(){{wchar_t * pipeName=L"\\\\.\\pipe\\mypipe";HANDLE hPipe=INVALID_HANDLE_VALUE;BOOL fConnected=FALSE;hPipe=CreateNamedPipeW( pipeName, PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, BUFSIZE, BUFSIZE, NMPWAIT_USE_DEFAULT_WAIT, NULL);if (hPipe==INVALID_HANDLE_VALUE){exit(1);}if (GetLastError()==ERROR_ACCESS_DENIED){exit(1);}fConnected=ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError()==ERROR_PIPE_CONNECTED);CloseHandle(hPipe);}}
void b_main_sink(int data);static void main(){int data;data=-1;data=100-1;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void d_main_sink(int data);void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
static void main(){unsigned char data;data=' ';data=(unsigned char)rand();b_main_sink(data);}void b_main_sink(unsigned char data){{unsigned char result=0;if (data > 0){result=data-1;printHexUnsignedCharLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char dest[100];memset(dest, 'C', 100-1);memcpy(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);}}
static void main(){int data;data=-1;data=100-1;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
static void main_sink(wchar_t * data){delete data;}static void main(){wchar_t * data;data=NULL;data=new wchar_t;main_sink(data);}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");{char * data_copy=data;char * data=data_copy;main_vasink(data, data);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100];data=data_buf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{char dest[50]="";strcat(dest, data);printLine(data);}}
static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");my_union.a=data;{char * data=my_union.b;{char dest[100]="";SNPRINTF(dest, 100-1, data);printLine(dest);}}}
static void main(){int data;_union_type my_union;data=-1;data=OPEN("BadSource_open.txt", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);my_union.a=data;{int data=my_union.b;if (data!=-1){CLOSE(data);}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}printWLine(data);}}
static void main(){twoints * data;data=new twoints[10];{int i;for(i=0;i<10;i++){data[i].a=i;data[i].b=i;}}main_sink(&data);}void main_sink(void * void_data_ptr){twoints * * data_ptr=(twoints * *)void_data_ptr;twoints * data=(*data_ptr);{int i;for(i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}delete [] data;}
static void main(){wchar_t * data;_union_type my_union;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));data=data_buf;}my_union.a=data;{wchar_t * data=my_union.b;printWLine(data);free(data);}}
void b_main_sink(void * void_data_ptr);static void main(){char * data;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{char src[100];strncpy(data, src, 100);data[100-1]='\0';printLine(data);}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}}{wchar_t * data=*data_ptr2;if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf(data, args);va_end(args);}}void c_main_sink(char * data){main_vasink(data, data);}
void _main_sink(char * data){{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");_main_sink(data);}
static void main(){twointsclass * data;twointsclass * data_array[5];data=NULL;data=new twointsclass[100];data_array[2]=data;main_sink(data_array);}void main_sink(twointsclass * data_array[]){twointsclass * data=data_array[2];delete [] data;}
void _main_sink(long long * data){{memmove(data, src, 100*sizeof(long long));printLongLongLine(data[0]);}}static void main(){long long * data;long long * data_badbuf=(long long *)ALLOCA(50*sizeof(long long));long long * data_goodbuf=(long long *)ALLOCA(100*sizeof(long long));data=data_goodbuf;_main_sink(data);}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;strcat(data, "*.*");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;data=NULL;data=(char *)malloc(100*sizeof(char));my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char dest[100];memset(dest, 'C', 100-1);memcpy(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);free(data);}}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, data, args);va_end(args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");{wchar_t * data_copy=data;wchar_t * data=data_copy;main_vasink(data, data);}}
void b_main_sink(void * void_data_ptr);static void main(){float data;data=0.0F;data=7.0F;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){float * data_ptr=(float *)void_data_ptr;float data=(*data_ptr);printDoubleLine((double)(100.0/data));}
static void main(){wchar_t * data;struct_type my_struct;data=NULL;wchar_t data_good;data=&data_good;printHexCharLine((char)*data);my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){wchar_t * data=my_struct.a;}
static void main(){int * data;data=NULL;data=new int[100];delete [] data;main_sink(&data);}void main_sink(int * * data_ptr){int * data=*data_ptr;}
static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}my_union.a=data;{char * data=my_union.b;if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}}
static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));if(global_returns_t_or_f()){data=data_goodbuf;}else{data=data_goodbuf;}{char dest[100];memset(dest, 'C', 100-1);memmove(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);}}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf(data, args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");{char * data_copy=data;char * data=data_copy;main_vasink(data, data);}}
static int main_source(int data){data=CHAR_MAX-5;return data;}static void main(){int data;data=-1;data=main_source(data);{char c=(char)data;printHexCharLine(c);}}
static void main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}main_sink(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{wchar_t src[100];wcscpy(data, src);printWLine(data);}}
static void main_sink(){char * data=_main_data;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");_main_data=data;main_sink();}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf("%s", args);va_end(args);}}void c_main_sink(char * data){main_vasink(data, data);}
static void main(){int data;union_type my_union;data=-1;data=20;my_union.a=data;{int data=my_union.b;{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[250]=L"PATH=";data=data_buf;{wchar_t * data=*data_ptr1;wcscat(data, NEW_PATH);}{wchar_t * data=*data_ptr2;PUTENV(data);}}
static void main(){int * data;data=NULL;data=(int *)malloc(100*sizeof(int));free(data);_main_data=data;b_main_sink();}void b_main_sink(){int * data=_main_data;}
static void main(){unsigned char data;data=' ';data=5;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){unsigned char * data_ptr=(unsigned char *)void_data_ptr;unsigned char data=(*data_ptr);{unsigned char result=data * 2;printHexUnsignedCharLine(result);}}
void _main_sink(wchar_t * data){{wchar_t src[100];_snwprintf(data, 100, L"%s", src);printWLine(data);free(data);}}static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));_main_sink(data);}
static void main(){char * data;char * data_array[5];data=NULL;data=new char[100];strcpy(data, "A String");printLine(data);data_array[2]=data;main_sink(data_array);}void main_sink(char * data_array[]){char * data=data_array[2];delete[] data;}
static void main(){{char * pipeName="\\\\.\\pipe\\mypipe";HANDLE hPipe=INVALID_HANDLE_VALUE;BOOL fConnected=FALSE;hPipe=CreateNamedPipeA( pipeName, PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, BUFSIZE, BUFSIZE, NMPWAIT_USE_DEFAULT_WAIT, NULL);if (hPipe==INVALID_HANDLE_VALUE){exit(1);}if (GetLastError()==ERROR_ACCESS_DENIED){exit(1);}fConnected=ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError()==ERROR_PIPE_CONNECTED);CloseHandle(hPipe);}}
static void main(){twointsclass * data;void (*func_ptr) (twointsclass *)=main_sink;data=NULL;data=new twointsclass[100];func_ptr(data);}void main_sink(twointsclass * data){delete [] data;}
static void main(){char data;data=' ';data=(char)rand();_main_data=data;b_main_sink();}void b_main_sink(){char data=_main_data;{char result=-1;if (data < CHAR_MAX){result=data+1;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
void b_main_sink();static void main(){int * data;data=NULL;data=(int *)malloc(10*sizeof(int));_main_data=data;b_main_sink();}void b_main_sink(){int * data=_main_data;{int data_src[10]={0};size_t i;for (i=0;i < 10;i++){data[i]=data_src[i];}printIntLine(data[0]);free(data);}}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main_sink(char * data){{int i, n, v;if (sscanf(data, "%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}func_ptr(data);}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]="";data=data_buf;{char * data=*data_ptr1;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}}{char * data=*data_ptr2;{char dest[100]="";SNPRINTF(dest, 100-1, "%s", data);printLine(dest);}}}
static void main(){twointsclass * data;data=NULL;main_source(data);delete [] data;}void main_source(twointsclass * &data){data=new twointsclass[100];}
static wchar_t * main_source(wchar_t * data){wcscat(data, L"file.txt");return data;}static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;data=main_source(data);{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main_sink(twoints * data){{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memcpy(data, src, 100*sizeof(twoints));printStructLine(&data[0]);free(data);}}static void main(){twoints * data;void (*func_ptr) (twoints *)=main_sink;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));func_ptr(data);}
void _main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnv(_P_WAIT, COMMAND_INT_PATH, args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_sink(data);}
static void main_sink(){wchar_t * data=_main_data;_wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_data=data;main_sink();}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=RAND32();}{int data=*data_ptr2;{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){char data;data=' ';data=(char)rand();{char result=-1;if (data < CHAR_MAX){result=data+1;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[250]=L"PATH=";data=data_buf;wcscat(data, NEW_PATH);data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];PUTENV(data);}
void b_main_sink(_struct_type my_struct);static void main(){short data;_struct_type my_struct;data=0;data=100-1;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){short data=my_struct.a;{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
static void main(){if(global_returns_t_or_f()){{char * pipeName="\\\\.\\pipe\\mypipe";HANDLE hPipe=INVALID_HANDLE_VALUE;hPipe=CreateNamedPipeA( pipeName, FILE_FLAG_FIRST_PIPE_INSTANCE, PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, BUFSIZE, BUFSIZE, NMPWAIT_USE_DEFAULT_WAIT, NULL);if (hPipe==INVALID_HANDLE_VALUE){exit(1);}if (GetLastError()==ERROR_ACCESS_DENIED){exit(1);}if (!ImpersonateNamedPipeClient(hPipe)){exit(1);}CloseHandle(hPipe);}}else{{char * pipeName="\\\\.\\pipe\\mypipe";HANDLE hPipe=INVALID_HANDLE_VALUE;hPipe=CreateNamedPipeA( pipeName, FILE_FLAG_FIRST_PIPE_INSTANCE, PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, BUFSIZE, BUFSIZE, NMPWAIT_USE_DEFAULT_WAIT, NULL);if (hPipe==INVALID_HANDLE_VALUE){exit(1);}if (GetLastError()==ERROR_ACCESS_DENIED){exit(1);}if (!ImpersonateNamedPipeClient(hPipe)){exit(1);}CloseHandle(hPipe);}}}
void main_sink();static void main(){twointsclass * data;{twointsclass * data_buf=new twointsclass[100];{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}_main_data=data;main_sink();}void main_sink(){twointsclass * data=_main_data;printIntLine(data[0].a);delete [] data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(&data);}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf("%s", args);va_end(args);}}void b_main_sink(char * * data_ptr){char * data=*data_ptr;main_vasink(data, data);}
static void main_sink(){char * data=_main_data;{char dest[50]="";strncat(dest, data, strlen(data));printLine(data);}}static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;_main_data=data;main_sink();}
static void main(){int data;data=-1;data=20;main_sink_b(data);}void main_sink_b(int data){main_sink_c(data);}void main_sink_c(int data){main_sink_d(data);}void main_sink_d(int data){{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){wprintf(L"%s\n", data);}
static void main(){int data;data=RAND32();{char data_buf[10]="AAAAAAAAA";{printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
void main_sink(wchar_t * data){{wchar_t dest[50]=L"";wcsncat(dest, data, wcslen(data));printWLine(data);delete [] data;}}static void main(){wchar_t * data;data=new wchar_t[100];main_sink(data);}
static void main(){struct _twoints * data;data=NULL;struct _twoints data_good;data=&data_good;data->a=0;data->b=0;printStructLine((twoints *)data);main_sink(data);}void main_sink(struct _twoints * data){}
static void main(){double * data;data=(double *)ALLOCA(10*sizeof(double));{int i;for(i=0;i<10;i++){data[i]=(double)i;}}b_main_sink(&data);}void b_main_sink(double * * data_ptr){double * data=*data_ptr;{int i;for(i=0;i<10;i++){printDoubleLine(data[i]);}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){twoints * data;data=NULL;main_source(data);delete data;}void main_source(twoints * &data){data=new twoints;}
void main_sink();static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}_main_data=data;main_sink();}void main_sink(){wchar_t * data=_main_data;{wchar_t src[100];wcsncpy(data, src, 100);data[100-1]=L'\0';printWLine(data);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t src[100];wcsncpy(data, src, 100);data[100-1]=L'\0';printWLine(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=L"P";_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;data=(wchar_t *)malloc(100*sizeof(wchar_t));my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{wchar_t dest[50]=L"";wcsncat(dest, data, wcslen(data));printWLine(data);free(data);}}
static void main(){wchar_t * data;_union_type my_union;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}my_union.a=data;{wchar_t * data=my_union.b;{wchar_t src[100];wcscpy(data, src);printWLine(data);}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}char * b_main_source(char * data){data="P";return data;}
static void main(){if(global_returns_t_or_f()){{wchar_t data_buf[100]=L"";wchar_t * data=data_buf;if (swscanf(SRC, L"%99s\0", data)==EOF){printLine("swscanf failed!");exit(1);}}}else{{wchar_t data_buf[100]=L"";wchar_t * data=data_buf;if (swscanf(SRC, L"%99s\0", data)==EOF){printLine("swscanf failed!");exit(1);}}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){unsigned char data;data=' ';data=5;b_main_sink(data);}void b_main_sink(unsigned char data){c_main_sink(data);}void c_main_sink(unsigned char data){d_main_sink(data);}void d_main_sink(unsigned char data){{unsigned char result=data-1;printHexUnsignedCharLine(result);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}void d_main_sink(wchar_t * data){main_vasink(data, data);}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;{char * data=*data_ptr1;strcat(data, "file.txt");}{char * data=*data_ptr2;{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}}
static void main_sink(long long * data){{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printLongLongLine(data[0]);delete [] data;}}}static void main(){long long * data;void (*func_ptr) (long long *)=main_sink;data=NULL;data=new long long[100];func_ptr(data);}
static void main(){int * data;int * data_badbuf=(int *)ALLOCA(50*sizeof(int));int * data_goodbuf=(int *)ALLOCA(100*sizeof(int));if(global_returns_t_or_f()){data=data_goodbuf;}else{data=data_goodbuf;}{memmove(data, src, 100*sizeof(int));printIntLine(data[0]);}}
static void main_sink(){char * data=_main_data;{int i, n, v;if (sscanf(data, "%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}_main_data=data;main_sink();}
static void main_sink(int data){printIntLine(100 % data);}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=7;func_ptr(data);}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;wcscpy(data, GOOD_OS_COMMAND);}{wchar_t * data=*data_ptr2;_wsystem(data);}}
static void main_source(twointsclass * &data){data=new twointsclass[100];}static void main(){twointsclass * data;data=NULL;main_source(data);delete [] data;}
static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"15");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main(){char data;data=' ';data=5;b_main_sink(data);}void b_main_sink(char data){c_main_sink(data);}void c_main_sink(char data){d_main_sink(data);}void d_main_sink(char data){{char result=data-1;printHexCharLine(result);}}
static void main_sink(wchar_t * data){{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, GOOD_OS_COMMAND);func_ptr(data);}
static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;if(global_returns_t_or_f()){strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");}else{strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");}{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){int data;data=7;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;if (wcsncmp(PASSWORD, data, wcslen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink();static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{char src[100];_snprintf(data, 100, "%s", src);printLine(data);}}
static void main(){int * data;int * *data_ptr1=&data;int * *data_ptr2=&data;data=NULL;{int * data=*data_ptr1;data=new int;}{int * data=*data_ptr2;delete data;}}
char * b_main_source(char * data);static void main(){char * data;char data_buf[250]="PATH=";data=data_buf;data=b_main_source(data);PUTENV(data);}char * b_main_source(char * data){strcat(data, NEW_PATH);return data;}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;func_ptr(data);}void b_main_sink(char * data){{char src[100];strncpy(data, src, 100);data[100-1]='\0';printLine(data);}}
void main_sink_b(char * data);static void main(){char * data;data=new char[100];main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){{char dest[50]="";size_t i, data_len;data_len=strlen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printLine(data);delete [] data;}}
void b_main_sink(int data);static void main(){int data;data=-1;data=ASSERT_VALUE+1;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){assert(data > ASSERT_VALUE);}
char * main_source(char * data);static void main(){char * data;data=NULL;data=main_source(data);{char src[100];strcpy(data, src);printLine(data);}}char * main_source(char * data){{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}return data;}
static void main(){int data;data=7;{int data_copy=data;int data=data_copy;{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}}
static void main_sink(twoints * data){delete [] data;}static void main(){twoints * data;void (*func_ptr) (twoints *)=main_sink;data=NULL;data=new twoints[100];func_ptr(data);}
static void main(){char * data;char * data_array[5];data=NULL;{char mystring[]="mystring";data=strdup(mystring);}data_array[2]=data;main_sink(data_array);}void main_sink(char * data_array[]){char * data=data_array[2];free(data);}
static void main_sink(char * data){if (data!=NULL){strcpy(data, "Initialize");printLine(data);free(data);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=(char *)malloc(100);func_ptr(data);}
static void main(){unsigned int data;data=0;data=b_main_source(data);{unsigned int result=data * 2;printUnsignedLine(result);}}unsigned int b_main_source(unsigned int data){data=5;return data;}
static void main(){int data;data=7;b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main_vasinkg(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, "%s", args);va_end(args);printLine(dest);}}static void main_vasinkb(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, data, args);va_end(args);printLine(dest);}}static void main(){char * data;char data_buf[100]="";data=data_buf;if(global_returns_f()){strcpy(data, "fixedstringtest");}else{strcpy(data, "fixedstringtest");}if(global_returns_t()){main_vasinkb(data, data);}else{main_vasinkb(data, data);}}
static void main(){unsigned int data;void (*func_ptr) (unsigned int)=b_main_sink;data=0;fscanf (stdin, "%u", &data);func_ptr(data);}void b_main_sink(unsigned int data){{unsigned int result=-1;if (data <=(unsigned int)sqrt((unsigned int)UINT_MAX)){result=data * data;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=100-1;func_ptr(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){if (strstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"C:\\Windows\\System32\\winsrv.dll");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{HMODULE hModule;hModule=LoadLibraryW(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
static twoints * main_source(twoints * data){data=(twoints *)calloc(100, sizeof(twoints));data[0].a=0;data[0].b=0;printStructLine(&data[0]);return data;}static void main(){twoints * data;data=NULL;data=main_source(data);free(data);}
static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_sink(&data);}void main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;delete [] data;}
static void main(){char data;data=' ';data=5;{char result=data+1;printHexCharLine(result);}}
static void main(){int data;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0 && data < 10){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){int * data;int * *data_ptr1=&data;int * *data_ptr2=&data;data=NULL;{int * data=*data_ptr1;data=(int *)malloc(10*sizeof(int));}{int * data=*data_ptr2;{int data_src[10]={0};size_t i;for (i=0;i < 10;i++){data[i]=data_src[i];}printIntLine(data[0]);free(data);}}}
static void main(){int data;int data_array[5];data=7;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{wchar_t data_buf[10]=L"AAAAAAAAA";if (data >=0){printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main(){char * data;data=NULL;if(global_returns_t_or_f()){{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}}else{{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}}{char dest[100];memcpy(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(data);}static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, data, args);va_end(args);printLine(dest);}}void b_main_sink(char * data){main_vasink(data, data);}
static void main(){long long * data;data=NULL;data=NULL;data=(long long *)realloc(data, 100*sizeof(long long));main_sink_b(data);}void main_sink_b(long long * data){main_sink_c(data);}void main_sink_c(long long * data){main_sink_d(data);}void main_sink_d(long long * data){main_sink_e(data);}void main_sink_e(long long * data){free(data);}
static void main(){unsigned int data;unsigned int data_array[5];data=0;data=5;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(unsigned int data_array[]){unsigned int data=data_array[2];{unsigned int result=data * 2;printUnsignedLine(result);}}
static void main_sink(){char * data=_main_data;{char src[100];strncpy(data, src, 100);printLine(data);}}static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;_main_data=data;main_sink();}
static void main(){int data;data=7;b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
void b_main_sink(int * data);static void main(){int * data;int data_badbuf[50];int data_goodbuf[100];data=data_goodbuf;b_main_sink(data);}void c_main_sink(int * data);void b_main_sink(int * data){c_main_sink(data);}void d_main_sink(int * data);void c_main_sink(int * data){d_main_sink(data);}void d_main_sink(int * data){{memcpy(data, src, 100*sizeof(int));printIntLine(data[0]);}}
static void main(){long long * data;data=NULL;data=new long long[100];{size_t i;for(i=0;i < 100;i++){data[i]=5L;}}main_sink(&data);}void main_sink(void * void_data_ptr){long long * * data_ptr=(long long * *)void_data_ptr;long long * data=(*data_ptr);printLongLongLine(data[0]);}
static void main(){wchar_t * data;data=NULL;data=new wchar_t;delete data;main_sink(&data);}void main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}_main_data=data;b_main_sink();}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, L"%s", args);va_end(args);}}void b_main_sink(){wchar_t * data=_main_data;main_vasink(data, data);}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;main_sink(&data);}void main_sink(void * void_data_ptr){twointsclass * * data_ptr=(twointsclass * *)void_data_ptr;twointsclass * data=(*data_ptr);delete data;}
static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));{char src[100];strcat(data, src);printLine(data);free(data);}}
static void main(){int data;int data_array[5];data=-1;data=20;data_array[2]=data;main_sink(data_array);}void main_sink(int data_array[]){int data=data_array[2];{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}
static void main_sink(struct _twoints * data){free(data);}static void main(){struct _twoints * data;void (*func_ptr) (struct _twoints *)=main_sink;data=NULL;data=NULL;data=(struct _twoints *)realloc(data, 100*sizeof(struct _twoints));data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);func_ptr(data);}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;data=b_main_source(data);{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}wchar_t * b_main_source(wchar_t * data){wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");return data;}
static void main(){FILE * data;data=NULL;data=freopen("BadSource_freopen.txt","w+",stdin);if(global_returns_t_or_f()){if (data!=NULL){fclose(data);}}else{if (data!=NULL){fclose(data);}}}
static void main(){char * data;data=NULL;data="Good";printf("%s\n", data);}
void b_main_sink(twoints * * data);static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));b_main_sink(&data);}void b_main_sink(twoints * * data_ptr){twoints * data=*data_ptr;{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memcpy(data, src, 100*sizeof(twoints));printStructLine(&data[0]);free(data);}}
static void main(){char data;data=' ';data=(char)rand();b_main_sink(data);}void b_main_sink(char data){c_main_sink(data);}void c_main_sink(char data){d_main_sink(data);}void d_main_sink(char data){{char result=-1;if (data <=(char)sqrt((char)CHAR_MAX)){result=data * data;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){int data;_union_type my_union;data=-1;data=INT_MIN;my_union.a=data;{int data=my_union.b;{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}}
static void main(){list<int> data;data.push_back(100);data.push_back(200);main_sink(data);}void main_sink(list<int> data){{list<int>::iterator i;cout << "The list contains: ";for( i=data.begin();i!=data.end();i++){if (!*i){data.clear();}cout << " " << *i;}cout << endl;}}
static void main_sink(int * data){{memmove(data, src, 100*sizeof(int));printIntLine(data[0]);}}static void main(){int * data;void (*func_ptr) (int *)=main_sink;int * data_badbuf=(int *)ALLOCA(50*sizeof(int));int * data_goodbuf=(int *)ALLOCA(100*sizeof(int));data=data_goodbuf;func_ptr(data);}
static int static_global_main=5;static void main(){printIntLine(static_global_main);}
void b_main_sink(int data_array[]);static void main(){int data;int data_array[5];data=-1;data=CHAR_MAX-5;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{char c=(char)data;printHexCharLine(c);}}
void _main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}static void main(){int data;data=-1;data=100-1;_main_sink(data);}
void main_sink(wchar_t * data);static void main(){wchar_t * data;data=new wchar_t[100];main_sink(data);}void main_sink(wchar_t * data){{wchar_t dest[50]=L"";memmove(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);delete [] data;}}
static void main(){{if (RpcImpersonateClient(0)!=RPC_S_OK){exit(1);}}}
static void main(){struct _twoints * data;data=NULL;{struct _twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);}_main_data=data;b_main_sink();}void b_main_sink(){struct _twoints * data=_main_data;}
static void main_source(long long * &data){data=new long long[100];}static void main(){long long * data;data=NULL;main_source(data);delete [] data;}
static void main_sink(long long * data){printLongLongLine(data[0]);free(data);}static void main(){long long * data;void (*func_ptr) (long long *)=main_sink;{long long * data_buf=(long long *)malloc(100*sizeof(long long));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5L;}}data=data_buf;}func_ptr(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){e_main_sink(data);}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf(data, args);va_end(args);}}void e_main_sink(char * data){main_vasink(data, data);}
static void main(){char data;_union_type my_union;data=' ';data=(char)rand();my_union.a=data;{char data=my_union.b;{char result=0;if (data > CHAR_MIN){result=data-1;printHexCharLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}}
static void main(){char * data;_union_type my_union;data=(char *)malloc(100*sizeof(char));data[0]='\0';{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}my_union.a=data;{char * data=my_union.b;{size_t i;for (i=0;i < strlen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");func_ptr(data);}void b_main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnvp(_P_WAIT, COMMAND_INT, args);}}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));free(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(char * data){if (strstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}void b_main_sink(wchar_t * data){{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, L"%s", data);printWLine(dest);}}
static void main(){if(global_returns_t_or_f()){try{if (rand()%2==0) throw out_of_range("err1");if (rand()%2==0) throw domain_error("err2");}catch (out_of_range &){printLine("out_of_range");}catch (domain_error &){printLine("domain_error");return;}printLine("ok");}else{try{if (rand()%2==0) throw out_of_range("err1");if (rand()%2==0) throw domain_error("err2");}catch (out_of_range &){printLine("out_of_range");}catch (domain_error &){printLine("domain_error");return;}printLine("ok");}}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
static void main(){int * data;data=NULL;data=(int *)calloc(100, sizeof(int));main_sink_b(data);}void main_sink_b(int * data){main_sink_c(data);}void main_sink_c(int * data){free(data);}
static void main(){char * data;{char * data_buf=new char[100];data=data_buf;}{char * data_copy=data;char * data=data_copy;printLine(data);delete [] data;}}
void main_sink(char * data);static void main(){char * data;data=new char[100];main_sink(data);}void main_sink(char * data){{char dest[50]="";strncat(dest, data, strlen(data));printLine(data);delete [] data;}}
static void main_sink(unsigned int data){{unsigned int result=-1;if (data < UINT_MAX){result=data+1;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}static void main(){unsigned int data;void (*func_ptr) (unsigned int)=main_sink;data=0;data=(unsigned int)RAND32();func_ptr(data);}
static void main(){twointsclass * data;data=NULL;data=main_source(data);delete data;}twointsclass * main_source(twointsclass * data){data=new twointsclass;return data;}
static twointsclass * main_source(twointsclass * data){{twointsclass * data_buf=new twointsclass[100];{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}return data;}static void main(){twointsclass * data;data=main_source(data);printIntLine(data[0].a);delete [] data;}
void main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}func_ptr(data);}void main_sink(char * data){{char src[100];strncpy(data, src, 100);data[100-1]='\0';printLine(data);}}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}my_union.a=data;{wchar_t * data=my_union.b;{int i, n, v;if (swscanf(data, L"%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, L"%s", data);printWLine(dest);}}wchar_t * b_main_source(wchar_t * data){{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}return data;}
static void main_sink(char * data){if (data!=NULL){strcpy(data, "Initialize");printLine(data);free(data);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=(char *)realloc(data, 100);func_ptr(data);}
static void main(){char * data;char * &data_ref=data;data=NULL;data=new char[100];{char * data=data_ref;{char src[100];_snprintf(data, 100, "%s", src);printLine(data);delete [] data;}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static char main_source(char data){data=5;return data;}static void main(){char data;data=' ';data=main_source(data);{char result=data-1;printHexCharLine(result);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);{int i, n, v;if (swscanf(data, L"%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}wchar_t * b_main_source(wchar_t * data){{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}return data;}
static void main(){unsigned char data;_union_type my_union;data=' ';data=UCHAR_MAX;my_union.a=data;{unsigned char data=my_union.b;{unsigned char result=-1;if (data < UCHAR_MAX){result=data+1;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
static void main(){unsigned char data;data=' ';data=(unsigned char)rand();{unsigned char result=0;if (data > 0){result=data-1;printHexUnsignedCharLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static void main(){int data;data=-1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){int * data;data=(int *)ALLOCA(10*sizeof(int));if(global_returns_t_or_f()){{int i;for(i=0;i<10;i++){data[i]=i;}}}else{{int i;for(i=0;i<10;i++){data[i]=i;}}}if(global_returns_t_or_f()){{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}}else{{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}}}
static void main(){{int x;x=(rand() % 3);switch (x){case 0: printLine("0");break;case 1: printLine("1");break;case 2: printLine("2");break;}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100];data=data_buf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{size_t src_len;char src[100];src_len=strlen(src);strncat(data, src, src_len);printLine(data);}}
static void main(){char data;data=' ';data=(char)rand();b_main_sink(&data);}void b_main_sink(char * data_ptr){char data=*data_ptr;{char result=-1;if (data <=(char)sqrt((char)CHAR_MAX)){result=data * data;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
void b_main_sink(short data);static void main(){short data;data=-1;data=CHAR_MAX-5;b_main_sink(data);}void b_main_sink(short data){{char c=(char)data;printHexCharLine(c);}}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, GOOD_OS_COMMAND);b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}
static void main(){unsigned int data;data=0;data=5;b_main_sink(data);}void b_main_sink(unsigned int data){c_main_sink(data);}void c_main_sink(unsigned int data){{unsigned int result=data * 2;printUnsignedLine(result);}}
static void main(){int data;int &data_ref=data;data=-1;data=20;{int data=data_ref;{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}}
static void main(){int * data;int * *data_ptr1=&data;int * *data_ptr2=&data;data=NULL;{int * data=*data_ptr1;data=new int;}{int * data=*data_ptr2;delete data;}}
static void main(){printLine("Hello");return;}
static void main_sink(){int data=_main_data;{int result=-1;if (data < INT_MAX){result=data+1;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}_main_data=data;main_sink();}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(data, args);va_end(args);}}void c_main_sink(wchar_t * data){main_vasink(data, data);}
void b_main_sink(char * data);static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{char src[100];memcpy(data, src, 100*sizeof(char));printLine(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"C:\\Windows\\System32\\winsrv.dll");{HMODULE hModule;hModule=LoadLibraryW(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
void main_sink(wchar_t * data){{wchar_t src[100];_snwprintf(data, 100, L"%s", src);printWLine(data);delete [] data;}}static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_sink(data);}
static void main(){int data;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{char data_buf[10]="AAAAAAAAA";{printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){long long * data;long long * *data_ptr1=&data;long long * *data_ptr2=&data;{long long * data=*data_ptr1;{long long * data_buf=new long long[100];{size_t i;for (i=0;i < 100;i++){data_buf[i]=5L;}}data=data_buf;}}{long long * data=*data_ptr2;printLongLongLine(data[0]);delete [] data;}}
static void main(){twoints * data;_struct_type my_struct;data=NULL;{twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine(&data[0]);}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){twoints * data=my_struct.a;}
static void main_sink(){HANDLE data=_main_data;if (data!=INVALID_HANDLE_VALUE){CloseHandle(data);}}static void main(){HANDLE data;data=INVALID_HANDLE_VALUE;data=CreateFile("BadSource_w32CreateFile.txt", (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);_main_data=data;main_sink();}
static void main(){char * data;char data_buf[100]="";data=data_buf;if(global_returns_t_or_f()){strcat(data, "*.*");}else{strcat(data, "*.*");}_spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){long long * data;data=NULL;main_source(data);}void main_source(long long * &data){data=new long long[100];delete [] data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{int i, n, v;if (sscanf(data, "%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';{wchar_t * data=*data_ptr1;data=data_buf;}{wchar_t * data=*data_ptr2;{wchar_t dest[100];memcpy(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "C:\\Windows\\System32\\winsrv.dll");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{HMODULE hModule;hModule=LoadLibraryA(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
void b_main_sink(char * data);static void main(){char * data;data=NULL;data=(char *)malloc((10+1)*sizeof(char));b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{char data_src[10+1]=SRC_STRING;memmove(data, data_src, strlen(data_src)*sizeof(char));printLine(data);free(data);}}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}printWLine(data);}}
static void main(){int data;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}{int data_copy=data;int data=data_copy;{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=100-1;}{int data=*data_ptr2;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}}
static void main_sink(){wchar_t * data=_main_data;{wchar_t src[100];wcscpy(data, src);printWLine(data);free(data);}}static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));_main_data=data;main_sink();}
static void main(){unsigned char data;data=' ';data=(unsigned char)rand();b_main_sink(data);}void b_main_sink(unsigned char data){c_main_sink(data);}void c_main_sink(unsigned char data){d_main_sink(data);}void d_main_sink(unsigned char data){{unsigned char result=-1;if (data < UCHAR_MAX){result=data+1;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_t_or_f()){wcscpy(data, L"fixedstringtest");}else{wcscpy(data, L"fixedstringtest");}if(global_returns_t_or_f()){{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, data);printWLine(dest);}}else{{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, data);printWLine(dest);}}}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];data=(char *)malloc(100*sizeof(char));data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{char dest[50]="";strcpy(dest, data);printLine(data);free(data);}}
static void main(){twoints * data;data=NULL;if(global_returns_t_or_f()){data=new twoints[100];{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}}else{data=new twoints[100];{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}}if(global_returns_t_or_f()){printStructLine(&data[0]);}else{printStructLine(&data[0]);}}
void b_main_sink(long long * data);static void main(){long long * data;void (*func_ptr) (long long *)=b_main_sink;long long data_badbuf[50];long long data_goodbuf[100];data=data_goodbuf;func_ptr(data);}void b_main_sink(long long * data){{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printLongLongLine(data[0]);}}}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main_sink(int * data){free(data);}static void main(){int * data;void (*func_ptr) (int *)=main_sink;data=NULL;data=(int *)malloc(100*sizeof(int));data[0]=5;printIntLine(data[0]);func_ptr(data);}
static void main(){{FILE *file;HCRYPTPROV cryptoprov;HCRYPTKEY key;HCRYPTHASH hash;char password[100];size_t password_len;char toBeDecrypted[100];DWORD toBeDecryptedLen=sizeof(toBeDecrypted)-1;printLine("Enter the password: ");fgets(password, 100, stdin);password_len=strlen(password);if (password_len > 0){password[password_len-1]='\0';}file=fopen("encrypted.txt", "rb");if (file==NULL) exit(1);if (fread(toBeDecrypted, sizeof(char), 100, file)!=100){fclose(file);exit(1);}toBeDecrypted[99]='\0';if(!CryptAcquireContext(&cryptoprov, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, 0)){if(!CryptAcquireContext(&cryptoprov, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET)){printLine("Error in acquiring cryptographic context");exit(1);}}if(!CryptCreateHash(cryptoprov, CALG_SHA1, 0, 0, &hash)){printLine("Error in creating hash");exit(1);}if(!CryptHashData(hash, (BYTE *) password, password_len, 0)){printLine("Error in hashing password");exit(1);}if(!CryptDeriveKey(cryptoprov, CALG_3DES, hash, 0, &key)){printLine("Error in CryptDeriveKey");exit(1);}if(!CryptDecrypt(key, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen)){printLine("Error in decryption");exit(1);}printLine(toBeDecrypted);CryptReleaseContext(cryptoprov,0);CryptDestroyHash(hash);CryptDestroyKey(key);fclose(file);}}
static void main(){int data;data=-1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{int result=-1;if (data <=(INT_MAX/2)){result=data * 2;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main_sink(){char * data=_main_data;printf("%s\n", data);}static void main(){char * data;data=NULL;data="Good";_main_data=data;main_sink();}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;func_ptr(data);}void b_main_sink(char * data){{char dest[50]="";size_t i, data_len;data_len=strlen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printLine(data);}}
void b_main_sink(char * data);static void main(){char * data;data=(char *)malloc(100*sizeof(char));b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{char dest[50]="";strcat(dest, data);printLine(data);free(data);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{wchar_t dest[50]=L"";memmove(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);}}
static int main_source(int data){data=5;return data;}static void main(){int data;data=-1;data=main_source(data);{int result=data * 2;printIntLine(result);}}
void b_main_sink(char * data);static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;b_main_sink(data);}void b_main_sink(char * data){{char src[100];memcpy(data, src, 100*sizeof(char));printLine(data);}}
static void main(){char data;data=' ';data=5;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * data_ptr=(char *)void_data_ptr;char data=(*data_ptr);{char result=data-1;printHexCharLine(result);}}
static void main(){twoints * data;union_type my_union;data=NULL;data=new twoints[100];my_union.a=data;{twoints * data=my_union.b;delete [] data;}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");func_ptr(data);}void b_main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnvp(_P_WAIT, COMMAND_INT, args);}}
static void main(){long long * data;data=NULL;data=new long long[100];main_sink(&data);}void main_sink(long long * * data_ptr){long long * data=*data_ptr;delete [] data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}func_ptr(data);}void b_main_sink(wchar_t * data){{wchar_t src[100];wcscpy(data, src);printWLine(data);}}
void main_sink(void * void_data_ptr);static void main(){int * data;{int * data_buf=new int[100];{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}main_sink(&data);}void main_sink(void * void_data_ptr){int * * data_ptr=(int * *)void_data_ptr;int * data=(*data_ptr);printIntLine(data[0]);delete [] data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, L"%s", args);va_end(args);printWLine(dest);}}void b_main_sink(wchar_t * data){main_vasink(data, data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");my_struct.a=data;b_main_sink(my_struct);}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;main_vasink(data, data);}
static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));if(global_returns_t_or_f()){data=data_goodbuf;}else{data=data_goodbuf;}{char src[100];strcat(data, src);printLine(data);}}
static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}void main_sink(int data){{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main_sink(){int data=_main_data;printIntLine(100 % data);}static void main(){int data;data=-1;data=7;_main_data=data;main_sink();}
static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;{wchar_t dest[100];wmemset(dest, L'C', 100-1);memmove(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main_sink(){wchar_t * data=_main_data;_wsystem(data);}static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");_main_data=data;main_sink();}
static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));free(data);}
static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, "%s", args);va_end(args);printLine(dest);}}static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]="";data=data_buf;{char * data=*data_ptr1;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}}{char * data=*data_ptr2;main_vasink(data, data);}}
static wchar_t * main_source(wchar_t * data){return data;}static void main(){wchar_t * data;data=new wchar_t[100];data=main_source(data);{wchar_t dest[50]=L"";size_t i, data_len;data_len=wcslen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printWLine(data);delete [] data;}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]="";data=data_buf;{char * data=*data_ptr1;strcpy(data, "fixedstringtest");}{char * data=*data_ptr2;printf(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;{wchar_t * data_copy=data;wchar_t * data=data_copy;if (wcsncmp(PASSWORD, data, wcslen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}}
static void main_sink(int count){{size_t i=0;FILE *file=NULL;const char *filename="output_good.txt";if (count > 0 && count <=20){file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}}static void main(){int count;count=-1;fscanf (stdin, "%d", &count);main_sink(count);}
static void main(){int data;data=-1;data=20;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}
static void main(){HANDLE data;data=CreateFile("GoodSource_w32CreateFile.txt", (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);b_main_sink(data);}void b_main_sink(HANDLE data){c_main_sink(data);}void c_main_sink(HANDLE data){d_main_sink(data);}void d_main_sink(HANDLE data){CloseHandle(data);}
void main_sink(struct_type my_struct);static void main(){wchar_t * data;struct_type my_struct;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){wchar_t * data=my_struct.a;{wchar_t dest[100];memmove(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");my_union.a=data;{wchar_t * data=my_union.b;_wsystem(data);}}
void main_sink(char * data);static void main(){char * data;data=NULL;data=new char[100];main_sink(data);}void main_sink(char * data){{char src[100];strcat(data, src);printLine(data);delete [] data;}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{size_t src_len;wchar_t src[100];src_len=wcslen(src);wcsncat(data, src, src_len);printWLine(data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;if(global_returns_t_or_f()){strcat(data, "*.*");}else{strcat(data, "*.*");}{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
static void main(){twoints * data;data=NULL;data=NULL;data=(twoints *)realloc(data, 100*sizeof(twoints));main_sink(data);}void main_sink(twoints * data){free(data);}
static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t src[100];wcsncpy(data, src, 100);data[100-1]=L'\0';printWLine(data);}}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];wmemset(data, L'A', 100-1);data[100-1]=L'\0';delete [] data;}
static void main(){int count;count=-1;count=20;b_main_sink(&count);}void b_main_sink(void * void_count_ptr){int * count_ptr=(int *)void_count_ptr;int count=(*count_ptr);{size_t i=0;FILE *file=NULL;const char *filename="output_bad.txt";file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}
void main_sink(char * data);static void main(){char * data;{char * data_buf=new char[100];data=data_buf;}main_sink(data);}void main_sink(char * data){printLine(data);delete [] data;}
static void main_sink(){int data=main_data;{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}static void main(){int data;data=-1;data=20;main_data=data;main_sink();}
static int main_source(int data){data=7;return data;}static void main(){int data;data=-1;data=main_source(data);printIntLine(100 % data);}
static void main_sink(char data){{char result=data-1;printHexCharLine(result);}}static void main(){char data;void (*func_ptr) (char)=main_sink;data=' ';data=5;func_ptr(data);}
static void main(){{char data_buf[100]="";char * data=data_buf;printLine("Please enter a string: ");if (fgets(data, 100, stdin)==NULL){printLine("fgets failed!");exit(1);}printLine(data);}}
static void main(){wchar_t * data;struct_type my_struct;data=NULL;data=new wchar_t[100];wcscpy(data, L"A String");printWLine(data);my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){wchar_t * data=my_struct.a;delete[] data;}
static void main(){int data;data=7;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(&data);}static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, "%s", args);va_end(args);printLine(dest);}}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);main_vasink(data, data);}
static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));main_sink(data);}void main_sink(twoints * data){free(data);}
static void main(){int count;_union_type my_union;count=-1;fscanf (stdin, "%d", &count);my_union.a=count;{int count=my_union.b;{size_t i=0;FILE *file=NULL;const char *filename="output_good.txt";if (count > 0 && count <=20){file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;data=(char *)malloc(100*sizeof(char));data[0]='\0';strcpy(data, BAD_SRC_FIXED);my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{size_t i;for (i=0;i < strlen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}
void b_main_sink();static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{wchar_t dest[50]=L"";memmove(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);free(data);}}
void main_sink();static void main(){wchar_t * data;data=new wchar_t[100];_main_data=data;main_sink();}void main_sink(){wchar_t * data=_main_data;{wchar_t dest[50]=L"";wcscat(dest, data);printWLine(data);delete [] data;}}
void b_main_sink(void * void_data_ptr);static void main(){FILE * data;data=NULL;data=freopen("BadSource_freopen.txt","w+",stdin);b_main_sink(&data);}void b_main_sink(void * void_data_ptr){FILE * * data_ptr=(FILE * *)void_data_ptr;FILE * data=(*data_ptr);if (data!=NULL){fclose(data);}}
static void main(){int count;count=-1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);count=atoi(input_buf);}b_main_sink(&count);}void b_main_sink(int * count_ptr){int count=*count_ptr;{size_t i=0;if (count > 0 && count <=20){for (i=0;i < (size_t)count;i++){printLine("Hello");}}}}
static void main_sink(){struct _twoints * data=_main_data;free(data);}static void main(){struct _twoints * data;data=NULL;data=(struct _twoints *)malloc(100*sizeof(struct _twoints));data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);_main_data=data;main_sink();}
static void main_vasinkb(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, data, args);va_end(args);printLine(dest);}}static void main_vasinkg(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, "%s", args);va_end(args);printLine(dest);}}static void main(){char * data;char data_buf[100]="";data=data_buf;if(global_returns_t_or_f()){{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}}else{{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}}if(global_returns_t_or_f()){main_vasinkg(data, data);}else{main_vasinkg(data, data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;if(global_returns_t_or_f()){strcat(data, "*.*");}else{strcat(data, "*.*");}{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{wchar_t dest[50]=L"";wcsncpy(dest, data, wcslen(data));printWLine(data);}}
static void main(){int data;data=-1;data=b_main_source(data);{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}int b_main_source(int data){{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}return data;}
static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;strcat(data, "*.*");my_union.a=data;{char * data=my_union.b;_spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}fprintf(stdout, "%s\n", data);}
void b_main_sink(_struct_type my_struct);static void main(){short data;_struct_type my_struct;data=0;data=100-1;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){short data=my_struct.a;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static int main_source(int data){data=20;return data;}static void main(){int data;data=-1;data=main_source(data);{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;wcscat(data, L"*.*");}{wchar_t * data=*data_ptr2;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnvp(_P_WAIT, COMMAND_INT, args);}}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=NULL;{char * data=*data_ptr1;data=(char *)malloc((10+1)*sizeof(char));}{char * data=*data_ptr2;{char data_src[10+1]=SRC_STRING;memcpy(data, data_src, strlen(data_src)*sizeof(char));printLine(data);free(data);}}}
static void main(){if(global_returns_t_or_f()){{std_thread thread_a=NULL;std_thread thread_b=NULL;int val;val=0;if (!std_thread_lock_create(&g_good_lock)){return;}if (!std_thread_create(helper_good, (void*)&val, &thread_a)){thread_a=NULL;}if (!std_thread_create(helper_good, (void*)&val, &thread_b)){thread_b=NULL;}if (thread_a && std_thread_join(thread_a)) std_thread_destroy(thread_a);if (thread_b && std_thread_join(thread_b)) std_thread_destroy(thread_b);std_thread_lock_destroy(g_good_lock);printIntLine(val);}}else{{std_thread thread_a=NULL;std_thread thread_b=NULL;int val;val=0;if (!std_thread_lock_create(&g_good_lock)){return;}if (!std_thread_create(helper_good, (void*)&val, &thread_a)){thread_a=NULL;}if (!std_thread_create(helper_good, (void*)&val, &thread_b)){thread_b=NULL;}if (thread_a && std_thread_join(thread_a)) std_thread_destroy(thread_a);if (thread_b && std_thread_join(thread_b)) std_thread_destroy(thread_b);std_thread_lock_destroy(g_good_lock);printIntLine(val);}}}
static void main(){char * data;_union_type my_union;data=NULL;data=(char *)malloc(100*sizeof(char));my_union.a=data;{char * data=my_union.b;{size_t i, dest_sz;char dest[100];memset(dest, 'C', 100-1);dest_sz=strlen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);free(data);}}}
void b_main_sink(char * data);static void main(){char * data;data=(char *)malloc(100);b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){if (data!=NULL){strcpy(data, "Initialize");printLine(data);free(data);}}
static void main(){int data;data=-1;if(global_returns_t_or_f()){data=5;}else{data=5;}if(global_returns_t_or_f()){{int result=data * data;printIntLine(result);}}else{{int result=data * data;printIntLine(result);}}}
static void main(){twointsclass * data;data=NULL;main_source(data);delete data;}void main_source(twointsclass * &data){data=new twointsclass;}
static void main(){int data;data=-1;data=INT_MAX;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){{int result=-1;if (data <=(INT_MAX/2)){result=data * 2;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){char * data;data=NULL;data="Good";{char * data_copy=data;char * data=data_copy;printf("%s\n", data);}}
static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=20;}{int data=*data_ptr2;{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=b_main_source(data);{wchar_t data_src[10+1]=SRC_STRING;size_t i, src_len;src_len=wcslen(data_src);for (i=0;i < src_len;i++){data[i]=data_src[i];}printWLine(data);free(data);}}wchar_t * b_main_source(wchar_t * data){data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));return data;}
static void main(){int flag=0;if((flag+global_returns_t_or_f())==1){printLine("Sometimes prints");}printIntLine(flag);}
static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;data=NULL;{char data_goodbuf[100];data=data_goodbuf;strcpy(data, "A String");printLine(data);}func_ptr(data);}void b_main_sink(char * data){}
static void main(){char * data;data=NULL;data=new char[100];{char * data_copy=data;char * data=data_copy;{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}printLine(data);delete [] data;}}}
static void main(){unsigned int data;void (*func_ptr) (unsigned int)=b_main_sink;data=0;data=5;func_ptr(data);}void b_main_sink(unsigned int data){{unsigned int result=data+1;printUnsignedLine(result);}}
static void main(){int count;int count_array[5];count=-1;count=RAND32();count_array[2]=count;b_main_sink(count_array);}void b_main_sink(int count_array[]){int count=count_array[2];{size_t i=0;if (count > 0 && count <=20){for (i=0;i < (size_t)count;i++){printLine("Hello");}}}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]="";data=data_buf;{char * data=*data_ptr1;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}}{char * data=*data_ptr2;if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}}
static void main(){int * data;data=(int *)ALLOCA(10*sizeof(int));{int i;for(i=0;i<10;i++){data[i]=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}}
static void main(){int data;_union_type my_union;data=-1;data=7;my_union.a=data;{int data=my_union.b;printIntLine(100 % data);}}
static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");{wchar_t * data_copy=data;wchar_t * data=data_copy;main_vasink(data, data);}}
static twoints * main_source(twoints * data){data=new twoints;return data;}static void main(){twoints * data;data=NULL;data=main_source(data);delete data;}
static void main(){long long data;data=5L;printLongLongLine(data);}
static void main(){int data;if(global_returns_t_or_f()){fscanf (stdin, "%d", &data);}else{fscanf (stdin, "%d", &data);}if(global_returns_t_or_f()){{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0 && data < 10){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}else{{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0 && data < 10){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}}
static void main_sink(){char * data=_main_data;_spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_main_data=data;main_sink();}
static void main(){int data;data=7;_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{wchar_t data_buf[10]=L"AAAAAAAAA";if (data >=0){printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main_sink(){wchar_t * data=_main_data;if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}_main_data=data;main_sink();}
static void main(){{if (fputs("string", stdout)==EOF){printLine("fputs failed!");}}}
static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;strcat(data, "*.*");my_union.a=data;{char * data=my_union.b;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnvp(_P_WAIT, COMMAND_INT, args);}}}
static void main_sink(int data){{size_t i;int *b;b=(int*)malloc(data * sizeof(int));for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);free(b);}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=20;func_ptr(data);}
static void main(){char data;data=' ';data=CHAR_MIN;b_main_sink(data);}void b_main_sink(char data){{char result=0;if (data > CHAR_MIN){result=data-1;printHexCharLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static void main(){int data;_union_type my_union;data=-1;data=CHAR_MAX-5;my_union.a=data;{int data=my_union.b;{short s=(short)data;printf("%hd\n", s);}}}
static void main(){long long * data;data=NULL;if(global_returns_t_or_f()){data=new long long;}else{data=new long long;}if(global_returns_t_or_f()){printLongLongLine(*data);}else{printLongLongLine(*data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"15");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main(){int data;data=-1;data=CHAR_MAX-5;{int data_copy=data;int data=data_copy;{char c=(char)data;printHexCharLine(c);}}}
void main_sink(char * data){{char src[100];_snprintf(data, 100, "%s", src);printLine(data);delete [] data;}}static void main(){char * data;data=NULL;data=new char[100];main_sink(data);}
static void main(){long long * data;data=NULL;data=new long long;delete data;main_sink_b(data);}void main_sink_b(long long * data){main_sink_c(data);}void main_sink_c(long long * data){}
static void main_sink(unsigned int data){{unsigned int result=-1;if (data <=(unsigned int)sqrt((unsigned int)UINT_MAX)){result=data * data;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}static void main(){unsigned int data;data=0;data=(unsigned int)RAND32();main_sink(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, data, args);va_end(args);printLine(dest);}}void d_main_sink(char * data){main_vasink(data, data);}
static int * main_source(int * data){data=(int *)malloc(100*sizeof(int));return data;}static void main(){int * data;data=NULL;data=main_source(data);free(data);}
static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';if(global_returns_t_or_f()){data=data_buf;}else{data=data_buf;}{wchar_t dest[100];wcscpy(dest, data);printWLine(dest);}}
static char * main_source(char * data){{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}return data;}static void main(){char * data;data=NULL;data=main_source(data);{size_t i;char dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);}}
static void main(){wchar_t * data;data=NULL;data=main_source(data);}wchar_t * main_source(wchar_t * data){data=new wchar_t;delete data;return data;}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);_wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
static void main(){int data;_struct_type my_struct;data=-1;data=5;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{int result=data * 2;printIntLine(result);}}
void b_main_sink();static void main(){char * data;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{char src[100];memcpy(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}
static void main(){twoints * data;data=(twoints *)ALLOCA(10*sizeof(twoints));if(global_returns_t_or_f()){{int i;for(i=0;i<10;i++){data[i].a=i;data[i].b=i;}}}else{{int i;for(i=0;i<10;i++){data[i].a=i;data[i].b=i;}}}if(global_returns_t_or_f()){{int i;for(i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}}else{{int i;for(i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}}}
static void main(){char * data;data=(char *)malloc(100*sizeof(char));{char * data_copy=data;char * data=data_copy;{char dest[50]="";strcat(dest, data);printLine(data);free(data);}}}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");my_union.a=data;{wchar_t * data=my_union.b;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnv(_P_WAIT, COMMAND_INT_PATH, args);}}}
static void main(){{if (RENAME(OLD_GOOD_FILE_NAME, "newgoodfilename.txt")!=0){printLine("rename failed!");}}}
static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}{char dest[100];memcpy(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
void b_main_sink(short data);static void main(){short data;data=-1;data=CHAR_MAX-5;b_main_sink(data);}void b_main_sink(short data){{char c=(char)data;printHexCharLine(c);}}
static void main_sink(wchar_t * data){wprintf(L"%s\n", data);}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(wchar_t * data){if (wcsncmp(PASSWORD, data, wcslen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(int data);static void main(){int data;data=-1;data=100-1;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char dest[100];memcpy(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
static void main(){long long * data;union_type my_union;data=NULL;{long long data_goodbuf[100];data=data_goodbuf;data[0]=5L;printLongLongLine(data[0]);}my_union.a=data;{long long * data=my_union.b;}}
static int main_source(int data){data=10;return data;}static void main(){int data;data=main_source(data);{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0 && data < 10){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));b_main_sink(&data);}void b_main_sink(void * void_data_ptr){twoints * * data_ptr=(twoints * *)void_data_ptr;twoints * data=(*data_ptr);free(data);}
static void main_sink(){twoints * data=main_data;free(data);}static void main(){twoints * data;data=NULL;data=(twoints *)calloc(100, sizeof(twoints));main_data=data;main_sink();}
static int main_source(int data){{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}return data;}static void main(){int data;data=-1;data=main_source(data);{int result=-1;if (data <=(INT_MAX/2)){result=data * 2;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;data=(wchar_t *)realloc(data, 100);func_ptr(data);}void b_main_sink(wchar_t * data){if (data!=NULL){wcscpy(data, L"Initialize");printWLine(data);free(data);}}
char * b_main_source(char * data);static void main(){char * data;data=NULL;data=b_main_source(data);{char src[100];memmove(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}char * b_main_source(char * data){{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}return data;}
static twointsclass * main_source(twointsclass * data){data=(twointsclass *)malloc(100*sizeof(twointsclass));return data;}static void main(){twointsclass * data;data=NULL;data=main_source(data);free(data);}
static void main(){int * data;data=NULL;if(global_returns_t_or_f()){data=new int[100];}else{data=new int[100];}{memmove(data, src, 100*sizeof(int));printIntLine(data[0]);delete [] data;}}
void b_main_sink();static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
void _main_sink(wchar_t * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");_main_sink(data);}
static void main(){long long * data;long long data_badbuf[50];long long data_goodbuf[100];if(global_returns_t_or_f()){data=data_goodbuf;}else{data=data_goodbuf;}{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printLongLongLine(data[0]);}}}
static void main_sink(int * data){printIntLine(data[0]);delete [] data;}static void main(){int * data;void (*func_ptr) (int *)=main_sink;{int * data_buf=new int[100];{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}func_ptr(data);}
static void main(){int * data;data=(int *)malloc(10*sizeof(int));{int i;for(i=0;i<10;i++){data[i]=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}}
static void main(){char data;data='C';printHexCharLine(data);}
static void main(){int data;data=-1;data=7;{int data_copy=data;int data=data_copy;printIntLine(100/data);}}
void main_sink_b(wchar_t * data);static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}main_sink_b(data);}void main_sink_c(wchar_t * data);void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_d(wchar_t * data);void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_d(wchar_t * data){{wchar_t dest[100];wcscpy(dest, data);printWLine(dest);}}
static wchar_t * main_source(wchar_t * cryptokey){{size_t cryptokey_len=wcslen(cryptokey);if(100-cryptokey_len > 1){fgetws(cryptokey+cryptokey_len, (int)(100-cryptokey_len), stdin);cryptokey_len=wcslen(cryptokey);if (cryptokey_len > 0){cryptokey[cryptokey_len-1]=L'\0';}}}return cryptokey;}static void main(){wchar_t * cryptokey;wchar_t cryptokey_buf[100]=L"";cryptokey=cryptokey_buf;cryptokey=main_source(cryptokey);{HCRYPTPROV cryptoprov;HCRYPTKEY key;HCRYPTHASH hash;DWORD toBeEncryptedLen=wcslen(toBeEncrypted)*sizeof(wchar_t);if(!CryptAcquireContext(&cryptoprov, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, 0)){if(!CryptAcquireContext(&cryptoprov, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET)){printLine("Error in acquiring cryptographic context");exit(1);}}if(!CryptCreateHash(cryptoprov, CALG_SHA1, 0, 0, &hash)){printLine("Error in creating hash");exit(1);}if(!CryptHashData(hash, (BYTE *) cryptokey, wcslen(cryptokey)*sizeof(wchar_t), 0)){printLine("Error in hashing cryptokey");exit(1);}if(!CryptDeriveKey(cryptoprov, CALG_3DES, hash, 0, &key)){printLine("Error in CryptDeriveKey");exit(1);}if(!CryptEncrypt(key, (HCRYPTHASH)NULL, 1, 0, (BYTE *)toBeEncrypted, &toBeEncryptedLen, sizeof(toBeEncrypted))){printLine("Error in CryptEncryptData");exit(1);}printWLine(toBeEncrypted);}}
void main_sink_b(char * data);static void main(){char * data;data=NULL;data=new char[100];main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){{char dest[100];memset(dest, 'C', 100-1);memcpy(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);delete [] data;}}
static void main_sink(int data){{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=7;func_ptr(data);}
char * b_main_source(char * data);static void main(){char * data;data=NULL;data=b_main_source(data);{char data_src[10+1]=SRC_STRING;strncpy(data, data_src, strlen(data_src));printLine(data);free(data);}}char * b_main_source(char * data){data=(char *)malloc((10+1)*sizeof(char));return data;}
static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}void b_main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){double * data;data=new double[10];{int i;for(i=0;i<10;i++){data[i]=(double)i;}}{int i;for(i=0;i<10;i++){printDoubleLine(data[i]);}}delete [] data;}
static void main_sink(wchar_t * data){PUTENV(data);}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[250]=L"PATH=";data=data_buf;wcscat(data, NEW_PATH);func_ptr(data);}
static void main(){twointsclass * data;struct_type my_struct;data=NULL;data=new twointsclass[100];my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){twointsclass * data=my_struct.a;delete [] data;}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));{wchar_t dest[100];wmemset(dest, L'C', 100-1);memmove(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);free(data);}}
static void main(){int data;void (*func_ptr) (int)=b_main_sink;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}func_ptr(data);}void b_main_sink(int data){{char data_buf[10]="AAAAAAAAA";{printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));{wchar_t data_src[10+1]=SRC_STRING;size_t i, src_len;src_len=wcslen(data_src);for (i=0;i < src_len;i++){data[i]=data_src[i];}printWLine(data);free(data);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;func_ptr(data);}void b_main_sink(wchar_t * data){{wchar_t dest[100];wcscpy(dest, data);printWLine(dest);}}
void b_main_sink(FILE * data);static void main(){FILE * data;data=NULL;data=freopen("BadSource_freopen.txt","w+",stdin);b_main_sink(data);}void c_main_sink(FILE * data);void b_main_sink(FILE * data){c_main_sink(data);}void d_main_sink(FILE * data);void c_main_sink(FILE * data){d_main_sink(data);}void d_main_sink(FILE * data){if (data!=NULL){fclose(data);}}
static void main(){wchar_t * data;_union_type my_union;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));wcscpy(data, L"A String");printWLine(data);my_union.a=data;{wchar_t * data=my_union.b;free(data);}}
static void main(){char data;data=' ';fscanf (stdin, "%c", &data);b_main_sink(data);}void b_main_sink(char data){{char result=-1;if (data < CHAR_MAX){result=data+1;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main_sink(){wchar_t * data=main_data;{wchar_t dest[100];wcscpy(dest, data);printWLine(dest);}}static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}main_data=data;main_sink();}
static void main(){char * data;data=NULL;{char data_goodbuf[100];data=data_goodbuf;strcpy(data, "A String");printLine(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;{wchar_t src[100];wcscpy(data, src);printWLine(data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");fprintf(stdout, data);}
static void main(){if(global_returns_t_or_f()){{if (fputwc((wchar_t)L'A', stdout)==WEOF){printLine("fputwc failed!");}}}else{{if (fputwc((wchar_t)L'A', stdout)==WEOF){printLine("fputwc failed!");}}}}
static void main(){int data;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){int data;data=-1;fscanf (stdin, "%d", &data);b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{int result=-1;if (data < INT_MAX){result=data+1;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
void b_main_sink(void * void_data_ptr);static void main(){int data;data=-1;data=ASSERT_VALUE+1;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);assert(data > ASSERT_VALUE);}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;my_union.a=data;{wchar_t * data=my_union.b;if (wcsstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}}
static int * main_source(int * data){data=new int;return data;}static void main(){int * data;data=NULL;data=main_source(data);delete data;}
static void main(){int data;_union_type my_union;data=7;my_union.a=data;{int data=my_union.b;{wchar_t data_buf[10]=L"AAAAAAAAA";if (data >=0){printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{wchar_t dest[50]=L"";memcpy(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);}}
static void main(){twointsclass * data;struct_type my_struct;data=NULL;data=new twointsclass;my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){twointsclass * data=my_struct.a;delete data;}
static void main(){char * data;_union_type my_union;data=NULL;data=(char *)malloc(100*sizeof(char));my_union.a=data;{char * data=my_union.b;{char src[100];memmove(data, src, 100*sizeof(char));printLine(data);free(data);}}}
void b_main_sink();static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnvp(_P_WAIT, COMMAND_INT, args);}}
static char * main_source(char * data){strcpy(data, "C:\\Windows\\System32\\winsrv.dll");return data;}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);{HMODULE hModule;hModule=LoadLibraryA(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
static void main_source(char * &data){data=new char;delete data;}static void main(){char * data;data=NULL;main_source(data);}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"C:\\Windows\\System32\\winsrv.dll");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{HMODULE hModule;hModule=LoadLibraryW(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "15");{int i, n, v;if (sscanf(data, "%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main(){long long * data;data=NULL;data=new long long;main_sink_b(data);}void main_sink_b(long long * data){main_sink_c(data);}void main_sink_c(long long * data){main_sink_d(data);}void main_sink_d(long long * data){main_sink_e(data);}void main_sink_e(long long * data){delete data;}
static void main(){int * data;int * data_array[5];data=NULL;data=(int *)malloc(100*sizeof(int));data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int * data_array[]){int * data=data_array[2];free(data);}
static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;{wchar_t dest[100];memcpy(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));data[0].a=0;data[0].b=0;printStructLine(&data[0]);b_main_sink(data);}void b_main_sink(twoints * data){c_main_sink(data);}void c_main_sink(twoints * data){d_main_sink(data);}void d_main_sink(twoints * data){e_main_sink(data);}void e_main_sink(twoints * data){free(data);}
void _main_sink(char * data){{char src[100];memcpy(data, src, 100*sizeof(char));printLine(data);}}static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;_main_sink(data);}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;wcscpy(data, L"fixedstringtest");}{wchar_t * data=*data_ptr2;wprintf(data);}}
static void main(){int data;_union_type my_union;data=-1;data=100-1;my_union.a=data;{int data=my_union.b;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];data=NULL;data=(char *)malloc(100*sizeof(char));data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{char dest[100];memset(dest, 'C', 100-1);memmove(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);free(data);}}
static void main(){char * password;_union_type my_union;char password_buf[100]="";password=password_buf;{size_t password_len=0;fgets(password, 100, stdin);password_len=strlen(password);if (password_len > 0){password[password_len-1]='\0';}}my_union.a=password;{char * password=my_union.b;{HANDLE pHandle;char * username="User";char * domain="Domain";if (LogonUserA( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}}
static void main_sink(){wchar_t * data=main_data;{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]=L'\0';printWLine(data);}}static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}main_data=data;main_sink();}
int b_main_source(int data);static void main(){int data;data=-1;data=b_main_source(data);{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}int b_main_source(int data){data=100-1;return data;}
static void main(){twoints * data;_union_type my_union;data=NULL;data=(twoints *)malloc(sizeof(*data));data->a=1;data->b=2;my_union.a=data;{twoints * data=my_union.b;printStructLine(data);free(data);}}
static void main(){int * data;int * &data_ref=data;data=new int[10];{int i;for(i=0;i<10;i++){data[i]=i;}}{int * data=data_ref;{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}delete [] data;}}
void main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}data_array[2]=data;main_sink(data_array);}void main_sink(char * data_array[]){char * data=data_array[2];{char dest[100];memcpy(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"C:\\Windows\\System32\\winsrv.dll");my_union.a=data;{wchar_t * data=my_union.b;{HMODULE hModule;hModule=LoadLibraryW(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}}
void b_main_sink();static void main(){int data;data=-1;data=100-1;_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
void main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];data=NULL;data=new char[100];data_array[2]=data;main_sink(data_array);}void main_sink(char * data_array[]){char * data=data_array[2];{char src[100];strncat(data, src, 100);printLine(data);delete [] data;}}
static wchar_t * main_source(wchar_t * data){{wchar_t mystring[]=L"mystring";data=wcsdup(mystring);}return data;}static void main(){wchar_t * data;data=NULL;data=main_source(data);free(data);}
static void main(){twoints * data;data=NULL;{twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine(&data[0]);}b_main_sink(data);}void b_main_sink(twoints * data){}
static void main_sink(unsigned int data){{unsigned int result=-1;if (data <=(UINT_MAX/2)){result=data * 2;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}static void main(){unsigned int data;data=0;data=UINT_MAX;main_sink(data);}
static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));if(global_returns_t_or_f()){}else{}{wchar_t dest[50]=L"";wcscat(dest, data);printWLine(data);free(data);}}
static void main(){wchar_t * data;data=NULL;data=main_source(data);free(data);}wchar_t * main_source(wchar_t * data){data=(wchar_t *)calloc(100, sizeof(wchar_t));return data;}
static void main(){char data;data=' ';data=5;b_main_sink(data);}void b_main_sink(char data){c_main_sink(data);}void c_main_sink(char data){{char result=data-1;printHexCharLine(result);}}
void b_main_sink(_struct_type my_struct);static void main(){short data;_struct_type my_struct;data=0;data=100-1;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){short data=my_struct.a;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");{wchar_t * data_copy=data;wchar_t * data=data_copy;_wsystem(data);}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=NULL;{char * data=*data_ptr1;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}}{char * data=*data_ptr2;{char src[100];strcpy(data, src);printLine(data);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, L"%s", data);printWLine(dest);}}
static void main(){long long * data;long long * *data_ptr1=&data;long long * *data_ptr2=&data;long long data_badbuf[50];long long data_goodbuf[100];{long long * data=*data_ptr1;data=data_goodbuf;}{long long * data=*data_ptr2;{memcpy(data, src, 100*sizeof(long long));printLongLongLine(data[0]);}}}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main_sink(char * data){fprintf(stdout, "%s\n", data);}static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}main_sink(data);}
static void main_sink(char * data){{int i, n, v;if (sscanf(data, "%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}
static void main(){int data;data=-1;data=5;b_main_sink(data);}void b_main_sink(int data){{int result=data * 2;printIntLine(result);}}
static void main(){int data;data=-1;data=5;b_main_sink(data);}void b_main_sink(int data){{int result=data * data;printIntLine(result);}}
static void main(){int * data;_struct_type my_struct;data=NULL;{int data_goodbuf[100];data=data_goodbuf;data[0]=5;printIntLine(data[0]);}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int * data=my_struct.a;}
static void main(){char data;data=' ';fscanf (stdin, "%c", &data);b_main_sink(data);}void b_main_sink(char data){c_main_sink(data);}void c_main_sink(char data){d_main_sink(data);}void d_main_sink(char data){{char result=-1;if (data <=(char)sqrt((char)CHAR_MAX)){result=data * data;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){long long * data;data=NULL;data=(long long *)calloc(100, sizeof(long long));data[0]=5L;printLongLongLine(data[0]);b_main_sink(data);}void b_main_sink(long long * data){c_main_sink(data);}void c_main_sink(long long * data){free(data);}
static void main(){wchar_t * data;data=NULL;data=new wchar_t;delete data;main_sink_b(data);}void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_d(wchar_t * data){}
static void main_sink(wchar_t * data){{wchar_t dest[50]=L"";memmove(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100];data=data_buf;func_ptr(data);}
static void main(){int data;data=b_main_source(data);{wchar_t data_buf[10]=L"AAAAAAAAA";if (data >=0){printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}int b_main_source(int data){data=7;return data;}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=5;}{int data=*data_ptr2;{int result=data-1;printIntLine(result);}}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]="";data=data_buf;{char * data=*data_ptr1;strcat(data, "*.*");}{char * data=*data_ptr2;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnv(_P_WAIT, COMMAND_INT_PATH, args);}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;func_ptr(data);}void b_main_sink(wchar_t * data){{wchar_t src[100];_snwprintf(data, 100, L"%s", src);printWLine(data);}}
void b_main_sink(int data);static void main(){int data;data=-1;data=100-1;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
void b_main_sink(char * data);static void main(){char * data;data=(char *)malloc(100*sizeof(char));b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{char dest[50]="";memmove(dest, data, strlen(data)*sizeof(char));printLine(data);free(data);}}
static void main(){char * data;data=NULL;if(global_returns_t_or_f()){{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}}else{{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}}{char dest[100];strncpy(dest, data, strlen(dest));dest[100-1]='\0';printLine(dest);}}
static void main(){unsigned int data;data=0;data=UINT_MAX;b_main_sink(data);}void b_main_sink(unsigned int data){c_main_sink(data);}void c_main_sink(unsigned int data){{unsigned int result=-1;if (data <=(unsigned int)sqrt((unsigned int)UINT_MAX)){result=data * data;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){char * data;char * &data_ref=data;data=NULL;data=new char[100];{char * data=data_ref;delete [] data;}}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(int data){{int result=-1;if (data <=(INT_MAX/2)){result=data * 2;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){char * data;data=(char *)calloc(100, sizeof(char));if (data!=NULL){strcpy(data, "Initialize");printLine(data);free(data);}}
static void main(){int data;data=-1;data=20;_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{char * char_string;if (data > 0){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than 0");}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");b_main_sink(data);}void b_main_sink(char * data){{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(data);}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, L"%s", args);va_end(args);printWLine(dest);}}void b_main_sink(wchar_t * data){main_vasink(data, data);}
static void main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}func_ptr(data);}
static void main(){long long * data;data=NULL;data=new long long[100];main_sink_b(data);}void main_sink_b(long long * data){main_sink_c(data);}void main_sink_c(long long * data){delete [] data;}
static void main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;strcat(data, "*.*");func_ptr(data);}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]="";data=data_buf;{char * data=*data_ptr1;strcpy(data, "fixedstringtest");}{char * data=*data_ptr2;{char dest[100]="";SNPRINTF(dest, 100-1, data);printLine(dest);}}}
static char * main_source(char * data){strcpy(data, "fixedstringtest");return data;}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);printf(data);}
static void main_sink(wchar_t * data){{wchar_t dest[100];wmemset(dest, L'C', 100-1);memmove(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);free(data);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));func_ptr(data);}
static void main(){int * data;data=NULL;data=new int;main_sink_b(data);}void main_sink_b(int * data){main_sink_c(data);}void main_sink_c(int * data){delete data;}
static void main(){char * data;data=NULL;data=new char;main_sink_b(data);}void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){main_sink_d(data);}void main_sink_d(char * data){printf("%c\n", *data);}
static void main_sink(){char * data=_main_data;{char dest[50]="";_snprintf(dest, strlen(data), "%s", data);printLine(data);}}static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;_main_data=data;main_sink();}
static void main(){int data;data=b_main_source(data);{char data_buf[10]="AAAAAAAAA";{printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}int b_main_source(int data){data=RAND32();return data;}
static void main_sink(char * data){{char dest[100];memset(dest, 'C', 100-1);memmove(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);free(data);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;data=(char *)malloc(100*sizeof(char));func_ptr(data);}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));main_sink_b(data);}void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){free(data);}
static void main_sink(){int data=_main_data;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}static void main(){int data;data=-1;data=100-1;_main_data=data;main_sink();}
static void main(){int * data;data=(int *)malloc(10*sizeof(int));{int i;for(i=0;i<10;i++){data[i]=i;}}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * * data_ptr=(int * *)void_data_ptr;int * data=(*data_ptr);{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);fwprintf(stdout, data);}
static int main_source(int data){data=CHAR_MAX-5;return data;}static void main(){int data;data=-1;data=main_source(data);{char c=(char)data;printHexCharLine(c);}}
void b_main_sink(void * void_data_ptr);static void main(){short data;data=0;data=100-1;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){short * data_ptr=(short *)void_data_ptr;short data=(*data_ptr);{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
static void main(){char * data;data=NULL;data=new char;main_sink(&data);}void main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);delete data;}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char src[100];strcpy(data, src);printLine(data);}}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *, ...)=b_main_vasink;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");func_ptr(data);}void b_main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, data, args);va_end(args);}}
void b_main_sink(twoints * data);static void main(){twoints * data;twoints data_badbuf[50];twoints data_goodbuf[100];data=data_goodbuf;b_main_sink(data);}void c_main_sink(twoints * data);void b_main_sink(twoints * data){c_main_sink(data);}void c_main_sink(twoints * data){{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memmove(data, src, 100*sizeof(twoints));printStructLine(&data[0]);}}
static void main(){char * data;data=NULL;main_source(data);free(data);}void main_source(char * &data){data=(char *)malloc(100*sizeof(char));}
void b_main_sink(FILE * data);static void main(){FILE * data;data=NULL;data=fopen("BadSource_fopen.txt", "w+");b_main_sink(data);}void c_main_sink(FILE * data);void b_main_sink(FILE * data){c_main_sink(data);}void d_main_sink(FILE * data);void c_main_sink(FILE * data){d_main_sink(data);}void e_main_sink(FILE * data);void d_main_sink(FILE * data){e_main_sink(data);}void e_main_sink(FILE * data){if (data!=NULL){fclose(data);}}
static int main_source(int data){data=5;return data;}static void main(){int data;data=-1;data=main_source(data);{int result=data * 2;printIntLine(result);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{wchar_t dest[50]=L"";_snwprintf(dest, wcslen(data), L"%s", data);printWLine(data);}}
static int main_source(int data){data=7;return data;}static void main(){int data;data=main_source(data);{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");b_main_sink(data);}void b_main_sink(wchar_t * data){{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static char * main_source(char * data){data=new char[100];return data;}static void main(){char * data;data=NULL;data=main_source(data);{size_t i, dest_sz;char dest[100];memset(dest, 'C', 100-1);dest_sz=strlen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);delete [] data;}}
static void main(){char * data;struct_type my_struct;data=NULL;data=new char;delete data;my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){char * data=my_struct.a;}
static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}
static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;printf("%s\n", data);}
static void main(){if(global_returns_t_or_f()){{char data;char * pointer=(char *)ALLOCA(sizeof(char));data=5;{char data=*pointer;printHexCharLine(data);}}}else{{char data;char * pointer=(char *)ALLOCA(sizeof(char));data=5;{char data=*pointer;printHexCharLine(data);}}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}fwprintf(stdout, L"%s\n", data);}
static void main(){int * data;int data_uninit_array[10];data=data_uninit_array;{int i;for(i=0;i<10;i++){data[i]=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}}
static void main_sink(char * data){{char src[100];strcat(data, src);printLine(data);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;func_ptr(data);}
static void main(){if(global_returns_t_or_f()){UMASK(022);}else{UMASK(022);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, GOOD_OS_COMMAND);func_ptr(data);}void b_main_sink(wchar_t * data){{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}
int b_main_source(int data);static void main(){int data;data=-1;data=b_main_source(data);{size_t i;int *b;b=(int*)malloc(data * sizeof(int));for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);free(b);}}int b_main_source(int data){data=20;return data;}
static twointsclass * main_source(twointsclass * data){data=new twointsclass[100];return data;}static void main(){twointsclass * data;data=NULL;data=main_source(data);{twointsclass src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memmove(data, src, 100*sizeof(twointsclass));printIntLine(data[0].a);delete [] data;}}
static void main(){int data;_union_type my_union;data=7;my_union.a=data;{int data=my_union.b;{wchar_t data_buf[10]=L"AAAAAAAAA";if (data >=0){printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
static void main(){{char * reversedString=helper_good("GoodSink");printLine(reversedString);}}
static void main(){int data;int data_array[5];data=-1;data=RAND32();data_array[2]=data;main_sink(data_array);}void main_sink(int data_array[]){int data=data_array[2];{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}
void b_main_sink(int data);static void main(){int data;data=-1;data=CHAR_MAX-5;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){{char c=(char)data;printHexCharLine(c);}}
static void main_sink(int * data){{int data_src[10]={0};memcpy(data, data_src, 10*sizeof(int));printIntLine(data[0]);free(data);}}static void main(){int * data;void (*func_ptr) (int *)=main_sink;data=NULL;data=(int *)malloc(10*sizeof(int));func_ptr(data);}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;data=L"P";}{wchar_t * data=*data_ptr2;if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}}
static void main(){int data;_struct_type my_struct;data=-1;data=5;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{int result=data+1;printIntLine(result);}}
static void main_sink(int data){{char data_buf[10]="AAAAAAAAA";{printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}static void main(){int data;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}main_sink(data);}
static int main_source(int data){data=RAND32();return data;}static void main(){int data;data=-1;data=main_source(data);{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than the length of the source string or too large");}}}
void b_main_sink(long long * data);static void main(){long long * data;void (*func_ptr) (long long *)=b_main_sink;data=NULL;data=(long long *)malloc(100*sizeof(long long));func_ptr(data);}void b_main_sink(long long * data){{memcpy(data, src, 100*sizeof(long long));printLongLongLine(data[0]);free(data);}}
static void main(){twointsclass * data;union_type my_union;{twointsclass * data_buf=new twointsclass[100];{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}my_union.a=data;{twointsclass * data=my_union.b;printIntLine(data[0].a);delete [] data;}}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;func_ptr(data);}void b_main_sink(char * data){{char src[100];memcpy(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}
void b_main_sink(int * data);static void main(){int * data;data=NULL;data=(int *)malloc(10*sizeof(int));b_main_sink(data);}void c_main_sink(int * data);void b_main_sink(int * data){c_main_sink(data);}void d_main_sink(int * data);void c_main_sink(int * data){d_main_sink(data);}void d_main_sink(int * data){{int data_src[10]={0};memmove(data, data_src, 10*sizeof(int));printIntLine(data[0]);free(data);}}
static void main(){{char * key="TEST\\TestKey";HKEY hKey;if (RegCreateKeyExA( HKEY_CURRENT_USER, key, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, NULL)!=ERROR_SUCCESS){printLine("Registry key could not be created");}else{printLine("Registry key created successfully");}}}
static twoints * main_source(twoints * data){data=(twoints *)malloc(100*sizeof(twoints));return data;}static void main(){twoints * data;data=NULL;data=main_source(data);free(data);}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");my_union.a=data;{wchar_t * data=my_union.b;_wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}}
static char * main_source(char * data){data=(char *)malloc(100*sizeof(char));return data;}static void main(){char * data;data=NULL;data=main_source(data);{char src[100];strcat(data, src);printLine(data);free(data);}}
static char * main_source(char * data){data=new char[100];return data;}static void main(){char * data;data=NULL;data=main_source(data);{char src[100];memcpy(data, src, 100*sizeof(char));printLine(data);delete [] data;}}
void b_main_sink(int data);static void main(){int data;data=-1;data=7;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){printIntLine(100 % data);}
static void main(){wchar_t * data;wchar_t * data_array[5];data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data, L'A', 100-1);data[100-1]=L'\0';data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];printWLine(data);}
void main_source(char * &data);static void main(){char * data;data=NULL;main_source(data);{size_t i;char dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);}}void main_source(char * &data){{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}}
static void main(){unsigned char data;_struct_type my_struct;data=' ';data=UCHAR_MAX;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){unsigned char data=my_struct.a;{unsigned char result=-1;if (data <=(UCHAR_MAX/2)){result=data * 2;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
void b_main_sink(int data);static void main(){int data;data=-1;data=100-1;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void d_main_sink(int data);void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main(){{wchar_t data_buf[100]=L"";wchar_t * data=data_buf;if (swscanf(SRC, L"%99s\0", data)==EOF){printLine("swscanf failed!");}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "15");_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{int i, n, v;if (sscanf(data, "%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main(){unsigned int data;data=0;data=5;{unsigned int data_copy=data;unsigned int data=data_copy;{unsigned int result=data-1;printUnsignedLine(result);}}}
static void main(){int * data;data=NULL;data=new int[100];{size_t i;for(i=0;i < 100;i++){data[i]=5;}}delete [] data;main_sink_b(data);}void main_sink_b(int * data){main_sink_c(data);}void main_sink_c(int * data){main_sink_d(data);}void main_sink_d(int * data){}
static void main(){int data;data=-1;data=20;{int data_copy=data;int data=data_copy;{size_t a,i;int *b;b=(int*)new char[a];for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);delete [] b;}}}
void b_main_sink(int data);static void main(){int data;data=-1;data=ASSERT_VALUE+1;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){assert(data > ASSERT_VALUE);}
static void main(){unsigned int data;void (*func_ptr) (unsigned int)=b_main_sink;data=0;data=5;func_ptr(data);}void b_main_sink(unsigned int data){{unsigned int result=data * 2;printUnsignedLine(result);}}
static void main_sink(){int data=_main_data;{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}static void main(){int data;data=-1;data=20;_main_data=data;main_sink();}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}{int data_copy=data;int data=data_copy;{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}}
static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;if(global_returns_t_or_f()){strcat(data, "*.*");}else{strcat(data, "*.*");}{FILE *pipe;pipe=POPEN(data, "wb");if (pipe!=NULL) PCLOSE(pipe);}}
static void main(){long long * data;long long * data_array[5];data=NULL;data=new long long;delete data;data_array[2]=data;main_sink(data_array);}void main_sink(long long * data_array[]){long long * data=data_array[2];}
static void main_sink(char * data){{size_t i;for (i=0;i < strlen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=(char *)malloc(100*sizeof(char));data[0]='\0';{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}func_ptr(data);}
void main_sink(void * void_data_ptr);static void main(){twointsclass * data;{twointsclass * data_buf=new twointsclass[100];{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}main_sink(&data);}void main_sink(void * void_data_ptr){twointsclass * * data_ptr=(twointsclass * *)void_data_ptr;twointsclass * data=(*data_ptr);printIntLine(data[0].a);delete [] data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));{wchar_t * data=*data_ptr1;data=data_goodbuf;}{wchar_t * data=*data_ptr2;{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));printWLine(data);}}}
static void main(){long long * data;data=NULL;{long long data_goodbuf[100];data=data_goodbuf;data[0]=5L;printLongLongLine(data[0]);}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){long long * * data_ptr=(long long * *)void_data_ptr;long long * data=(*data_ptr);}
static void main(){int data;data=-1;data=b_main_source(data);{int result=-1;if (data <=(int)sqrt((int)INT_MAX)){result=data * data;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}int b_main_source(int data){{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}return data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));data=data_buf;}b_main_sink(data);}void b_main_sink(wchar_t * data){printWLine(data);free(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char dest[100]="";SNPRINTF(dest, 100-1, data);printLine(dest);}}
static void main_sink(){char * data=_main_data;printf("%s\n", data);}static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}_main_data=data;main_sink();}
static void main(){unsigned int data;unsigned int *data_ptr1=&data;unsigned int *data_ptr2=&data;data=0;{unsigned int data=*data_ptr1;data=5;}{unsigned int data=*data_ptr2;{unsigned int result=data-1;printUnsignedLine(result);}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char dest[100]="";SNPRINTF(dest, 100-1, data);printLine(dest);}}
static void main(){char * data;_union_type my_union;data=NULL;data=(char *)malloc(100*sizeof(char));my_union.a=data;{char * data=my_union.b;free(data);}}
static void main(){char * data;char * &data_ref=data;data=NULL;data=new char;{char * data=data_ref;printf("%c\n", *data);}}
static void main(){{if (fwrite((wchar_t *)L"string", sizeof(wchar_t), wcslen(L"string"), stdout)!=wcslen(L"string")){printLine("fwrite failed!");}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_t_or_f()){{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}}else{{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}}if(global_returns_t_or_f()){{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, L"%s", data);printWLine(dest);}}else{{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, L"%s", data);printWLine(dest);}}}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");func_ptr(data);}void b_main_sink(char * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;{size_t i, dest_sz;wchar_t dest[100];wmemset(dest, L'C', 100-1);dest_sz=wcslen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);}}
static void main(){twoints * data;{twoints * data_buf=(twoints *)malloc(100*sizeof(twoints));{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}{twoints * data_copy=data;twoints * data=data_copy;printStructLine(&data[0]);free(data);}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;wcscat(data, L"*.*");}{wchar_t * data=*data_ptr2;_wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){wchar_t * data;wchar_t * data_array[5];data=NULL;data=new wchar_t[100];data_array[2]=data;main_sink(data_array);}void main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];delete [] data;}
static void main_source(long long * &data){data=new long long[100];}static void main(){long long * data;data=NULL;main_source(data);{memmove(data, src, 100*sizeof(long long));printLongLongLine(data[0]);delete [] data;}}
static void main(){int data;int data_array[5];data=-1;data=5;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{int result=data * 2;printIntLine(result);}}
static void main(){wchar_t * data;data=NULL;if(global_returns_t_or_f()){data=new wchar_t;}else{data=new wchar_t;}if(global_returns_t_or_f()){delete data;}else{delete data;}}
void b_main_sink();static void main(){int data;data=-1;data=7;_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;printIntLine(100/data);}
void main_sink(void * void_data_ptr);static void main(){char * data;{char * data_buf=new char[100];data=data_buf;}main_sink(&data);}void main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);printLine(data);delete [] data;}
static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=-1;data=5;func_ptr(data);}void b_main_sink(int data){{int result=data+1;printIntLine(result);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));data[0]=L'\0';{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{size_t i;for (i=0;i < wcslen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}
static void main(){char * data;data=NULL;data=new char;main_sink_b(data);}void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){main_sink_d(data);}void main_sink_d(char * data){delete data;}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]="";data=data_buf;strcpy(data, "C:\\Windows\\System32\\winsrv.dll");func_ptr(data);}void b_main_sink(char * data){{HMODULE hModule;hModule=LoadLibraryA(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
static void main_sink(){wchar_t * data=_main_data;{wchar_t dest[100];wcscpy(dest, data);printWLine(dest);}}static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;_main_data=data;main_sink();}
static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];if (wcsncmp(PASSWORD, data, wcslen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){char * data;_union_type my_union;data=NULL;data=(char *)malloc(100*sizeof(char));strcpy(data, "A String");printLine(data);my_union.a=data;{char * data=my_union.b;free(data);}}
void b_main_sink(long long * data);static void main(){long long * data;data=NULL;data=(long long *)malloc(sizeof(*data));b_main_sink(data);}void b_main_sink(long long * data){printLongLongLine(*data);free(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){int data;_union_type my_union;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}my_union.a=data;{int data=my_union.b;{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}}
static void main_sink(int data){{char c=(char)data;printHexCharLine(c);}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=CHAR_MAX-5;func_ptr(data);}
void main_sink_b(wchar_t * data);static void main(){wchar_t * data;{wchar_t * data_buf=new wchar_t[100];data=data_buf;}main_sink_b(data);}void main_sink_c(wchar_t * data);void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_d(wchar_t * data);void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_e(wchar_t * data);void main_sink_d(wchar_t * data){main_sink_e(data);}void main_sink_e(wchar_t * data){printWLine(data);delete [] data;}
static void main(){char data;void (*func_ptr) (char)=b_main_sink;data=' ';data=(char)rand();func_ptr(data);}void b_main_sink(char data){{char result=-1;if (data <=(char)sqrt((char)CHAR_MAX)){result=data * data;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=(char *)malloc(100*sizeof(char));{char * data=*data_ptr1;}{char * data=*data_ptr2;{char dest[50]="";memmove(dest, data, strlen(data)*sizeof(char));printLine(data);free(data);}}}
char * b_main_source(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;data=b_main_source(data);{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}char * b_main_source(char * data){strcat(data, "file.txt");return data;}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf(data, args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");main_vasink(data, data);}
static void main(){wchar_t * data;data=NULL;data=NULL;data=(wchar_t *)realloc(data, 100*sizeof(wchar_t));wcscpy(data, L"A String");printWLine(data);b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);free(data);}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';{char * data=*data_ptr1;data=data_buf;}{char * data=*data_ptr2;{char dest[100];strcpy(dest, data);printLine(dest);}}}
void main_sink_b(twointsclass * data);static void main(){twointsclass * data;{twointsclass * data_buf=new twointsclass[100];{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}main_sink_b(data);}void main_sink_c(twointsclass * data);void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_c(twointsclass * data){printIntLine(data[0].a);delete [] data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main_sink(int * data){delete data;}static void main(){int * data;void (*func_ptr) (int *)=main_sink;data=NULL;data=new int;func_ptr(data);}
static void main(){char * data;char data_buf[100];data=data_buf;{char dest[50]="";_snprintf(dest, strlen(data), "%s", data);printLine(data);}}
void b_main_sink(int * data_array[]);static void main(){int * data;int * data_array[5];data=NULL;data=(int *)malloc(100*sizeof(int));data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int * data_array[]){int * data=data_array[2];{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printIntLine(data[0]);free(data);}}}
static void main(){{wchar_t data[100]=L"";WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();printWLine(data);}}
static void main(){unsigned char data;data=' ';data=b_main_source(data);{unsigned char result=data-1;printHexUnsignedCharLine(result);}}unsigned char b_main_source(unsigned char data){data=5;return data;}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100];data=data_buf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{size_t src_len;char src[100];src_len=strlen(src);strncat(data, src, src_len);printLine(data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);printf(data);}
static void main(){int data;data=-1;data=5;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){{int result=data * data;printIntLine(result);}}
static void main(){int * data;int * *data_ptr1=&data;int * *data_ptr2=&data;data=NULL;{int * data=*data_ptr1;data=new int;}{int * data=*data_ptr2;delete data;}}
static void main(){unsigned int data;_union_type my_union;data=0;data=UINT_MAX;my_union.a=data;{unsigned int data=my_union.b;{unsigned int result=-1;if (data < UINT_MAX){result=data+1;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
void b_main_sink(int data);static void main(){int data;data=-1;data=ASSERT_VALUE+1;b_main_sink(data);}void b_main_sink(int data){assert(data > ASSERT_VALUE);}
static void main(){char data;data=' ';fscanf (stdin, "%c", &data);b_main_sink(data);}void b_main_sink(char data){c_main_sink(data);}void c_main_sink(char data){{char result=-1;if (data <=(char)sqrt((char)CHAR_MAX)){result=data * data;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
void _main_sink(wchar_t * data){{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));printWLine(data);free(data);}}static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));_main_sink(data);}
static void main(){long long * data;data=NULL;data=new long long[100];data[0]=5L;printLongLongLine(data[0]);main_sink(data);}void main_sink(long long * data){delete[] data;}
static void main(){int * data;data=NULL;data=new int[100];main_sink(data);}void main_sink(int * data){delete [] data;}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100];data=data_buf;{wchar_t * data=*data_ptr1;}{wchar_t * data=*data_ptr2;{wchar_t dest[50]=L"";_snwprintf(dest, wcslen(data), L"%s", data);printWLine(data);}}}
static void main(){char data;_union_type my_union;data=' ';data=5;my_union.a=data;{char data=my_union.b;{char result=data * data;printHexCharLine(result);}}}
static void main(){twointsclass * data;twointsclass * *data_ptr1=&data;twointsclass * *data_ptr2=&data;data=NULL;{twointsclass * data=*data_ptr1;data=new twointsclass[100];data[0].a=0;data[0].b=0;printIntLine(data[0].a);printIntLine(data[0].b);}{twointsclass * data=*data_ptr2;delete[] data;}}
static void main(){long long * data;data=NULL;if(global_returns_t_or_f()){data=new long long;}else{data=new long long;}if(global_returns_t_or_f()){delete data;}else{delete data;}}
void b_main_sink();static void main(){int data;data=-1;data=7;_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;printIntLine(100 % data);}
static void main_sink(int * data){delete data;}static void main(){int * data;void (*func_ptr) (int *)=main_sink;data=NULL;data=new int;func_ptr(data);}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);_wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){int data;data=-1;fscanf (stdin, "%d", &data);b_main_sink(data);}void b_main_sink(int data){{int result=-1;if (data <=(INT_MAX/2)){result=data * 2;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){int * data;data=NULL;data=new int;main_sink(&data);}void main_sink(void * void_data_ptr){int * * data_ptr=(int * *)void_data_ptr;int * data=(*data_ptr);delete data;}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[FILENAME_MAX]="";data=data_buf;{char * data=*data_ptr1;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");}{char * data=*data_ptr2;{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}}
static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;{char dest[50]="";strncat(dest, data, strlen(data));printLine(data);}}
static void main(){{char data_buf[100]="";char * data=data_buf;strcpy(data, "abcdefghijklmnopqrstuvwxyz");memmove(data+6, data+4, 10*sizeof(char));printLine(data);}}
void b_main_sink(twoints * data);static void main(){twoints * data;{twoints * data_buf=(twoints *)malloc(100*sizeof(twoints));{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}b_main_sink(data);}void c_main_sink(twoints * data);void b_main_sink(twoints * data){c_main_sink(data);}void d_main_sink(twoints * data);void c_main_sink(twoints * data){d_main_sink(data);}void e_main_sink(twoints * data);void d_main_sink(twoints * data){e_main_sink(data);}void e_main_sink(twoints * data){printStructLine(&data[0]);free(data);}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");{wchar_t * data_copy=data;wchar_t * data=data_copy;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}}
void b_main_sink(char * data);static void main(){char * data;data=NULL;data=(char *)malloc((10+1)*sizeof(char));b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{char data_src[10+1]=SRC_STRING;size_t i, src_len;src_len=strlen(data_src);for (i=0;i < src_len;i++){data[i]=data_src[i];}printLine(data);free(data);}}
void main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];data=NULL;data=new char[100];data_array[2]=data;main_sink(data_array);}void main_sink(char * data_array[]){char * data=data_array[2];{char src[100];strcpy(data, src);printLine(data);delete [] data;}}
static wchar_t * main_source(wchar_t * data){wcscat(data, L"*.*");return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{wchar_t data_src[10+1]=SRC_STRING;memcpy(data, data_src, wcslen(data_src)*sizeof(wchar_t));printWLine(data);free(data);}}
void main_sink(struct_type my_struct);static void main(){twointsclass * data;struct_type my_struct;{twointsclass * data_buf=new twointsclass[100];{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){twointsclass * data=my_struct.a;printIntLine(data[0].a);delete [] data;}
static void main(){double * data;b_main_sink(&data);}void b_main_sink(double * * data_ptr){double * data=*data_ptr;data=(double *)malloc(sizeof(double));printDoubleLine(*data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t dest[50]=L"";wcscpy(dest, data);printWLine(data);free(data);}}
static void main(){char * data;_union_type my_union;char data_buf[250]="PATH=";data=data_buf;strcat(data, NEW_PATH);my_union.a=data;{char * data=my_union.b;PUTENV(data);}}
static void main_sink(int * data){delete data;}static void main(){int * data;void (*func_ptr) (int *)=main_sink;data=NULL;data=new int;func_ptr(data);}
static void main_sink(){char * data=_main_data;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnv(_P_WAIT, COMMAND_INT_PATH, args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_main_data=data;main_sink();}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{wchar_t src[100];wcsncpy(data, src, 100);data[100-1]=L'\0';printWLine(data);}}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{wchar_t src[100];wcscat(data, src);printWLine(data);free(data);}}
static twoints * main_source(twoints * data){data=new twoints[100];return data;}static void main(){twoints * data;data=NULL;data=main_source(data);delete [] data;}
static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;if(global_returns_t_or_f()){}else{}{wchar_t dest[50]=L"";size_t i, data_len;data_len=wcslen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printWLine(data);}}
static void main(){void * data;void (*func_ptr) (void *)=b_main_sink;data=NULL;data=CHAR_STRING;func_ptr(data);}void b_main_sink(void * data){{size_t data_len=strlen((char *)data);void * data_dest=(void *)calloc(data_len+1, 1);memcpy(data_dest, data, (data_len+1));printLine((char *)data_dest);free(data_dest);}}
void _main_sink(char * data){{char dest[50]="";memmove(dest, data, strlen(data)*sizeof(char));printLine(data);}}static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;_main_sink(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;if (strstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
static char * main_source(char * data){strcat(data, "*.*");return data;}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);_spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){int * data;int * *data_ptr1=&data;int * *data_ptr2=&data;data=NULL;{int * data=*data_ptr1;data=new int[100];{size_t i;for(i=0;i < 100;i++){data[i]=5;}}delete [] data;}{int * data=*data_ptr2;}}
static void main(){char * data;data=NULL;data=new char;main_sink_b(data);}void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){main_sink_d(data);}void main_sink_d(char * data){delete data;}
void b_main_sink(int data);static void main(){int data;data=-1;data=7;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){printIntLine(100/data);}
static void main(){int data;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t;delete data;main_sink_b(data);}void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_d(wchar_t * data){main_sink_e(data);}void main_sink_e(wchar_t * data){}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{size_t i;wchar_t dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{wchar_t data_src[10+1]=SRC_STRING;memmove(data, data_src, wcslen(data_src)*sizeof(wchar_t));printWLine(data);free(data);}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char dest[100];memset(dest, 'C', 100-1);memmove(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnvp(_P_WAIT, COMMAND_INT, args);}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;{char * data=*data_ptr1;strcat(data, "file.txt");}{char * data=*data_ptr2;{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}}
static void main(){{char data_buf[100]="";char * data=data_buf;if (_snprintf(data,100-strlen(SRC)-1, "%s\n", SRC) < 0){printLine("snprintf failed!");}}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char dest[100];strncpy(dest, data, strlen(dest));dest[100-1]='\0';printLine(dest);}}
static void main_sink(){wchar_t * data=_main_data;{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");_main_data=data;main_sink();}
void b_main_sink(_struct_type my_struct);static void main(){FILE * data;_struct_type my_struct;data=NULL;data=freopen("BadSource_freopen.txt","w+",stdin);my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){FILE * data=my_struct.a;if (data!=NULL){fclose(data);}}
static void main(){if(global_returns_t_or_f()){{if (putchar((int)'A')==EOF){printLine("putchar failed!");}}}else{{if (putchar((int)'A')==EOF){printLine("putchar failed!");}}}}
static void main(){char * data;_union_type my_union;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;my_union.a=data;{char * data=my_union.b;{char src[100];_snprintf(data, 100, "%s", src);printLine(data);}}}
static void main(){twointsclass * data;twointsclass * &data_ref=data;data=NULL;data=new twointsclass;data->a=0;data->b=0;printIntLine(data->a);printIntLine(data->b);{twointsclass * data=data_ref;delete data;}}
void _main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnv(_P_WAIT, COMMAND_INT_PATH, args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_sink(data);}
static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, "%s", args);va_end(args);printLine(dest);}}static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]="";data=data_buf;{char * data=*data_ptr1;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}}{char * data=*data_ptr2;main_vasink(data, data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");fprintf(stdout, data);}
static void main(){twoints * data;twoints * *data_ptr1=&data;twoints * *data_ptr2=&data;data=NULL;{twoints * data=*data_ptr1;{twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine(&data[0]);}}{twoints * data=*data_ptr2;}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];delete [] data;}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(_struct_type my_struct);static void main(){int data;_struct_type my_struct;data=-1;data=100-1;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"15");func_ptr(data);}void b_main_sink(wchar_t * data){{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main(){int data;data=-1;data=5;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{int result=data-1;printIntLine(result);}}
static void main_sink(wchar_t * data){{wchar_t dest[50]=L"";memmove(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;func_ptr(data);}
static void main(){int * data;data=NULL;data=new int;printIntLine(*data);delete data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");b_main_sink(data);}void b_main_sink(wchar_t * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){unsigned int data;data=0;data=UINT_MAX;b_main_sink(data);}void b_main_sink(unsigned int data){c_main_sink(data);}void c_main_sink(unsigned int data){d_main_sink(data);}void d_main_sink(unsigned int data){e_main_sink(data);}void e_main_sink(unsigned int data){{unsigned int result=-1;if (data <=(UINT_MAX/2)){result=data * 2;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
void b_main_sink(long long * data);static void main(){long long * data;{long long * data_buf=(long long *)malloc(100*sizeof(long long));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5L;}}data=data_buf;}b_main_sink(data);}void c_main_sink(long long * data);void b_main_sink(long long * data){c_main_sink(data);}void d_main_sink(long long * data);void c_main_sink(long long * data){d_main_sink(data);}void e_main_sink(long long * data);void d_main_sink(long long * data){e_main_sink(data);}void e_main_sink(long long * data){printLongLongLine(data[0]);free(data);}
static void main_sink(wchar_t * data){{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");func_ptr(data);}
static void main(){unsigned char data;data=' ';data=(unsigned char)rand();b_main_sink(&data);}void b_main_sink(unsigned char * data_ptr){unsigned char data=*data_ptr;{unsigned char result=-1;if (data <=(unsigned char)sqrt((unsigned char)UCHAR_MAX)){result=data * data;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){int data;data=-1;data=100-1;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
static void main_sink(int count){{size_t i=0;if (count > 0 && count <=20){for (i=0;i < (size_t)count;i++){printLine("Hello");}}}}static void main(){int count;count=-1;fscanf (stdin, "%d", &count);main_sink(count);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
static void main(){char * data;data=NULL;{char data_goodbuf[100];data=data_goodbuf;strcpy(data, "A String");printLine(data);}_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;}
static void main(){int data;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}{int data_copy=data;int data=data_copy;{char data_buf[10]="AAAAAAAAA";{printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}}
static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;wcscpy(data, L"fixedstringtest");}{wchar_t * data=*data_ptr2;main_vasink(data, data);}}
void b_main_sink();static void main(){long long * data;data=NULL;{long long tmp=5L;data=&tmp;}_main_data=data;b_main_sink();}void b_main_sink(){long long * data=_main_data;printLongLongLine(*data);}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");my_union.a=data;{wchar_t * data=my_union.b;{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}}
static void main_sink(){int data=_main_data;{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}static void main(){int data;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}_main_data=data;main_sink();}
static void main(){wchar_t * data;struct_type my_struct;data=NULL;data=new wchar_t;my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){wchar_t * data=my_struct.a;printWcharLine(*data);}
static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}free(data);b_main_sink(data);}void b_main_sink(twoints * data){c_main_sink(data);}void c_main_sink(twoints * data){d_main_sink(data);}void d_main_sink(twoints * data){}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;func_ptr(data);}void b_main_sink(char * data){{char src[100];memcpy(data, src, 100*sizeof(char));printLine(data);}}
static void main(){long long * data;long long data_badbuf[50];long long data_goodbuf[100];if(global_returns_t_or_f()){data=data_goodbuf;}else{data=data_goodbuf;}{memmove(data, src, 100*sizeof(long long));printLongLongLine(data[0]);}}
static void main(){int data;data=10;{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){{wchar_t * pipeName=L"\\\\.\\pipe\\mypipe";HANDLE hPipe=INVALID_HANDLE_VALUE;BOOL fConnected=FALSE;hPipe=CreateNamedPipeW( pipeName, PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, BUFSIZE, BUFSIZE, NMPWAIT_USE_DEFAULT_WAIT, NULL);if (hPipe==INVALID_HANDLE_VALUE){exit(1);}if (GetLastError()==ERROR_ACCESS_DENIED){exit(1);}fConnected=ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError()==ERROR_PIPE_CONNECTED);CloseHandle(hPipe);}}
static int * main_source(int * data){data=new int;return data;}static void main(){int * data;data=NULL;data=main_source(data);delete data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{size_t i;wchar_t dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);}}
static void main(){twoints * data;union_type my_union;data=NULL;data=new twoints[100];{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}delete [] data;my_union.a=data;{twoints * data=my_union.b;}}
static void main(){char * data;data=NULL;data=new char;main_sink_b(data);}void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){main_sink_d(data);}void main_sink_d(char * data){delete data;}
void main_sink(struct_type my_struct);static void main(){wchar_t * data;struct_type my_struct;data=NULL;data=new wchar_t[100];my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){wchar_t * data=my_struct.a;{wchar_t src[100];_snwprintf(data, 100, L"%s", src);printWLine(data);delete [] data;}}
void main_sink_b(twointsclass * data);static void main(){twointsclass * data;data=NULL;{twointsclass * tmp=new twointsclass;tmp->a=0;tmp->b=0;data=tmp;}main_sink_b(data);}void main_sink_c(twointsclass * data);void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_d(twointsclass * data);void main_sink_c(twointsclass * data){main_sink_d(data);}void main_sink_d(twointsclass * data){printIntLine(data[0].a);}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);if (strncmp(PASSWORD, data, strlen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}char * b_main_source(char * data){data=PASSWORD;return data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");b_main_sink(data);}void b_main_sink(wchar_t * data){{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}
void main_sink(struct_type my_struct);static void main(){int data;struct_type my_struct;data=-1;data=20;my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){int data=my_struct.a;{size_t a,i;int *b;b=(int*)new char[a];for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);delete [] b;}}
static void main(){int * data;struct_type my_struct;data=NULL;int data_good;data=&data_good;printIntLine(*data);my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){int * data=my_struct.a;}
static void main(){float data;_union_type my_union;data=0.0F;data=7.0F;my_union.a=data;{float data=my_union.b;printDoubleLine((double)(100.0/data));}}
static void main(){char * data;data=(char *)malloc(100);if (data!=NULL){strcpy(data, "Initialize");printLine(data);free(data);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}printWLine(data);free(data);}}
static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}data_array[2]=data;b_main_sink(data_array);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(L"%s", args);va_end(args);}}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];main_vasink(data, data);}
static void main_sink(char * data){{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");func_ptr(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}_main_data=data;b_main_sink();}static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, "%s", args);va_end(args);printLine(dest);}}void b_main_sink(){char * data=_main_data;main_vasink(data, data);}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;my_union.a=data;{wchar_t * data=my_union.b;{wchar_t dest[100];wcscpy(dest, data);printWLine(dest);}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
static void main(){char * data;char * &data_ref=data;data=NULL;data=new char[100];{char * data=data_ref;delete [] data;}}
void main_sink();static void main(){char * data;data=NULL;data=new char[100];_main_data=data;main_sink();}void main_sink(){char * data=_main_data;{char src[100];memcpy(data, src, 100*sizeof(char));printLine(data);delete [] data;}}
static wchar_t * main_source(wchar_t * data){wcscpy(data, L"fixedstringtest");return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, data);printWLine(dest);}}
void b_main_sink(int data);static void main(){int data;data=-1;data=CHAR_MAX-5;b_main_sink(data);}void b_main_sink(int data){{short s=(short)data;printf("%hd\n", s);}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;data=new wchar_t[100];{wchar_t * data=*data_ptr1;}{wchar_t * data=*data_ptr2;{wchar_t dest[50]=L"";memmove(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);delete [] data;}}}
static void main(){int data;int data_array[5];data=-1;data=5;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{int result=data * 2;printIntLine(result);}}
static void main(){char data;_struct_type my_struct;data=' ';data=(char)rand();my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char data=my_struct.a;{char result=0;if (data > CHAR_MIN){result=data-1;printHexCharLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
void main_sink_b(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_sink_b(data);}void main_sink_c(wchar_t * data);void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_d(wchar_t * data);void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_d(wchar_t * data){{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));printWLine(data);delete [] data;}}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=b_main_source(data);{wchar_t src[100];wcsncpy(data, src, 100);printWLine(data);free(data);}}wchar_t * b_main_source(wchar_t * data){data=(wchar_t *)malloc(100*sizeof(wchar_t));return data;}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");my_union.a=data;{wchar_t * data=my_union.b;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;_wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static char * main_source(char * data){{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}return data;}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf("%s", args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);main_vasink(data, data);}
static void main(){struct _twoints * data;struct _twoints * data_array[5];data=NULL;data=(struct _twoints *)malloc(100*sizeof(struct _twoints));data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);data_array[2]=data;b_main_sink(data_array);}void b_main_sink(struct _twoints * data_array[]){struct _twoints * data=data_array[2];free(data);}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;_spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{wchar_t dest[50]=L"";_snwprintf(dest, wcslen(data), L"%s", data);printWLine(data);}}
static void main(){int data;data=-1;if(global_returns_t_or_f()){data=7;}else{data=7;}printIntLine(100 % data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){long long * data;data=NULL;data=new long long;{long long * data_copy=data;long long * data=data_copy;delete data;}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");_main_data=data;b_main_sink();}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}void b_main_sink(){wchar_t * data=_main_data;main_vasink(data, data);}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=20;}{int data=*data_ptr2;{char * char_string;if (data > 0){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than 0");}}}}
static void main(){char data;_union_type my_union;data=' ';data=5;my_union.a=data;{char data=my_union.b;{char result=data+1;printHexCharLine(result);}}}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
static void main(){double * data;data=new double[10];if(global_returns_t_or_f()){{int i;for(i=0;i<(10/2);i++){data[i]=(double)i;}}}else{{int i;for(i=0;i<(10/2);i++){data[i]=(double)i;}}}if(global_returns_t_or_f()){{int i;for(i=0;i<10;i++){data[i]=(double)i;}}{int i;for(i=0;i<10;i++){printDoubleLine(data[i]);}}delete [] data;}else{{int i;for(i=0;i<10;i++){data[i]=(double)i;}}{int i;for(i=0;i<10;i++){printDoubleLine(data[i]);}}delete [] data;}}
static void main(){twointsclass * data;data=NULL;if(global_returns_t_or_f()){data=new twointsclass;}else{data=new twointsclass;}if(global_returns_t_or_f()){delete data;}else{delete data;}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=5;}{int data=*data_ptr2;{int result=data * data;printIntLine(result);}}}
static void main_sink(unsigned int data){{unsigned int result=-1;if (data < UINT_MAX){result=data+1;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}static void main(){unsigned int data;data=0;data=(unsigned int)RAND32();main_sink(data);}
static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;strcpy(data, "15");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{int i, n, v;if (sscanf(data, "%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main(){int data;data=-1;data=RAND32();main_sink_b(data);}void main_sink_b(int data){main_sink_c(data);}void main_sink_c(int data){main_sink_d(data);}void main_sink_d(int data){{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main_sink(){char * data=main_data;printLine(data);delete [] data;}static void main(){char * data;{char * data_buf=new char[100];data=data_buf;}main_data=data;main_sink();}
static void main(){char * data;data="string";printLine(data);}
static void main(){int count;count=-1;count=20;{int count_copy=count;int count=count_copy;{size_t i=0;FILE *file=NULL;const char *filename="output_bad.txt";file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}}
void main_sink_b(char * data);static void main(){char * data;data=new char[100];main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_d(char * data);void main_sink_c(char * data){main_sink_d(data);}void main_sink_d(char * data){{char dest[50]="";memmove(dest, data, strlen(data)*sizeof(char));printLine(data);delete [] data;}}
static wchar_t * main_source(wchar_t * data){data=new wchar_t[100];return data;}static void main(){wchar_t * data;data=NULL;data=main_source(data);delete [] data;}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{char src[100];strncpy(data, src, 100);data[100-1]='\0';printLine(data);}}
static void main(){struct _twoints * data;data=NULL;{struct _twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);}b_main_sink(data);}void b_main_sink(struct _twoints * data){c_main_sink(data);}void c_main_sink(struct _twoints * data){d_main_sink(data);}void d_main_sink(struct _twoints * data){e_main_sink(data);}void e_main_sink(struct _twoints * data){}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=(char *)malloc(100*sizeof(char));data[0]='\0';{char * data=*data_ptr1;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}}{char * data=*data_ptr2;{size_t i;for (i=0;i < strlen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}}
static wchar_t * main_source(wchar_t * data){wcscpy(data, L"fixedstringtest");return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, data);printWLine(dest);}}
static void main(){long long * data;data=NULL;data=main_source(data);free(data);}long long * main_source(long long * data){data=(long long *)calloc(100, sizeof(long long));return data;}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=NULL;{char * data=*data_ptr1;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}}{char * data=*data_ptr2;{char dest[100];strncpy(dest, data, strlen(dest));dest[100-1]='\0';printLine(dest);}}}
void main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];data=NULL;data=new wchar_t[100];data_array[2]=data;main_sink(data_array);}void main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));printWLine(data);delete [] data;}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;wcscat(data, L"*.*");}{wchar_t * data=*data_ptr2;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}}
static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){int data;data=-1;data=100-1;{int data_copy=data;int data=data_copy;{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}}
static long long * main_source(long long * data){data=new long long[100];return data;}static void main(){long long * data;data=NULL;data=main_source(data);delete [] data;}
void b_main_sink(long long * data);static void main(){long long * data;void (*func_ptr) (long long *)=b_main_sink;data=(long long *)calloc(100, sizeof(long long));func_ptr(data);}void b_main_sink(long long * data){if (data!=NULL){data[0]=5L;printLongLongLine(data[0]);free(data);}}
static void main(){int count;int count_array[5];count=-1;count=20;count_array[2]=count;b_main_sink(count_array);}void b_main_sink(int count_array[]){int count=count_array[2];{size_t i=0;for (i=0;i < (size_t)count;i++){printLine("Hello");}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);if (strncmp(PASSWORD, data, strlen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}char * b_main_source(char * data){data=PASSWORD;return data;}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");b_main_sink(data);}void b_main_sink(char * data){{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
static void main(){twoints * data;data=NULL;data=new twoints;{twoints * data_copy=data;twoints * data=data_copy;delete data;}}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than the length of the source string or too large");}}}
static void main_sink(twointsclass * data){delete data;}static void main(){twointsclass * data;data=NULL;data=new twointsclass;main_sink(data);}
void main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_sink(data);}void main_sink(wchar_t * data){{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));printWLine(data);delete [] data;}}
static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]='\0';printLine(data);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}func_ptr(data);}void b_main_sink(wchar_t * data){{wchar_t dest[100];wcsncpy(dest, data, wcslen(dest));dest[100-1]=L'\0';printWLine(dest);}}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{FILE *pipe;pipe=POPEN(data, "wb");if (pipe!=NULL) PCLOSE(pipe);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}wchar_t * b_main_source(wchar_t * data){data=L"P";return data;}
static void main(){int data;data=-1;data=100-1;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
void b_main_sink(_struct_type my_struct);static void main(){short data;_struct_type my_struct;data=-1;data=CHAR_MAX-5;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){short data=my_struct.a;{char c=(char)data;printHexCharLine(c);}}
void b_main_sink(int data_array[]);static void main(){int data;int data_array[5];data=-1;data=100-1;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(L"%s", args);va_end(args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}main_vasink(data, data);}
static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));main_sink(data);}void main_sink(long long * data){free(data);}
static void main(){wchar_t * data;struct_type my_struct;data=NULL;data=new wchar_t[100];my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){wchar_t * data=my_struct.a;delete [] data;}
void main_sink_b(wchar_t * data);static void main(){wchar_t * data;data=new wchar_t[100];main_sink_b(data);}void main_sink_c(wchar_t * data);void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_d(wchar_t * data);void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_e(wchar_t * data);void main_sink_d(wchar_t * data){main_sink_e(data);}void main_sink_e(wchar_t * data){{wchar_t dest[50]=L"";wcsncat(dest, data, wcslen(data));printWLine(data);delete [] data;}}
static void main(){wchar_t * data;_struct_type my_struct;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));free(data);my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;}
void main_sink(wchar_t * data);static void main(){wchar_t * data;data=new wchar_t[100];main_sink(data);}void main_sink(wchar_t * data){{wchar_t dest[50]=L"";size_t i, data_len;data_len=wcslen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printWLine(data);delete [] data;}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;data=NULL;{wchar_t * data=*data_ptr1;data=new wchar_t[100];wmemset(data, L'A', 100-1);data[100-1]=L'\0';}{wchar_t * data=*data_ptr2;printWLine(data);}}
static void main(){double * data;data=(double *)ALLOCA(10*sizeof(double));{int i;for(i=0;i<10;i++){data[i]=(double)i;}}{int i;for(i=0;i<10;i++){printDoubleLine(data[i]);}}}
static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t dest[50]=L"";memmove(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);}}}
static void main(){if(global_returns_t_or_f()){{unsigned u;int i;u=rand();if (rand() % 2==0){u=UINT_MAX-u;}if (u > INT_MAX) exit(1);i=u;printIntLine(i);}}else{{unsigned u;int i;u=rand();if (rand() % 2==0){u=UINT_MAX-u;}if (u > INT_MAX) exit(1);i=u;printIntLine(i);}}}
static void main(){int * data;data=NULL;if(global_returns_t_or_f()){data=(int *)malloc(100*sizeof(int));{size_t i;for(i=0;i < 100;i++){data[i]=5;}}}else{data=(int *)malloc(100*sizeof(int));{size_t i;for(i=0;i < 100;i++){data[i]=5;}}}if(global_returns_t_or_f()){printIntLine(data[0]);}else{printIntLine(data[0]);}}
static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;{size_t i, dest_sz;wchar_t dest[100];wmemset(dest, L'C', 100-1);dest_sz=wcslen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);}}
static void main(){twoints * data;data=NULL;data=new twoints;delete data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{wchar_t dest[50]=L"";wcscat(dest, data);printWLine(data);}}
static void main(){long long * data;void (*func_ptr) (long long *)=b_main_sink;data=NULL;data=(long long *)malloc(100*sizeof(long long));{size_t i;for(i=0;i < 100;i++){data[i]=5L;}}func_ptr(data);}void b_main_sink(long long * data){printLongLongLine(data[0]);}
char * b_main_source(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);{HMODULE hModule;hModule=LoadLibraryA(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}char * b_main_source(char * data){strcpy(data, "C:\\Windows\\System32\\winsrv.dll");return data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;if (strncmp(PASSWORD, data, strlen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){wchar_t * data;data=NULL;{wchar_t mystring[]=L"mystring";data=wcsdup(mystring);printWLine(data);}b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;free(data);}
static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;{wchar_t dest[100];wmemset(dest, L'C', 100-1);memmove(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;data=NULL;{wchar_t * data=*data_ptr1;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}}{wchar_t * data=*data_ptr2;{wchar_t src[100];wcsncpy(data, src, 100);data[100-1]=L'\0';printWLine(data);}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{char dest[100]="";SNPRINTF(dest, 100-1, "%s", data);printLine(dest);}}
static void main(){twoints * data;data=(twoints *)calloc(100, sizeof(twoints));if(global_returns_t_or_f()){if (data!=NULL){data[0].a=1;data[0].b=1;printStructLine(&data[0]);free(data);}}else{if (data!=NULL){data[0].a=1;data[0].b=1;printStructLine(&data[0]);free(data);}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{char dest[100];strncpy(dest, data, strlen(dest));dest[100-1]='\0';printLine(dest);}}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{char src[100];memcpy(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}
static char * main_source(char * data){data="P";return data;}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main_sink(char * data){if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;main_sink(data);}
static void main(){twointsclass * data;data=NULL;data=(twointsclass *)malloc(100*sizeof(twointsclass));{twointsclass * data_copy=data;twointsclass * data=data_copy;free(data);}}
static void main(){int data;data=RAND32();b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);{char data_buf[10]="AAAAAAAAA";{printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;_wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){_spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){long long data;data=5L;printLongLongLine(data);}
void b_main_sink(int data);static void main(){int data;data=-1;data=100-1;b_main_sink(data);}void b_main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, L"%s", data);printWLine(dest);}}
void main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];data=NULL;data=new wchar_t[100];data_array[2]=data;main_sink(data_array);}void main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t src[100];wcscpy(data, src);printWLine(data);delete [] data;}}
static void main(){int count;count=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;count=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(&count);}void b_main_sink(int * count_ptr){int count=*count_ptr;{size_t i=0;if (count > 0 && count <=20){for (i=0;i < (size_t)count;i++){printLine("Hello");}}}}
static void main(){int * data;int * data_array[5];data=NULL;{int data_goodbuf[100];data=data_goodbuf;data[0]=5;printIntLine(data[0]);}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int * data_array[]){int * data=data_array[2];}
static void main(){int data;data=-1;data=20;main_data=data;main_sink();}void main_sink(){int data=main_data;{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}
static void main_sink(wchar_t * data){_wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");func_ptr(data);}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;func_ptr(data);}void b_main_sink(char * data){{char src[100];strncat(data, src, 100);printLine(data);}}
void b_main_sink(char * * data);static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char src[100];strncpy(data, src, 100);printLine(data);}}
static void main_sink(){int data=_main_data;{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than the length of the source string or too large");}}}static void main(){int data;data=-1;data=10000;_main_data=data;main_sink();}
static void main(){char * data;char data_buf[250]="PATH=";data=data_buf;strcat(data, NEW_PATH);PUTENV(data);}
static void main(){long long * data;_union_type my_union;data=NULL;data=(long long *)malloc(100*sizeof(long long));{size_t i;for(i=0;i < 100;i++){data[i]=5L;}}free(data);my_union.a=data;{long long * data=my_union.b;}}
static void * main_source(void * data){data=WIDE_STRING;return data;}static void main(){void * data;data=NULL;data=main_source(data);{size_t data_len=wcslen((wchar_t *)data);void * data_dest=(void *)calloc(data_len+1, sizeof(wchar_t));memcpy(data_dest, data, (data_len+1)*sizeof(wchar_t));printWLine((wchar_t *)data_dest);free(data_dest);}}
static void main(){twointsclass * data;twointsclass * &data_ref=data;data=(twointsclass *)malloc(10*sizeof(twointsclass));for(int i=0;i<10;i++){data[i].a=i;data[i].b=i;}{twointsclass * data=data_ref;for(int i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){int data;data=-1;if(global_returns_t_or_f()){fscanf (stdin, "%d", &data);}else{fscanf (stdin, "%d", &data);}if(global_returns_t_or_f()){{int result=-1;if (data < INT_MAX){result=data+1;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}else{{int result=-1;if (data < INT_MAX){result=data+1;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
static FILE * main_source(FILE * data){data=fopen("BadSource_fopen.txt", "w+");return data;}static void main(){FILE * data;data=NULL;data=main_source(data);if (data!=NULL){fclose(data);}}
static void main(){unsigned int data;data=0;data=0;b_main_sink(data);}void b_main_sink(unsigned int data){c_main_sink(data);}void c_main_sink(unsigned int data){d_main_sink(data);}void d_main_sink(unsigned int data){{unsigned int result=0;if (data > 0){result=data-1;printUnsignedLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static wchar_t * main_source(wchar_t * data){wcscat(data, L"*.*");return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;data=main_source(data);{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];data=(char *)malloc(100*sizeof(char));data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{char dest[50]="";memmove(dest, data, strlen(data)*sizeof(char));printLine(data);free(data);}}
static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));main_sink(data);}void main_sink(long long * data){free(data);}
static void main(){int data;data=-1;data=RAND32();b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){{struct _twoints * data=(struct _twoints *)malloc(100*sizeof(struct _twoints));struct _twoints * tmp;data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);tmp=(struct _twoints *)realloc(data, (130000)*sizeof(struct _twoints));if (tmp!=NULL){data=tmp;data[0].a=1;data[0].b=1;printStructLine((twoints *)&data[0]);}free(data);}}
void b_main_sink(char * data);static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;b_main_sink(data);}void b_main_sink(char * data){{char src[100];strcpy(data, src);printLine(data);}}
static void main(){int data;data=7;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{wchar_t data_buf[10]=L"AAAAAAAAA";if (data >=0){printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t data_src[10+1]=SRC_STRING;wcsncpy(data, data_src, wcslen(data_src));printWLine(data);free(data);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"C:\\Windows\\System32\\winsrv.dll");{HMODULE hModule;hModule=LoadLibraryW(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
static void main_sink(unsigned int data){{unsigned int result=0;if (data > 0){result=data-1;printUnsignedLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}static void main(){unsigned int data;data=0;fscanf (stdin, "%u", &data);main_sink(data);}
static void main_sink(int * data){printIntLine(*data);}static void main(){int * data;void (*func_ptr) (int *)=main_sink;data=NULL;data=new int;func_ptr(data);}
static void main(){int data;data=-1;data=5;_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{int result=data * 2;printIntLine(result);}}
void b_main_sink(char * data);static void main(){char * data;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}b_main_sink(data);}void b_main_sink(char * data){{char src[100];memcpy(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}
static void main(){int data;data=-1;data=10000;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than the length of the source string or too large");}}}
static void main_sink(){twoints * data=main_data;free(data);}static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));main_data=data;main_sink();}
static void main(){char * data;char * data_array[5];char data_buf[100]="";data=data_buf;data=PASSWORD;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];if (strstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
static wchar_t * main_source(wchar_t * data){return data;}static void main(){wchar_t * data;data=new wchar_t[100];data=main_source(data);{wchar_t dest[50]=L"";wcsncat(dest, data, wcslen(data));printWLine(data);delete [] data;}}
static void main(){short data;_union_type my_union;data=0;data=100-1;my_union.a=data;{short data=my_union.b;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;if (wcsncmp(PASSWORD, data, wcslen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(void * void_data_ptr);static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{size_t i, dest_sz;char dest[100];memset(dest, 'C', 100-1);dest_sz=strlen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);free(data);}}
static wchar_t * main_source(wchar_t * data){{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));data=data_buf;}return data;}static void main(){wchar_t * data;data=main_source(data);printWLine(data);free(data);}
static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=-1;data=RAND32();func_ptr(data);}void b_main_sink(int data){{int result=-1;if (data < INT_MAX){result=data+1;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
static void main(){{char dst[DST_SZ];strncpy(dst, COPY_STR, DST_SZ-1);dst[DST_SZ-1]='\0';printLine(dst);}}
static void main(){{char data_buf[100]="";char * data=data_buf;if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin)!=100-1){printLine("fread failed!");}}}
static void main(){long long * data;_union_type my_union;long long * data_badbuf=(long long *)ALLOCA(50*sizeof(long long));long long * data_goodbuf=(long long *)ALLOCA(100*sizeof(long long));data=data_goodbuf;my_union.a=data;{long long * data=my_union.b;{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printLongLongLine(data[0]);}}}}
short b_main_source(short data);static void main(){short data;data=0;data=b_main_source(data);{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}short b_main_source(short data){data=100-1;return data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t dest[50]=L"";wcscat(dest, data);printWLine(data);}}
static void main(){char * data;data=NULL;main_source(data);delete [] data;}void main_source(char * &data){data=new char[100];}
static void main_sink(){char * data=main_data;delete [] data;}static void main(){char * data;data=NULL;data=new char[100];main_data=data;main_sink();}
static int main_source(int data){data=20;return data;}static void main(){int data;data=-1;data=main_source(data);{size_t a,i;int *b;b=(int*)new char[a];for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);delete [] b;}}
void b_main_sink(_struct_type my_struct);static void main(){twoints * data;_struct_type my_struct;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){twoints * data=my_struct.a;{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printStructLine(&data[0]);free(data);}}}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf(data, args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);main_vasink(data, data);}char * b_main_source(char * data){strcpy(data, "fixedstringtest");return data;}
static void main(){char * data;_union_type my_union;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;my_union.a=data;{char * data=my_union.b;{char dest[100];memcpy(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}}
static void main(){unsigned char data;data=' ';data=(unsigned char)rand();b_main_sink(data);}void b_main_sink(unsigned char data){{unsigned char result=-1;if (data <=(UCHAR_MAX/2)){result=data * 2;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static int * main_source(int * data){data=new int;return data;}static void main(){int * data;data=NULL;data=main_source(data);delete data;}
static void main(){int * data;data=(int *)ALLOCA(10*sizeof(int));{int i;for(i=0;i<(10/2);i++){data[i]=i;}}b_main_sink(&data);}void b_main_sink(int * * data_ptr){int * data=*data_ptr;{int i;for(i=0;i<10;i++){data[i]=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}}
static void main_sink(){wchar_t * data=_main_data;{wchar_t data_src[10+1]=SRC_STRING;memcpy(data, data_src, wcslen(data_src)*sizeof(wchar_t));printWLine(data);free(data);}}static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));_main_data=data;main_sink();}
static void main(){twoints * data;_struct_type my_struct;data=NULL;{twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine(&data[0]);}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){twoints * data=my_struct.a;}
static void main(){twointsclass * data;twointsclass * &data_ref=data;data=NULL;data=new twointsclass;{twointsclass * data=data_ref;delete data;}}
void main_sink(int * data);static void main(){int * data;void (*func_ptr) (int *)=main_sink;data=NULL;data=new int[100];func_ptr(data);}void main_sink(int * data){{memmove(data, src, 100*sizeof(int));printIntLine(data[0]);delete [] data;}}
void b_main_sink(char * data);static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}printLine(data);}}
static void main_sink(short data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}static void main(){short data;void (*func_ptr) (short)=main_sink;data=0;data=100-1;func_ptr(data);}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;data=NULL;{wchar_t * data=*data_ptr1;data=new wchar_t[100];}{wchar_t * data=*data_ptr2;delete [] data;}}
static void main_sink(wchar_t * data){{wchar_t src[100];wcsncpy(data, src, 100);data[100-1]=L'\0';printWLine(data);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;func_ptr(data);}
void main_sink(void * void_data_ptr);static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}main_sink(&data);}void main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{wchar_t src[100];wcsncpy(data, src, 100);data[100-1]=L'\0';printWLine(data);}}
static void main(){double * data;data=new double[10];{int i;for(i=0;i<10;i++){data[i]=(double)i;}}main_sink(&data);}void main_sink(void * void_data_ptr){double * * data_ptr=(double * *)void_data_ptr;double * data=(*data_ptr);{int i;for(i=0;i<10;i++){printDoubleLine(data[i]);}}delete [] data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){int data;_union_type my_union;data=-1;data=5;my_union.a=data;{int data=my_union.b;{int result=data-1;printIntLine(result);}}}
static void main(){twoints * data;union_type my_union;data=NULL;data=new twoints;my_union.a=data;{twoints * data=my_union.b;delete data;}}
static void main(){wchar_t * data;struct_type my_struct;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){wchar_t * data=my_struct.a;free(data);}
static void main(){int data;data=-1;data=7;printIntLine(100/data);}
static void main(){int * data;data=(int *)calloc(100, sizeof(int));{int * data_copy=data;int * data=data_copy;if (data!=NULL){data[0]=5;printIntLine(data[0]);free(data);}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, data, args);va_end(args);printLine(dest);}}void d_main_sink(char * data){main_vasink(data, data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(char * data){if (strstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
static void main(){unsigned char data;_struct_type my_struct;data=' ';data=5;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){unsigned char data=my_struct.a;{unsigned char result=data+1;printHexUnsignedCharLine(result);}}
static void main(){unsigned char data;unsigned char *data_ptr1=&data;unsigned char *data_ptr2=&data;data=' ';{unsigned char data=*data_ptr1;data=5;}{unsigned char data=*data_ptr2;{unsigned char result=data-1;printHexUnsignedCharLine(result);}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t src[100];_snwprintf(data, 100, L"%s", src);printWLine(data);}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;data=NULL;data=(char *)malloc((10+1)*sizeof(char));my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char data_src[10+1]=SRC_STRING;memmove(data, data_src, strlen(data_src)*sizeof(char));printLine(data);free(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"15");{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main(){twointsclass * data;twointsclass * data_array[5];data=NULL;data=new twointsclass[100];{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}delete [] data;data_array[2]=data;main_sink(data_array);}void main_sink(twointsclass * data_array[]){twointsclass * data=data_array[2];}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void b_main_sink(wchar_t * data){EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));{wchar_t dest[50]=L"";_snwprintf(dest, wcslen(data), L"%s", data);printWLine(data);free(data);}}
static void main(){char * data;data=NULL;main_source(data);delete [] data;}void main_source(char * &data){data=new char[100];}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)calloc(100, sizeof(wchar_t));wcscpy(data, L"A String");printWLine(data);free(data);}
static void main_sink(){char * data=_main_data;{char src[100];_snprintf(data, 100, "%s", src);printLine(data);free(data);}}static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));_main_data=data;main_sink();}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;func_ptr(data);}void b_main_sink(char * data){{char dest[50]="";memcpy(dest, data, strlen(data)*sizeof(char));printLine(data);}}
void b_main_sink(FILE * data);static void main(){FILE * data;data=NULL;data=fopen("file.txt", "w+");b_main_sink(data);}void c_main_sink(FILE * data);void b_main_sink(FILE * data){c_main_sink(data);}void d_main_sink(FILE * data);void c_main_sink(FILE * data){d_main_sink(data);}void e_main_sink(FILE * data);void d_main_sink(FILE * data){e_main_sink(data);}void e_main_sink(FILE * data){if (data!=NULL){fclose(data);}}
static void main(){int data;data=-1;fscanf (stdin, "%d", &data);main_data=data;main_sink();}void main_sink(){int data=main_data;{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t src[100];wcscpy(data, src);printWLine(data);}}
static void main(){char * data;data=NULL;data=new char;printHexCharLine(*data);main_data=data;main_sink();}void main_sink(){char * data=main_data;delete data;}
static void main(){int * data;data=NULL;data=new int;main_sink_b(data);}void main_sink_b(int * data){main_sink_c(data);}void main_sink_c(int * data){delete data;}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, "%s", args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}{char * data_copy=data;char * data=data_copy;main_vasink(data, data);}}
static void main(){unsigned char data;data=' ';data=5;b_main_sink(data);}void b_main_sink(unsigned char data){c_main_sink(data);}void c_main_sink(unsigned char data){{unsigned char result=data * 2;printHexUnsignedCharLine(result);}}
static void main(){unsigned int data;data=0;if(global_returns_t_or_f()){data=5;}else{data=5;}if(global_returns_t_or_f()){{unsigned int result=data * 2;printUnsignedLine(result);}}else{{unsigned int result=data * 2;printUnsignedLine(result);}}}
static void main_sink(){char * data=_main_data;printf(data);}static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");_main_data=data;main_sink();}
void b_main_sink(char * data);static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{char src[100];strncat(data, src, 100);printLine(data);free(data);}}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, GOOD_OS_COMMAND);my_union.a=data;{wchar_t * data=my_union.b;{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t dest[50]=L"";wcscat(dest, data);printWLine(data);free(data);}}
void b_main_sink(char * data);static void main(){char * data;data=(char *)malloc(100*sizeof(char));b_main_sink(data);}void b_main_sink(char * data){{char dest[50]="";memcpy(dest, data, strlen(data)*sizeof(char));printLine(data);free(data);}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;main_sink_b(data);}void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_c(twointsclass * data){delete data;}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}
static void main(){wchar_t * data;struct_type my_struct;data=NULL;data=new wchar_t;my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){wchar_t * data=my_struct.a;delete data;}
static void main(){int data;data=-1;data=5;{int result=data+1;printIntLine(result);}}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;{int data=*data_ptr1;data=7;}{int data=*data_ptr2;{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}}
static twoints * main_source(twoints * data){{twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine(&data[0]);}return data;}static void main(){twoints * data;data=NULL;data=main_source(data);}
static void main(){wchar_t * data;data=NULL;main_source(data);}void main_source(wchar_t * &data){wchar_t data_good;data=&data_good;printHexCharLine((char)*data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, L"%s", data);printWLine(dest);}}wchar_t * b_main_source(wchar_t * data){{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}return data;}
static void main_sink(char * data){{char src[100];memcpy(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}func_ptr(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;func_ptr(data);}void b_main_sink(wchar_t * data){{wchar_t dest[100];memmove(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;{wchar_t src[100];wcscpy(data, src);printWLine(data);}}
static twointsclass * main_source(twointsclass * data){data=new twointsclass[100];return data;}static void main(){twointsclass * data;data=NULL;data=main_source(data);delete [] data;}
static long long * main_source(long long * data){{long long * data_buf=(long long *)malloc(100*sizeof(long long));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5L;}}data=data_buf;}return data;}static void main(){long long * data;data=main_source(data);printLongLongLine(data[0]);free(data);}
static void main(){int count;count=-1;count=20;{size_t i=0;FILE *file=NULL;const char *filename="output_bad.txt";file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}
static void main(){int data;data=-1;fscanf (stdin, "%d", &data);{int data_copy=data;int data=data_copy;{int result=-1;if (data <=(INT_MAX/2)){result=data * 2;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
static void main_sink(int * data){}static void main(){int * data;data=NULL;int data_good;data=&data_good;printIntLine(*data);main_sink(data);}
void b_main_sink();static void main(){char * data;char data_buf[100];data=data_buf;_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{char dest[50]="";strcpy(dest, data);printLine(data);}}
void b_main_sink(void * void_data_ptr);static void main(){char * data;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{char dest[100];memcpy(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
static void main(){char * data;data=NULL;data=new char[100];{char src[100];_snprintf(data, 100, "%s", src);printLine(data);delete [] data;}}
static void main(){int data;data=7;_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main_sink(int * data){free(data);}static void main(){int * data;void (*func_ptr) (int *)=main_sink;data=NULL;data=(int *)calloc(100, sizeof(int));func_ptr(data);}
void main_sink(struct_type my_struct);static void main(){int data;struct_type my_struct;data=-1;data=20;my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){int data=my_struct.a;{size_t a,i;int *b;b=(int*)new char[a];for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);delete [] b;}}
static void main_sink(wchar_t * data){EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");func_ptr(data);}
static int * main_source(int * data){{int data_goodbuf[100];data=data_goodbuf;data[0]=5;printIntLine(data[0]);}return data;}static void main(){int * data;data=NULL;data=main_source(data);}
static void main_sink(){twoints * data=_main_data;{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memmove(data, src, 100*sizeof(twoints));printStructLine(&data[0]);}}static void main(){twoints * data;twoints * data_badbuf=(twoints *)ALLOCA(50*sizeof(twoints));twoints * data_goodbuf=(twoints *)ALLOCA(100*sizeof(twoints));data=data_goodbuf;_main_data=data;main_sink();}
static void main(){int data;data=-1;data=5;b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{int result=data * 2;printIntLine(result);}}
static void main(){int data;data=-1;data=100-1;{int data_copy=data;int data=data_copy;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}}
static void main(){twointsclass * data;data=NULL;data=NULL;data=(twointsclass *)realloc(data, 100*sizeof(twointsclass));main_sink(data);}void main_sink(twointsclass * data){free(data);}
static void main(){char * data;data=NULL;data=new char;main_sink(&data);}void main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);delete data;}
static void main_sink(char * data){free(data);}static void main(){char * data;data=NULL;data=(char *)calloc(100, sizeof(char));strcpy(data, "A String");printLine(data);main_sink(data);}
static void main(){{twointsclass * data;data=new twointsclass;data->a=5;data->b=6;twointsclass * * pointer=new twointsclass *;{twointsclass * data=*pointer;printIntLine(data->a);printIntLine(data->b);}delete pointer;}}
static void main_sink(){int * data=_main_data;{memcpy(data, src, 100*sizeof(int));printIntLine(data[0]);free(data);}}static void main(){int * data;data=NULL;data=(int *)malloc(100*sizeof(int));_main_data=data;main_sink();}
static void main_sink(){wchar_t * data=_main_data;fwprintf(stdout, data);}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");_main_data=data;main_sink();}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");b_main_sink(data);}void b_main_sink(wchar_t * data){{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));main_sink_b(data);}void main_sink_b(long long * data){main_sink_c(data);}void main_sink_c(long long * data){free(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{char dest[100]="";SNPRINTF(dest, 100-1, data);printLine(dest);}}
static void main(){int count;_union_type my_union;count=-1;count=20;my_union.a=count;{int count=my_union.b;{size_t i=0;FILE *file=NULL;const char *filename="output_bad.txt";file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;my_union.a=data;{wchar_t * data=my_union.b;if (wcsncmp(PASSWORD, data, wcslen(data))==0) printLine("Access granted");else printLine("Access denied!");}}
static void main_sink(wchar_t * data){_wsystem(data);}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");func_ptr(data);}
static void main(){int count;_struct_type my_struct;count=-1;count=20;my_struct.a=count;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int count=my_struct.a;{size_t i=0;FILE *file=NULL;const char *filename="output_bad.txt";file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}
static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{int i, n, v;if (swscanf(data, L"%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static void main(){int data;int data_array[5];data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=-1;data=5;func_ptr(data);}void b_main_sink(int data){{int result=data+1;printIntLine(result);}}
static twoints * main_source(twoints * data){data=NULL;data=(twoints *)realloc(data, 100*sizeof(twoints));return data;}static void main(){twoints * data;data=NULL;data=main_source(data);free(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;if (strstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=5;}{int data=*data_ptr2;{int result=data-1;printIntLine(result);}}}
static wchar_t * main_source(wchar_t * data){wcscpy(data, L"C:\\Windows\\System32\\winsrv.dll");return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);{HMODULE hModule;hModule=LoadLibraryW(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
void b_main_sink(char * data);static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{char dest[50]="";strncpy(dest, data, strlen(data));printLine(data);}}
static void main(){int data;data=-1;if(global_returns_t_or_f()){data=100-1;}else{data=100-1;}{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
static int * main_source(int * data){data=(int *)malloc(100*sizeof(int));data[0]=5;printIntLine(data[0]);return data;}static void main(){int * data;data=NULL;data=main_source(data);free(data);}
static char * main_source(char * data){strcpy(data, "C:\\Windows\\System32\\winsrv.dll");return data;}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);{HMODULE hModule;hModule=LoadLibraryA(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=NULL;{char * data=*data_ptr1;data=(char *)malloc(100*sizeof(char));}{char * data=*data_ptr2;{char dest[100];memset(dest, 'C', 100-1);memcpy(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);free(data);}}}
void b_main_sink();static void main(){int data;data=-1;data=100-1;_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{wchar_t data_src[10+1]=SRC_STRING;memmove(data, data_src, wcslen(data_src)*sizeof(wchar_t));printWLine(data);free(data);}}
static twoints * main_source(twoints * data){data=NULL;data=(twoints *)realloc(data, 100*sizeof(twoints));data[0].a=0;data[0].b=0;printStructLine(&data[0]);return data;}static void main(){twoints * data;data=NULL;data=main_source(data);free(data);}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}func_ptr(data);}void b_main_sink(char * data){{int i, n, v;if (sscanf(data, "%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static void main(){int data;data=-1;data=20;{char * char_string;if (data > 0){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than 0");}}}
static void main_sink(int data){assert(data > ASSERT_VALUE);}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=ASSERT_VALUE+1;func_ptr(data);}
static void main(){int * data;data=NULL;data=new int[100];main_sink(&data);}void main_sink(int * * data_ptr){int * data=*data_ptr;delete [] data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");func_ptr(data);}void b_main_sink(wchar_t * data){EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, L"%s", data);printWLine(dest);}}
char * b_main_source(char * data);static void main(){char * data;data=NULL;data=b_main_source(data);{char dest[100];memset(dest, 'C', 100-1);memcpy(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);free(data);}}char * b_main_source(char * data){data=(char *)malloc(100*sizeof(char));return data;}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=NULL;{char * data=*data_ptr1;data=NULL;data=(char *)realloc(data, 100*sizeof(char));}{char * data=*data_ptr2;free(data);}}
static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;{char * data_copy=data;char * data=data_copy;{size_t i;char dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);}}}
static void main(){char * data;data="string";printLine(data);}
static void main_sink(long long * data){if (data!=NULL){data[0]=5L;printLongLongLine(data[0]);free(data);}}static void main(){long long * data;data=(long long *)realloc(data, 100);main_sink(data);}
static void main(){unsigned int data;data=0;data=(unsigned int)RAND32();_main_data=data;b_main_sink();}void b_main_sink(){unsigned int data=_main_data;{unsigned int result=0;if (data > 0){result=data-1;printUnsignedLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static void main(){HANDLE data;_struct_type my_struct;data=CreateFile("BadSource_w32CreateFile.txt", (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);CloseHandle(data);my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){HANDLE data=my_struct.a;}
static void main(){unsigned int data;data=0;if(global_returns_t_or_f()){data=(unsigned int)RAND32();}else{data=(unsigned int)RAND32();}if(global_returns_t_or_f()){{unsigned int result=-1;if (data <=(unsigned int)sqrt((unsigned int)UINT_MAX)){result=data * data;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}else{{unsigned int result=-1;if (data <=(unsigned int)sqrt((unsigned int)UINT_MAX)){result=data * data;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}
static void main_sink(wchar_t * data){delete[] data;}static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];wcscpy(data, L"A String");printWLine(data);main_sink(data);}
static void main(){unsigned int data;data=0;data=(unsigned int)RAND32();b_main_sink(&data);}void b_main_sink(void * void_data_ptr){unsigned int * data_ptr=(unsigned int *)void_data_ptr;unsigned int data=(*data_ptr);{unsigned int result=-1;if (data <=(UINT_MAX/2)){result=data * 2;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
void main_sink_b(wchar_t * data);static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}main_sink_b(data);}void main_sink_c(wchar_t * data);void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]=L'\0';printWLine(data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);{char dest[100]="";SNPRINTF(dest, 100-1, data);printLine(dest);}}char * b_main_source(char * data){strcpy(data, "fixedstringtest");return data;}
void b_main_sink(_struct_type my_struct);static void main(){char * password;_struct_type my_struct;char password_buf[100]="";password=password_buf;{size_t password_len=0;fgets(password, 100, stdin);password_len=strlen(password);if (password_len > 0){password[password_len-1]='\0';}}my_struct.a=password;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * password=my_struct.a;{HANDLE pHandle;char * username="User";char * domain="Domain";if (LogonUserA( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}
static void main_sink(short data){{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}static void main(){short data;void (*func_ptr) (short)=main_sink;data=0;data=100-1;func_ptr(data);}
void main_sink_b(char * data);static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_d(char * data);void main_sink_c(char * data){main_sink_d(data);}void main_sink_e(char * data);void main_sink_d(char * data){main_sink_e(data);}void main_sink_e(char * data){{char src[100];memmove(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}
static void main_sink(char * data){if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;main_sink(data);}
static void main(){char * data;data=NULL;if(global_returns_t_or_f()){data=NULL;data=(char *)realloc(data, 100*sizeof(char));}else{data=NULL;data=(char *)realloc(data, 100*sizeof(char));}if(global_returns_t_or_f()){free(data);}else{free(data);}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=20;}{int data=*data_ptr2;{char * char_string;if (data > 0){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than 0");}}}}
static void main(){int * data;int * data_array[5];data=NULL;data=new int[100];delete [] data;data_array[2]=data;main_sink(data_array);}void main_sink(int * data_array[]){int * data=data_array[2];}
static void main(){short data;data=0;data=100-1;{short data_copy=data;short data=data_copy;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data="P";b_main_sink(data);}void b_main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]="";data=data_buf;data=PASSWORD;func_ptr(data);}void b_main_sink(char * data){if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(short data);static void main(){short data;void (*func_ptr) (short)=b_main_sink;data=0;data=100-1;func_ptr(data);}void b_main_sink(short data){{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
void b_main_sink(int * data);static void main(){int data;data=-1;data=100-1;b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));data[0]=L'\0';wcscpy(data, BAD_SRC_FIXED);{size_t i;for (i=0;i < wcslen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));printWLine(data);free(data);}}
static void main_sink(){wchar_t * data=_main_data;{wchar_t dest[100];wmemset(dest, L'C', 100-1);memmove(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;_main_data=data;main_sink();}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]=L'\0';printWLine(data);}}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}wchar_t * b_main_source(wchar_t * data){wcscat(data, L"*.*");return data;}
static void main(){struct _twoints * data;void (*func_ptr) (struct _twoints *)=b_main_sink;data=NULL;{struct _twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);}func_ptr(data);}void b_main_sink(struct _twoints * data){}
static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));printWLine(data);}}}
void _main_sink(wchar_t * password){{HANDLE pHandle;wchar_t * username=L"User";wchar_t * domain=L"Domain";if (LogonUserW( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}static void main(){wchar_t * password;wchar_t password_buf[100]=L"";password=password_buf;wcscpy(password, L"Password1234!");_main_sink(password);}
void b_main_sink(int data);static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=-1;data=100-1;func_ptr(data);}void b_main_sink(int data){{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, L"%s", args);va_end(args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}{wchar_t * data_copy=data;wchar_t * data=data_copy;main_vasink(data, data);}}
void b_main_sink(int data_array[]);static void main(){int data;int data_array[5];data=-1;data=7;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];printIntLine(100 % data);}
static char * main_source(char * data){{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}return data;}static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, "%s", args);va_end(args);printLine(dest);}}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);main_vasink(data, data);}
static void main(){long long * data;void (*func_ptr) (long long *)=main_sink;data=NULL;data=new long long[100];func_ptr(data);}void main_sink(long long * data){delete [] data;}
static void main(){int data;_union_type my_union;data=-1;fscanf (stdin, "%d", &data);my_union.a=data;{int data=my_union.b;{int result=-1;if (data < INT_MAX){result=data+1;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
static void main(){{wchar_t data_buf[100]=L"";wchar_t * data=data_buf;if (fread((wchar_t *)data, sizeof(wchar_t), (size_t)(100-1), stdin)!=100-1){printLine("fread failed!");}}}
static void main(){int data;data=-1;data=20;{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}
static void main(){int * data;data=NULL;data=(int *)calloc(100, sizeof(int));data[0]=5;printIntLine(data[0]);b_main_sink(data);}void b_main_sink(int * data){free(data);}
static void main_source(twointsclass * &data){data=new twointsclass;}static void main(){twointsclass * data;data=NULL;main_source(data);delete data;}
void main_sink(int data_array[]);static void main(){int data;int data_array[5];data=-1;data=20;data_array[2]=data;main_sink(data_array);}void main_sink(int data_array[]){int data=data_array[2];{size_t a,i;int *b;b=(int*)new char[a];for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);delete [] b;}}
void b_main_sink(void * data);static void main(){void * data;twoints data_goodbuf;int data_badbuf=100;data_goodbuf.a=0;data_goodbuf.b=0;data=&data_goodbuf;b_main_sink(data);}void c_main_sink(void * data);void b_main_sink(void * data){c_main_sink(data);}void d_main_sink(void * data);void c_main_sink(void * data){d_main_sink(data);}void d_main_sink(void * data){printStructLine((twoints *)data);}
static void main(){int data;int data_array[5];{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0 && data < 10){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){if (wcsncmp(PASSWORD, data, wcslen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){char * data;char * data_array[5];data=NULL;data=new char[100];data_array[2]=data;main_sink(data_array);}void main_sink(char * data_array[]){char * data=data_array[2];delete [] data;}
static void main(){int data;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){{char data_buf[10]="AAAAAAAAA";{printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
void b_main_sink(twoints * * data);static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));b_main_sink(&data);}void b_main_sink(twoints * * data_ptr){twoints * data=*data_ptr;{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memmove(data, src, 100*sizeof(twoints));printStructLine(&data[0]);free(data);}}
void b_main_sink(void * void_cryptokey_ptr);static void main(){char * cryptokey;char cryptokey_buf[100]="";cryptokey=cryptokey_buf;{size_t cryptokey_len=strlen(cryptokey);if(100-cryptokey_len > 1){fgets(cryptokey+cryptokey_len, (int)(100-cryptokey_len), stdin);cryptokey_len=strlen(cryptokey);if (cryptokey_len > 0){cryptokey[cryptokey_len-1]='\0';}}}b_main_sink(&cryptokey);}void b_main_sink(void * void_cryptokey_ptr){char * * cryptokey_ptr=(char * *)void_cryptokey_ptr;char * cryptokey=(*cryptokey_ptr);{HCRYPTPROV cryptoprov;HCRYPTKEY key;HCRYPTHASH hash;DWORD toBeEncryptedLen=strlen(toBeEncrypted)*sizeof(char);if(!CryptAcquireContext(&cryptoprov, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, 0)){if(!CryptAcquireContext(&cryptoprov, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET)){printLine("Error in acquiring cryptographic context");exit(1);}}if(!CryptCreateHash(cryptoprov, CALG_SHA1, 0, 0, &hash)){printLine("Error in creating hash");exit(1);}if(!CryptHashData(hash, (BYTE *) cryptokey, strlen(cryptokey)*sizeof(char), 0)){printLine("Error in hashing cryptokey");exit(1);}if(!CryptDeriveKey(cryptoprov, CALG_3DES, hash, 0, &key)){printLine("Error in CryptDeriveKey");exit(1);}if(!CryptEncrypt(key, (HCRYPTHASH)NULL, 1, 0, (BYTE *)toBeEncrypted, &toBeEncryptedLen, sizeof(toBeEncrypted))){printLine("Error in CryptEncryptData");exit(1);}printLine(toBeEncrypted);}}
static void main_sink(){int data=_main_data;printIntLine(100/data);}static void main(){int data;data=-1;data=7;_main_data=data;main_sink();}
static void main_sink(char * data){{size_t i;for (i=0;i < strlen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}static void main(){char * data;data=(char *)malloc(100*sizeof(char));data[0]='\0';{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}main_sink(data);}
static void main(){unsigned char data;data=' ';data=b_main_source(data);{unsigned char result=data * 2;printHexUnsignedCharLine(result);}}unsigned char b_main_source(unsigned char data){data=5;return data;}
void b_main_sink(int data);static void main(){int data;data=-1;data=7;b_main_sink(data);}void b_main_sink(int data){printIntLine(100/data);}
static void main(){int data;data=-1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}main_sink(&data);}void main_sink(int * data_ptr){int data=*data_ptr;{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=ASSERT_VALUE+1;}{int data=*data_ptr2;assert(data > ASSERT_VALUE);}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=RAND32();}{int data=*data_ptr2;{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than the length of the source string or too large");}}}}
void b_main_sink(int * data);static void main(){int * data;void (*func_ptr) (int *)=b_main_sink;data=(int *)realloc(data, 100);func_ptr(data);}void b_main_sink(int * data){if (data!=NULL){data[0]=5;printIntLine(data[0]);free(data);}}
static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t dest[100];wmemset(dest, L'C', 100-1);memmove(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=CHAR_MAX-5;}{int data=*data_ptr2;{short s=(short)data;printf("%hd\n", s);}}}
static void main(){int data;fscanf (stdin, "%d", &data);_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){e_main_sink(data);}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, "%s", args);va_end(args);}}void e_main_sink(char * data){main_vasink(data, data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;strcat(data, "*.*");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
static void main(){unsigned int data;unsigned int *data_ptr1=&data;unsigned int *data_ptr2=&data;data=0;{unsigned int data=*data_ptr1;data=0;}{unsigned int data=*data_ptr2;{unsigned int result=0;if (data > 0){result=data-1;printUnsignedLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}char * b_main_source(char * data){data=PASSWORD;return data;}
static void main(){char * data;char * &data_ref=data;data=new char[100];{char * data=data_ref;{char dest[50]="";strncpy(dest, data, strlen(data));printLine(data);delete [] data;}}}
static void main(){wchar_t * data;_union_type my_union;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}my_union.a=data;{wchar_t * data=my_union.b;{wchar_t dest[100];memmove(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;strcpy(data, "C:\\Windows\\System32\\winsrv.dll");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{HMODULE hModule;hModule=LoadLibraryA(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");b_main_sink(data);}void b_main_sink(wchar_t * data){{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=20;}{int data=*data_ptr2;{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}}
static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");{FILE *pipe;pipe=POPEN(data, "wb");if (pipe!=NULL) PCLOSE(pipe);}}
static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}{char * data_copy=data;char * data=data_copy;{char src[100];memmove(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}}
static void main(){unsigned int data;_struct_type my_struct;data=0;data=5;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){unsigned int data=my_struct.a;{unsigned int result=data * 2;printUnsignedLine(result);}}
void b_main_sink();static void main(){short data;data=0;data=100-1;_main_data=data;b_main_sink();}void b_main_sink(){short data=_main_data;{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
static void main(){unsigned int data;data=0;data=(unsigned int)RAND32();b_main_sink(data);}void b_main_sink(unsigned int data){c_main_sink(data);}void c_main_sink(unsigned int data){d_main_sink(data);}void d_main_sink(unsigned int data){e_main_sink(data);}void e_main_sink(unsigned int data){{unsigned int result=-1;if (data < UINT_MAX){result=data+1;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){int * data;data=NULL;data=new int[100];delete [] data;main_sink_b(data);}void main_sink_b(int * data){main_sink_c(data);}void main_sink_c(int * data){main_sink_d(data);}void main_sink_d(int * data){}
static void main(){{HCRYPTPROV Prov;HCRYPTHASH Hash;FILE *password_file=NULL;char password[PASSWORD_INPUT_SZ];UCHAR saved_hash[SHA1SUM_SIZE], calc_hash[SHA1SUM_SIZE];DWORD hash_size;char *replace;size_t i;password_file=fopen("password.txt", "r");if (password_file==NULL) exit(1);for (i=0;i < SHA1SUM_SIZE;i++){ULONG val;if (fscanf(password_file, "%02x", &val)!=1){fclose(password_file);exit(1);}{fclose(password_file);exit(1);}saved_hash[i]=(UCHAR)val;}fclose(password_file);if (fgets(password, PASSWORD_INPUT_SZ, stdin)==NULL) exit(1);replace=strchr(password, '\r');if (replace) *replace='\0';replace=strchr(password, '\n');if (replace) *replace='\0';if (!CryptAcquireContextW(&Prov, 0, 0, PROV_RSA_FULL, 0)) exit(1);if (!CryptCreateHash(Prov, CALG_SHA1, 0, 0, &Hash)){CryptReleaseContext(Prov, 0);exit(1);}*/if (!CryptHashData(Hash, (BYTE*)password, strlen(password), 0)){CryptDestroyHash(Hash);CryptReleaseContext(Prov, 0);exit(1);}hash_size=SHA1SUM_SIZE;if (!CryptGetHashParam(Hash, HP_HASHVAL, (BYTE*)calc_hash, &hash_size, 0)){CryptDestroyHash(Hash);CryptReleaseContext(Prov, 0);exit(1);}if (memcmp(saved_hash, calc_hash, SHA1SUM_SIZE * sizeof(UCHAR))==0){printLine("Access granted");}else{printLine("Access denied");}CryptDestroyHash(Hash);CryptReleaseContext(Prov, 0);}}
static void main(){twoints * data;twoints * data_badbuf=(twoints *)ALLOCA(50*sizeof(twoints));twoints * data_goodbuf=(twoints *)ALLOCA(100*sizeof(twoints));data=data_goodbuf;{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memmove(data, src, 100*sizeof(twoints));printStructLine(&data[0]);}}
short b_main_source(short data);static void main(){short data;data=0;data=b_main_source(data);{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}short b_main_source(short data){data=100-1;return data;}
static void main(){int * data;data=(int *)malloc(100);if (data!=NULL){data[0]=5;printIntLine(data[0]);free(data);}}
static void main(){char * data;char * data_array[5];data=NULL;data=(char *)malloc(100*sizeof(char));data_array[2]=data;main_sink(data_array);}void main_sink(char * data_array[]){char * data=data_array[2];free(data);}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{char dest[100];memcpy(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;strcpy(data, "15");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{int i, n, v;if (sscanf(data, "%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main(){int data;data=-1;data=10000;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than the length of the source string or too large");}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");func_ptr(data);}void b_main_sink(wchar_t * data){_wsystem(data);}
static void main(){wchar_t * data;_union_type my_union;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;my_union.a=data;{wchar_t * data=my_union.b;{wchar_t dest[50]=L"";wcsncpy(dest, data, wcslen(data));printWLine(data);}}}
static wchar_t * main_source(wchar_t * data){wcscpy(data, L"15");return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main(){int * data;data=NULL;data=new int;main_sink_b(data);}void main_sink_b(int * data){main_sink_c(data);}void main_sink_c(int * data){main_sink_d(data);}void main_sink_d(int * data){main_sink_e(data);}void main_sink_e(int * data){delete data;}
static void main(){char * data;data=(char *)malloc(100*sizeof(char));{char * data_copy=data;char * data=data_copy;{char dest[50]="";memmove(dest, data, strlen(data)*sizeof(char));printLine(data);free(data);}}}
static void main(){twoints * data;data=NULL;data=new twoints[100];{twoints * data_copy=data;twoints * data=data_copy;delete [] data;}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "15");b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{int i, n, v;if (sscanf(data, "%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"15");{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main_sink(char * data){{char src[100];strcat(data, src);printLine(data);free(data);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;data=(char *)malloc(100*sizeof(char));func_ptr(data);}
static void main(){long long * data;_union_type my_union;data=NULL;{long long data_goodbuf[100];data=data_goodbuf;data[0]=5L;printLongLongLine(data[0]);}my_union.a=data;{long long * data=my_union.b;}}
static void main(){unsigned int data;_union_type my_union;data=0;fscanf (stdin, "%u", &data);my_union.a=data;{unsigned int data=my_union.b;{unsigned int result=-1;if (data <=(UINT_MAX/2)){result=data * 2;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
static void main_sink(char * data){{char dest[100]="";SNPRINTF(dest, 100-1, data);printLine(dest);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");func_ptr(data);}
void b_main_sink(char * data);static void main(){char * data;char data_buf[250]="PATH=";data=data_buf;strcat(data, NEW_PATH);b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){PUTENV(data);}
static void main(){char data;data=' ';data=5;{char data_copy=data;char data=data_copy;{char result=data-1;printHexCharLine(result);}}}
static void main(){int data;data=7;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");_main_data=data;b_main_sink();}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}void b_main_sink(){char * data=_main_data;main_vasink(data, data);}
static void main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}
static void main_vasinkg(char * data, ...){{va_list args;va_start(args, data);vprintf("%s", args);va_end(args);}}static void main_vasinkb(char * data, ...){{va_list args;va_start(args, data);vprintf(data, args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");main_vasinkb(data, data);}
static void main(){char * data;char * &data_ref=data;data=new char[100];{char * data=data_ref;{char dest[50]="";memcpy(dest, data, strlen(data)*sizeof(char));printLine(data);delete [] data;}}}
static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';if(global_returns_t_or_f()){data=data_buf;}else{data=data_buf;}{char src[100];memmove(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=NULL;{char * data=*data_ptr1;data=(char *)malloc(100*sizeof(char));}{char * data=*data_ptr2;free(data);}}
static void main(){int * data;data=NULL;data=NULL;data=(int *)realloc(data, 100*sizeof(int));main_sink_b(data);}void main_sink_b(int * data){main_sink_c(data);}void main_sink_c(int * data){main_sink_d(data);}void main_sink_d(int * data){free(data);}
static void main(){int data;data=-1;data=20;main_sink(data);}void main_sink(int data){{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}
static void main(){struct _twoints * data;union_type my_union;data=NULL;{struct _twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);}my_union.a=data;{struct _twoints * data=my_union.b;}}
void b_main_sink(_struct_type my_struct);static void main(){int data;_struct_type my_struct;data=-1;data=100-1;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
static void main(){int data;int data_array[5];data=-1;data=INT_MAX;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{int result=-1;if (data <=(INT_MAX/2)){result=data * 2;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){char data;void (*func_ptr) (char)=b_main_sink;data=' ';data=5;func_ptr(data);}void b_main_sink(char data){{char result=data * 2;printHexCharLine(result);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, L"%s", data);printWLine(dest);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, L"%s", data);printWLine(dest);}}
static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));b_main_sink(&data);}void b_main_sink(long long * * data_ptr){long long * data=*data_ptr;free(data);}
static void main(){twoints * data;twoints * &data_ref=data;data=NULL;data=new twoints;{twoints * data=data_ref;delete data;}}
static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=-1;data=10000;func_ptr(data);}void b_main_sink(int data){{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than the length of the source string or too large");}}}
static void main_sink(wchar_t * data){{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");func_ptr(data);}
static void main_sink(long long * data){delete [] data;}static void main(){long long * data;data=NULL;data=new long long[100];main_sink(data);}
void b_main_sink(char * data);static void main(){char * data;data=NULL;data=(char *)malloc((10+1)*sizeof(char));b_main_sink(data);}void b_main_sink(char * data){{char data_src[10+1]=SRC_STRING;memmove(data, data_src, strlen(data_src)*sizeof(char));printLine(data);free(data);}}
static void main(){wchar_t * data;data=NULL;if(global_returns_t_or_f()){data=new wchar_t[100];}else{data=new wchar_t[100];}{size_t i, dest_sz;wchar_t dest[100];wmemset(dest, L'C', 100-1);dest_sz=wcslen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);delete [] data;}}
static void main(){if(global_returns_t_or_f()){{if (putwc((wchar_t)L'A', stdout)==WEOF){printLine("putwc failed!");}}}else{{if (putwc((wchar_t)L'A', stdout)==WEOF){printLine("putwc failed!");}}}}
static int main_source(int data){data=OPEN("BadSource_open.txt", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);return data;}static void main(){int data;data=-1;data=main_source(data);if (data!=-1){CLOSE(data);}}
void main_sink(char * * data);static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}main_sink(&data);}void main_sink(char * * data_ptr){char * data=*data_ptr;{char src[100];memcpy(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}
static void main(){HANDLE data;data=CreateFile("GoodSource_w32CreateFile.txt", (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);{HANDLE data_copy=data;HANDLE data=data_copy;CloseHandle(data);}}
static void main(){unsigned int data;data=0;data=5;b_main_sink(data);}void b_main_sink(unsigned int data){c_main_sink(data);}void c_main_sink(unsigned int data){d_main_sink(data);}void d_main_sink(unsigned int data){e_main_sink(data);}void e_main_sink(unsigned int data){{unsigned int result=data+1;printUnsignedLine(result);}}
static void main_sink(char * data){delete data;}static void main(){char * data;data=NULL;data=new char;main_sink(data);}
static void main(){if(global_returns_t_or_f()){{wchar_t * key=L"TEST\\TestKey";HKEY hKey;if (RegOpenKeyExW( HKEY_CURRENT_USER, key, 0, KEY_WRITE, &hKey)!=ERROR_SUCCESS){printLine("Registry key could not be opened");}else{printLine("Registry key opened successfully");}}}else{{wchar_t * key=L"TEST\\TestKey";HKEY hKey;if (RegOpenKeyExW( HKEY_CURRENT_USER, key, 0, KEY_WRITE, &hKey)!=ERROR_SUCCESS){printLine("Registry key could not be opened");}else{printLine("Registry key opened successfully");}}}}
static void main(){unsigned char data;data=' ';fscanf (stdin, "%hc", &data);b_main_sink(data);}void b_main_sink(unsigned char data){c_main_sink(data);}void c_main_sink(unsigned char data){d_main_sink(data);}void d_main_sink(unsigned char data){{unsigned char result=-1;if (data <=(UCHAR_MAX/2)){result=data * 2;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;fwprintf(stdout, L"%s\n", data);}
static void main_source(int * &data){data=NULL;data=(int *)realloc(data, 100*sizeof(int));}static void main(){int * data;data=NULL;main_source(data);free(data);}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{wchar_t dest[100];memmove(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;data->a=0;data->b=0;printIntLine(data->a);printIntLine(data->b);main_sink(&data);}void main_sink(twointsclass * * data_ptr){twointsclass * data=*data_ptr;delete data;}
static void main(){int data;data=-1;data=7;printIntLine(100 % data);}
static void main(){long long * data;struct_type my_struct;data=NULL;data=(long long *)malloc(100*sizeof(long long));my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){long long * data=my_struct.a;free(data);}
static void main(){{wchar_t data_buf[100]=L"";wchar_t * data=data_buf;if (fwscanf(stdin, L"%99s\0", data)==EOF){printLine("fwscanf failed!");exit(1);}}}
static int main_source(int data){fscanf (stdin, "%d", &data);return data;}static void main(){int data;data=main_source(data);{char data_buf[10]="AAAAAAAAA";{printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
void b_main_sink(_struct_type my_struct);static void main(){int * data;_struct_type my_struct;data=NULL;data=(int *)malloc(100*sizeof(int));my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int * data=my_struct.a;{memcpy(data, src, 100*sizeof(int));printIntLine(data[0]);free(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=L"P";b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){{long l;l=0x10203040;* */l |=LONG_MIN;printIntLine(l);}}
static void main_sink(char * data){fprintf(stdout, data);}static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");main_sink(data);}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;func_ptr(data);}void b_main_sink(char * data){{char dest[100];strcpy(dest, data);printLine(dest);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(int data);static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=-1;data=100-1;func_ptr(data);}void b_main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main_sink(wchar_t * data){{size_t i;for (i=0;i < wcslen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=(wchar_t *)malloc(100*sizeof(wchar_t));data[0]=L'\0';{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]="";data=data_buf;strcat(data, "*.*");func_ptr(data);}void b_main_sink(char * data){EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");my_union.a=data;{char * data=my_union.b;printf(data);}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;data=NULL;{wchar_t * data=*data_ptr1;data=(wchar_t *)malloc(100*sizeof(wchar_t));}{wchar_t * data=*data_ptr2;{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}printWLine(data);free(data);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"15");b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}wchar_t * b_main_source(wchar_t * data){wcscat(data, L"*.*");return data;}
static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, L"%s", data);printWLine(dest);}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=NULL;{char * data=*data_ptr1;{char mystring[]="mystring";data=strdup(mystring);}}{char * data=*data_ptr2;free(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, L"%s", args);va_end(args);}}void b_main_sink(wchar_t * data){main_vasink(data, data);}
static void main(){char data;data=' ';data=5;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * data_ptr=(char *)void_data_ptr;char data=(*data_ptr);{char result=data * 2;printHexCharLine(result);}}
static void main(){{errno_t err_code=-1;double d=(double)sqrt((double)-1);if (_get_errno(&err_code)){printLine("_get_errno failed");exit(1);}if (err_code==EDOM){printLine("sqrt() failed");exit(1);}printDoubleLine(d);}}
static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static wchar_t * main_source(wchar_t * data){wcscat(data, L"*.*");return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){int data;data=-1;data=5;{int result=data * 2;printIntLine(result);}}
void main_sink_b(char * data);static void main(){char * data;data=new char[100];main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_d(char * data);void main_sink_c(char * data){main_sink_d(data);}void main_sink_e(char * data);void main_sink_d(char * data){main_sink_e(data);}void main_sink_e(char * data){{char dest[50]="";strcpy(dest, data);printLine(data);delete [] data;}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
int main_source(int data);static void main(){int data;data=-1;data=main_source(data);{size_t a,i;int *b;b=(int*)new char[a];for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);delete [] b;}}int main_source(int data){data=20;return data;}
static void main(){twoints * data;data=NULL;data=new twoints[100];{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}main_sink_b(data);}void main_sink_b(twoints * data){main_sink_c(data);}void main_sink_c(twoints * data){printStructLine(&data[0]);}
static wchar_t * main_source(wchar_t * data){{wchar_t mystring[]=L"mystring";data=wcsdup(mystring);printWLine(data);}return data;}static void main(){wchar_t * data;data=NULL;data=main_source(data);free(data);}
static void main(){wchar_t * data;data=NULL;if(global_returns_t_or_f()){data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));}else{data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));}{wchar_t data_src[10+1]=SRC_STRING;memmove(data, data_src, wcslen(data_src)*sizeof(wchar_t));printWLine(data);free(data);}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];delete [] data;}
static void main_sink(long long * data){delete [] data;}static void main(){long long * data;data=NULL;data=new long long[100];main_sink(data);}
static void main(){int * data;data=NULL;data=NULL;data=(int *)realloc(data, 100*sizeof(int));data[0]=5;printIntLine(data[0]);free(data);}
static void main(){wchar_t * data;data=NULL;data=new wchar_t;printHexCharLine((char)*data);main_sink_b(data);}void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_d(wchar_t * data){delete data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{wchar_t src[100];wcscpy(data, src);printWLine(data);}}
static void main_sink(char * data){if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;data=PASSWORD;func_ptr(data);}
void main_sink(long long * data_array[]);static void main(){long long * data;long long * data_array[5];{long long * data_buf=new long long[100];{size_t i;for (i=0;i < 100;i++){data_buf[i]=5L;}}data=data_buf;}data_array[2]=data;main_sink(data_array);}void main_sink(long long * data_array[]){long long * data=data_array[2];printLongLongLine(data[0]);delete [] data;}
static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static wchar_t * main_source(wchar_t * data){{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}return data;}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(L"%s", args);va_end(args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);main_vasink(data, data);}
static void main(){wchar_t * data;data=NULL;data=new wchar_t;main_sink(data);}void main_sink(wchar_t * data){delete data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){fprintf(stdout, "%s\n", data);}
static void main_sink(){twointsclass * data=main_data;printIntLine(data[0].a);}static void main(){twointsclass * data;data=NULL;{twointsclass * tmp=new twointsclass;tmp->a=0;tmp->b=0;data=tmp;}main_data=data;main_sink();}
void b_main_sink(char * data);static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{char src[100];memcpy(data, src, 100*sizeof(char));printLine(data);}}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf("%s", args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}main_vasink(data, data);}
static void main(){int data;struct_type my_struct;data=-1;data=20;my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){int data=my_struct.a;{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=new char[100];{char * data=*data_ptr1;}{char * data=*data_ptr2;{char dest[50]="";_snprintf(dest, strlen(data), "%s", data);printLine(data);delete [] data;}}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;data=NULL;{wchar_t * data=*data_ptr1;data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));}{wchar_t * data=*data_ptr2;{wchar_t data_src[10+1]=SRC_STRING;memmove(data, data_src, wcslen(data_src)*sizeof(wchar_t));printWLine(data);free(data);}}}
static void main(){twoints * data;data=NULL;data=new twoints;delete data;}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf("%s", args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}{char * data_copy=data;char * data=data_copy;main_vasink(data, data);}}
static void main(){{char * key="TEST\\TestKey";HKEY hKey;if (RegCreateKeyA( HKEY_CURRENT_USER, key, &hKey)!=ERROR_SUCCESS){printLine("Registry key could not be created");}else{printLine("Registry key created successfully");}}}
void b_main_sink(long long * data);static void main(){long long * data;{long long * data_buf=(long long *)malloc(100*sizeof(long long));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5L;}}data=data_buf;}b_main_sink(data);}void c_main_sink(long long * data);void b_main_sink(long long * data){c_main_sink(data);}void d_main_sink(long long * data);void c_main_sink(long long * data){d_main_sink(data);}void e_main_sink(long long * data);void d_main_sink(long long * data){e_main_sink(data);}void e_main_sink(long long * data){printLongLongLine(data[0]);free(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "15");b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{int i, n, v;if (sscanf(data, "%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main_sink(twointsclass * data){delete data;}static void main(){twointsclass * data;void (*func_ptr) (twointsclass *)=main_sink;data=NULL;data=new twointsclass;func_ptr(data);}
static void main(){FILE * data;data=fopen("GoodSource_fopen.txt", "w+");b_main_sink(&data);}void b_main_sink(FILE * * data_ptr){FILE * data=*data_ptr;fclose(data);}
static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;printf(data);}
static void main_sink(wchar_t * data){if (wcsncmp(PASSWORD, data, wcslen(data))==0) printLine("Access granted");else printLine("Access denied!");}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;main_sink(data);}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{size_t src_len;wchar_t src[100];src_len=wcslen(src);wcsncat(data, src, src_len);printWLine(data);}}
static void main(){int data;fscanf (stdin, "%d", &data);b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(data);}void b_main_sink(char * data){printf(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"15");b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
void main_sink_b(wchar_t * data);static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}main_sink_b(data);}void main_sink_c(wchar_t * data);void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){{size_t i;wchar_t dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);}}
void b_main_sink(int * data);static void main(){int * data;int data_badbuf[50];int data_goodbuf[100];data=data_goodbuf;b_main_sink(data);}void b_main_sink(int * data){{memcpy(data, src, 100*sizeof(int));printIntLine(data[0]);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));printWLine(data);}}
static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}{wchar_t src[100];wcscpy(data, src);printWLine(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(data, args);va_end(args);}}void e_main_sink(wchar_t * data){main_vasink(data, data);}
static void main_source(char * &data){data=new char[100];}static void main(){char * data;data=NULL;main_source(data);delete [] data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(&data);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, data, args);va_end(args);}}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;main_vasink(data, data);}
static void main(){twointsclass * data;data=(twointsclass *)malloc(10*sizeof(twointsclass));for(int i=0;i<10;i++){data[i].a=i;data[i].b=i;}for(int i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}
static void main(){struct _twoints * data;data=NULL;{struct _twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);}{struct _twoints * data_copy=data;struct _twoints * data=data_copy;}}
static void main(){wchar_t * data;union_type my_union;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));my_union.a=data;{wchar_t * data=my_union.b;free(data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}_main_data=data;b_main_sink();}static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, "%s", args);va_end(args);printLine(dest);}}void b_main_sink(){char * data=_main_data;main_vasink(data, data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(char * data){if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){int * data;int * *data_ptr1=&data;int * *data_ptr2=&data;{int * data=*data_ptr1;{int * data_buf=(int *)malloc(100*sizeof(int));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}}{int * data=*data_ptr2;printIntLine(data[0]);free(data);}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=20;}{int data=*data_ptr2;{char * char_string;if (data > 0){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than 0");}}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{wchar_t src[100];wcsncat(data, src, 100);printWLine(data);}}
void _main_sink(short data){{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}static void main(){short data;data=0;data=100-1;_main_sink(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}{char * data_copy=data;char * data=data_copy;if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}}
static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}
static void main(){{time_t time_val=time(NULL);switch (time_val % 4){case 0: printLine("0");break;case 1: printLine("1");break;default: printLine("default");break;}}}
static void main(){char * data;_union_type my_union;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}my_union.a=data;{char * data=my_union.b;{char src[100];strncpy(data, src, 100);data[100-1]='\0';printLine(data);}}}
static wchar_t * main_source(wchar_t * data){{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}return data;}static void main(){wchar_t * data;data=NULL;data=main_source(data);{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}
static void main(){int data;_union_type my_union;data=-1;data=ASSERT_VALUE+1;my_union.a=data;{int data=my_union.b;assert(data > ASSERT_VALUE);}}
static void main(){char data;data=' ';data=CHAR_MIN;_main_data=data;b_main_sink();}void b_main_sink(){char data=_main_data;{char result=0;if (data > CHAR_MIN){result=data-1;printHexCharLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static void main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=L"P";main_sink(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=(wchar_t *)calloc(100, sizeof(wchar_t));b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){if (data!=NULL){wcscpy(data, L"Initialize");printWLine(data);free(data);}}
static void main(){long long * data;data=NULL;data=new long long[100];main_sink_b(data);}void main_sink_b(long long * data){main_sink_c(data);}void main_sink_c(long long * data){main_sink_d(data);}void main_sink_d(long long * data){main_sink_e(data);}void main_sink_e(long long * data){delete [] data;}
static void main_source(wchar_t * &data){data=new wchar_t[100];}static void main(){wchar_t * data;data=NULL;main_source(data);{wchar_t src[100];wcsncat(data, src, 100);printWLine(data);delete [] data;}}
void b_main_sink(char * data);static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{char src[100];memcpy(data, src, 100*sizeof(char));printLine(data);}}
static void main_sink(int data){{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}static void main(){int data;void (*func_ptr) (int)=main_sink;fscanf (stdin, "%d", &data);func_ptr(data);}
static void main(){unsigned int data;data=0;data=b_main_source(data);{unsigned int result=data * data;printUnsignedLine(result);}}unsigned int b_main_source(unsigned int data){data=5;return data;}
void b_main_sink(int data_array[]);static void main(){int data;int data_array[5];data=-1;data=CHAR_MAX-5;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{char c=(char)data;printHexCharLine(c);}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;main_sink(&data);}void main_sink(void * void_data_ptr){twointsclass * * data_ptr=(twointsclass * *)void_data_ptr;twointsclass * data=(*data_ptr);delete data;}
static void main(){{if (fputc((int)'A', stdout)==EOF){printLine("fputc failed!");}}}
static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;{wchar_t dest[100];wmemset(dest, L'C', 100-1);memmove(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}void e_main_sink(wchar_t * data){main_vasink(data, data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
twointsclass * main_source(twointsclass * data);static void main(){twointsclass * data;data=NULL;data=main_source(data);printIntLine(data[0].a);}twointsclass * main_source(twointsclass * data){{twointsclass * tmp=new twointsclass;tmp->a=0;tmp->b=0;data=tmp;}return data;}
static void main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=100-1;func_ptr(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnvp(_P_WAIT, COMMAND_INT, args);}}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{wchar_t src[100];wcscat(data, src);printWLine(data);free(data);}}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));{size_t i, dest_sz;wchar_t dest[100];wmemset(dest, L'C', 100-1);dest_sz=wcslen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);free(data);}}
static void main_sink(char * data){{FILE *pipe;pipe=POPEN(data, "wb");if (pipe!=NULL) PCLOSE(pipe);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");func_ptr(data);}
static void main(){long long * data;data=NULL;{long long data_goodbuf[100];data=data_goodbuf;data[0]=5L;printLongLongLine(data[0]);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;{wchar_t * data_copy=data;wchar_t * data=data_copy;if (wcsncmp(PASSWORD, data, wcslen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}}
static void main(){twoints * data;data=NULL;data=main_source(data);free(data);}twoints * main_source(twoints * data){data=(twoints *)malloc(100*sizeof(twoints));return data;}
static unsigned int main_source(unsigned int data){data=UINT_MAX;return data;}static void main(){unsigned int data;data=0;data=main_source(data);{unsigned int result=-1;if (data < UINT_MAX){result=data+1;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main_sink(char * data){{char dest[100]="";SNPRINTF(dest, 100-1, "%s", data);printLine(dest);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}func_ptr(data);}
static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));main_sink(data);}void main_sink(char * data){free(data);}
static void main(){int * data;data=NULL;data=new int[100];delete [] data;main_sink_b(data);}void main_sink_b(int * data){main_sink_c(data);}void main_sink_c(int * data){main_sink_d(data);}void main_sink_d(int * data){main_sink_e(data);}void main_sink_e(int * data){}
static void main(){int * data;data=NULL;int data_good;data=&data_good;printIntLine(*data);main_sink(data);}void main_sink(int * data){}
void b_main_sink(short * data);static void main(){short data;data=0;data=100-1;b_main_sink(&data);}void b_main_sink(short * data_ptr){short data=*data_ptr;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
static twoints * main_source(twoints * data){{twoints tmp;tmp.a=0;tmp.b=0;data=&tmp;}return data;}static void main(){twoints * data;data=NULL;data=main_source(data);printStructLine(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t dest[100];wmemset(dest, L'C', 100-1);memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);free(data);}}
static void main(){long long * data;struct_type my_struct;data=NULL;data=new long long;delete data;my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){long long * data=my_struct.a;}
static void main(){twoints * data;data=NULL;data=main_source(data);delete data;}twoints * main_source(twoints * data){data=new twoints;return data;}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main_sink(char * data){if (data!=NULL){strcpy(data, "Initialize");printLine(data);free(data);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=(char *)calloc(100, sizeof(char));func_ptr(data);}
static void main(){char * data;_union_type my_union;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");my_union.a=data;{char * data=my_union.b;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}}
static void main_sink(unsigned char data){{unsigned char result=data+1;printHexUnsignedCharLine(result);}}static void main(){unsigned char data;void (*func_ptr) (unsigned char)=main_sink;data=' ';data=5;func_ptr(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){int data;data=7;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main(){int data;data=-1;data=5;b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{int result=data-1;printIntLine(result);}}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;func_ptr(data);}void b_main_sink(char * data){{char dest[100];memcpy(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
static void main(){int * data;data=NULL;if(global_returns_t_or_f()){data=new int[100];}else{data=new int[100];}if(global_returns_t_or_f()){delete [] data;}else{delete [] data;}}
static void main_sink(){char * data=_main_data;{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");_main_data=data;main_sink();}
static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=10;func_ptr(data);}void b_main_sink(int data){{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]=L'\0';printWLine(data);}}
static void main(){int data;int data_array[5];data=7;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);if (wcsstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[250]="PATH=";data=data_buf;strcat(data, NEW_PATH);b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){PUTENV(data);}
static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;strcat(data, "*.*");my_union.a=data;{char * data=my_union.b;_spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}}
static void main_sink(char * data){free(data);}static void main(){char * data;data=NULL;data=(char *)calloc(100, sizeof(char));main_sink(data);}
void b_main_sink(int data);static void main(){int data;data=-1;data=100-1;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void d_main_sink(int data);void c_main_sink(int data){d_main_sink(data);}void e_main_sink(int data);void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
void b_main_sink(int * data);static void main(){int * data;data=NULL;data=(int *)malloc(10*sizeof(int));b_main_sink(data);}void c_main_sink(int * data);void b_main_sink(int * data){c_main_sink(data);}void c_main_sink(int * data){{int data_src[10]={0};size_t i;for (i=0;i < 10;i++){data[i]=data_src[i];}printIntLine(data[0]);free(data);}}
void b_main_sink(int data);static void main(){int data;data=-1;data=100-1;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void d_main_sink(int data);void c_main_sink(int data){d_main_sink(data);}void e_main_sink(int data);void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main_sink(){char * data=main_data;{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}printLine(data);delete [] data;}}static void main(){char * data;data=NULL;data=new char[100];main_data=data;main_sink();}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;main_sink(data);}void main_sink(twointsclass * data){delete data;}
void b_main_sink(int data);static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=-1;data=CHAR_MAX-5;func_ptr(data);}void b_main_sink(int data){{char c=(char)data;printHexCharLine(c);}}
static void main_sink(){unsigned int data=_main_data;{unsigned int result=data * data;printUnsignedLine(result);}}static void main(){unsigned int data;data=0;data=5;_main_data=data;main_sink();}
static void main(){char * data;data=(char *)realloc(data, 100);{char * data_copy=data;char * data=data_copy;if (data!=NULL){strcpy(data, "Initialize");printLine(data);free(data);}}}
static void main_sink(wchar_t * data){{wchar_t src[100];wcsncat(data, src, 100);printWLine(data);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;func_ptr(data);}
void b_main_sink(_struct_type my_struct);static void main(){short data;_struct_type my_struct;data=0;data=100-1;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){short data=my_struct.a;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(data);}void b_main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(void * void_data_ptr);static void main(){char * data;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{char src[100];strcpy(data, src);printLine(data);}}
static void main(){char * data;data=NULL;{char mystring[]="mystring";data=strdup(mystring);}main_sink(&data);}void main_sink(char * * data_ptr){char * data=*data_ptr;free(data);}
static void main(){int data;data=-1;data=INT_MAX;b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{int result=-1;if (data <=(INT_MAX/2)){result=data * 2;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){unsigned char data;unsigned char *data_ptr1=&data;unsigned char *data_ptr2=&data;data=' ';{unsigned char data=*data_ptr1;fscanf (stdin, "%hc", &data);}{unsigned char data=*data_ptr2;{unsigned char result=-1;if (data <=(unsigned char)sqrt((unsigned char)UCHAR_MAX)){result=data * data;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
static void main(){int data;data=-1;data=RAND32();{int data_copy=data;int data=data_copy;{int result=-1;if (data <=(int)sqrt((int)INT_MAX)){result=data * data;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
void main_sink_b(twointsclass * data);static void main(){twointsclass * data;{twointsclass * data_buf=new twointsclass[100];{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}main_sink_b(data);}void main_sink_c(twointsclass * data);void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_d(twointsclass * data);void main_sink_c(twointsclass * data){main_sink_d(data);}void main_sink_d(twointsclass * data){printIntLine(data[0].a);delete [] data;}
void b_main_sink();static void main(){short data;data=0;data=100-1;_main_data=data;b_main_sink();}void b_main_sink(){short data=_main_data;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
void main_sink(char * * data);static void main(){char * data;data=NULL;data=new char[100];main_sink(&data);}void main_sink(char * * data_ptr){char * data=*data_ptr;{char src[100];strcat(data, src);printLine(data);delete [] data;}}
static void main(){int data;_struct_type my_struct;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{int result=-1;if (data <=(INT_MAX/2)){result=data * 2;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main_vasinkb(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, data, args);va_end(args);}}static void main_vasinkg(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, L"%s", args);va_end(args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}main_vasinkg(data, data);}
static void main(){int data;int data_array[5];data=-1;data=10000;data_array[2]=data;main_sink(data_array);}void main_sink(int data_array[]){int data=data_array[2];{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main_sink(wchar_t * data){{HMODULE hModule;hModule=LoadLibraryW(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"C:\\Windows\\System32\\winsrv.dll");func_ptr(data);}
static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;strcat(data, "*.*");my_union.a=data;{char * data=my_union.b;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnvp(_P_WAIT, COMMAND_INT, args);}}}
void b_main_sink(short * data);static void main(){short data;data=0;data=100-1;b_main_sink(&data);}void b_main_sink(short * data_ptr){short data=*data_ptr;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main_sink(unsigned int data){{unsigned int result=0;if (data > 0){result=data-1;printUnsignedLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}static void main(){unsigned int data;void (*func_ptr) (unsigned int)=main_sink;data=0;data=0;func_ptr(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void main_sink_b(char * data);static void main(){char * data;data=new char[100];main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_d(char * data);void main_sink_c(char * data){main_sink_d(data);}void main_sink_d(char * data){{char dest[50]="";size_t i, data_len;data_len=strlen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printLine(data);delete [] data;}}
static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));main_sink(data);}void main_sink(twoints * data){free(data);}
void main_sink(wchar_t * data){{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));printWLine(data);delete [] data;}}static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_sink(data);}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;my_union.a=data;{wchar_t * data=my_union.b;if (wcsncmp(PASSWORD, data, wcslen(data))==0) printLine("Access granted");else printLine("Access denied!");}}
static void main(){twointsclass data;data.a=1;data.b=2;printIntLine(data.a);printIntLine(data.b);}
static void main_sink(){short data=_main_data;{char c=(char)data;printHexCharLine(c);}}static void main(){short data;data=-1;data=CHAR_MAX-5;_main_data=data;main_sink();}
static void main_sink(){int data=_main_data;{int result=data-1;printIntLine(result);}}static void main(){int data;data=-1;data=5;_main_data=data;main_sink();}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;func_ptr(data);}void b_main_sink(char * data){{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}printLine(data);}}
static void main(){char data;data=' ';data=5;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * data_ptr=(char *)void_data_ptr;char data=(*data_ptr);{char result=data * 2;printHexCharLine(result);}}
static void main_sink(){long long * data=_main_data;printLongLongLine(data[0]);}static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));{size_t i;for(i=0;i < 100;i++){data[i]=5L;}}_main_data=data;main_sink();}
void main_sink_b(char * data);static void main(){char * data;data=new char[100];main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){{char dest[50]="";strncat(dest, data, strlen(data));printLine(data);delete [] data;}}
static void main_sink(char data){{char result=data * 2;printHexCharLine(result);}}static void main(){char data;data=' ';data=5;main_sink(data);}
static void main(){int data;data=-1;if(global_returns_t_or_f()){data=20;}else{data=20;}if(global_returns_t_or_f()){{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}else{{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}}
static void main_source(long long * &data){{long long * data_buf=new long long[100];{size_t i;for (i=0;i < 100;i++){data_buf[i]=5L;}}data=data_buf;}}static void main(){long long * data;main_source(data);printLongLongLine(data[0]);delete [] data;}
static void main(){twointsclass * data;data=NULL;data=NULL;data=(twointsclass *)realloc(data, 100*sizeof(twointsclass));free(data);}
static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));if(global_returns_t_or_f()){data=data_goodbuf;}else{data=data_goodbuf;}{char src[100];memcpy(data, src, 100*sizeof(char));printLine(data);}}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"C:\\Windows\\System32\\winsrv.dll");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{HMODULE hModule;hModule=LoadLibraryW(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
static void main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}main_sink(data);}
void b_main_sink(void * void_data_ptr);static void main(){int data;data=-1;data=7;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);printIntLine(100/data);}
void b_main_sink();static void main(){wchar_t * password;password=L"";password=(wchar_t *)malloc(100*sizeof(wchar_t));if(!VirtualLock(password, 100*sizeof(wchar_t))){printLine("Memory could not be locked");exit(1);}wcscpy(password, L"Password1234!");_main_data=password;b_main_sink();}void b_main_sink(){wchar_t * password=_main_data;{HANDLE pHandle;wchar_t * username=L"User";wchar_t * domain=L"Domain";if (LogonUserW( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}
void b_main_sink(int * data);static void main(){int * data;{int * data_buf=(int *)malloc(100*sizeof(int));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}b_main_sink(data);}void b_main_sink(int * data){printIntLine(data[0]);free(data);}
static void main(){twointsclass * data;data=NULL;data=(twointsclass *)calloc(100, sizeof(twointsclass));main_sink_b(data);}void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_c(twointsclass * data){free(data);}
static void main_source(twointsclass * &data){data=new twointsclass;}static void main(){twointsclass * data;data=NULL;main_source(data);delete data;}
static void main_source(char * &data){data=new char;}static void main(){char * data;data=NULL;main_source(data);delete data;}
static void main_sink(){int * data=_main_data;{int data_src[10]={0};size_t i;for (i=0;i < 10;i++){data[i]=data_src[i];}printIntLine(data[0]);free(data);}}static void main(){int * data;data=NULL;data=(int *)malloc(10*sizeof(int));_main_data=data;main_sink();}
static void main(){int * data;data=NULL;data=(int *)calloc(100, sizeof(int));{int * data_copy=data;int * data=data_copy;free(data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;data->a=0;data->b=0;printIntLine(data->a);printIntLine(data->b);main_sink(&data);}void main_sink(void * void_data_ptr){twointsclass * * data_ptr=(twointsclass * *)void_data_ptr;twointsclass * data=(*data_ptr);delete data;}
static void main(){long long * data;struct_type my_struct;data=NULL;data=new long long[100];my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){long long * data=my_struct.a;delete [] data;}
static void main(){int data;if(global_returns_t_or_f()){data=10;}else{data=10;}if(global_returns_t_or_f()){{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}else{{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];delete [] data;}
static void main_sink(int data){{int result=data-1;printIntLine(result);}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=5;func_ptr(data);}
static void main(){unsigned char data;unsigned char data_array[5];data=' ';data=5;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(unsigned char data_array[]){unsigned char data=data_array[2];{unsigned char result=data+1;printHexUnsignedCharLine(result);}}
void b_main_sink(int data_array[]);static void main(){int data;int data_array[5];data=-1;data=ASSERT_VALUE+1;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];assert(data > ASSERT_VALUE);}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){if (strstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(twoints * data);static void main(){twoints * data;twoints * data_badbuf=(twoints *)ALLOCA(50*sizeof(twoints));twoints * data_goodbuf=(twoints *)ALLOCA(100*sizeof(twoints));data=data_goodbuf;b_main_sink(data);}void c_main_sink(twoints * data);void b_main_sink(twoints * data){c_main_sink(data);}void c_main_sink(twoints * data){{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memcpy(data, src, 100*sizeof(twoints));printStructLine(&data[0]);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{wchar_t src[100];wcsncpy(data, src, 100);data[100-1]=L'\0';printWLine(data);}}
static void main(){int count;int count_array[5];count=-1;count=20;count_array[2]=count;b_main_sink(count_array);}void b_main_sink(int count_array[]){int count=count_array[2];{size_t i=0;FILE *file=NULL;const char *filename="output_bad.txt";file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}
static void main(){FILE * data;data=NULL;data=fopen("BadSource_fopen.txt", "w+");if(global_returns_t_or_f()){if (data!=NULL){fclose(data);}}else{if (data!=NULL){fclose(data);}}}
static void main(){wchar_t * data;wchar_t * &data_ref=data;data=new wchar_t[100];{wchar_t * data=data_ref;{wchar_t dest[50]=L"";wcscat(dest, data);printWLine(data);delete [] data;}}}
static void main(){int data;fscanf (stdin, "%d", &data);b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){int data;void (*func_ptr) (int)=b_main_sink;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}func_ptr(data);}void b_main_sink(int data){{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){int data;int data_array[5];data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{int result=-1;if (data < INT_MAX){result=data+1;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static long long * main_source(long long * data){data=new long long[100];return data;}static void main(){long long * data;data=NULL;data=main_source(data);delete [] data;}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");func_ptr(data);}void b_main_sink(char * data){{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;wprintf(data);}
static void main(){char data;data=' ';fscanf (stdin, "%c", &data);b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * data_ptr=(char *)void_data_ptr;char data=(*data_ptr);{char result=-1;if (data <=(char)sqrt((char)CHAR_MAX)){result=data * data;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
void _main_sink(wchar_t * data){EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_sink(data);}
static void main_vasinkb(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, data, args);va_end(args);}}static void main_vasinkg(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, L"%s", args);va_end(args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}main_vasinkg(data, data);}
void main_sink_b(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_sink_b(data);}void main_sink_c(wchar_t * data);void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_d(wchar_t * data);void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_d(wchar_t * data){{wchar_t src[100];wcscat(data, src);printWLine(data);delete [] data;}}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[250]=L"PATH=";data=data_buf;wcscat(data, NEW_PATH);my_union.a=data;{wchar_t * data=my_union.b;PUTENV(data);}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;delete data;main_data=data;main_sink();}void main_sink(){twointsclass * data=main_data;}
static void main(){char * password;char * *password_ptr1=&password;char * *password_ptr2=&password;char password_buf[100]="";password=password_buf;{char * password=*password_ptr1;{size_t password_len=0;fgets(password, 100, stdin);password_len=strlen(password);if (password_len > 0){password[password_len-1]='\0';}}}{char * password=*password_ptr2;{HANDLE pHandle;char * username="User";char * domain="Domain";if (LogonUserA( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}}
static void main_sink(twoints * data){}static void main(){twoints * data;void (*func_ptr) (twoints *)=main_sink;data=NULL;twoints data_good;data=&data_good;data->a=0;data->b=0;printStructLine(data);func_ptr(data);}
static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t dest[50]=L"";memcpy(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);}}}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");my_union.a=data;{wchar_t * data=my_union.b;{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}}
void main_sink_b(wchar_t * data);static void main(){wchar_t * data;{wchar_t * data_buf=new wchar_t[100];data=data_buf;}main_sink_b(data);}void main_sink_c(wchar_t * data);void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){printWLine(data);delete [] data;}
static void main(){{int * data;data=new int;int * * pointer=new int *;{int * data=*pointer;printIntLine(*data);}delete pointer;}}
static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=7;func_ptr(data);}void b_main_sink(int data){{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main(){int * data;union_type my_union;data=NULL;data=new int;my_union.a=data;{int * data=my_union.b;delete data;}}
static void main(){char * data;data=(char *)malloc(100*sizeof(char));if(global_returns_t_or_f()){}else{}{char dest[50]="";_snprintf(dest, strlen(data), "%s", data);printLine(data);free(data);}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;data=PASSWORD;}{wchar_t * data=*data_ptr2;if (wcsncmp(PASSWORD, data, wcslen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");b_main_sink(data);}void b_main_sink(wchar_t * data){{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
void _main_sink(wchar_t * data){PUTENV(data);}static void main(){wchar_t * data;wchar_t data_buf[250]=L"PATH=";data=data_buf;wcscat(data, NEW_PATH);_main_sink(data);}
static void main(){int data;data=-1;data=10000;{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}
void b_main_sink(char * data);static void main(){char * data;data=(char *)malloc(100*sizeof(char));b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{char dest[50]="";_snprintf(dest, strlen(data), "%s", data);printLine(data);free(data);}}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf(data, args);va_end(args);}}static void main(){char * data;void (*func_ptr) (char *, ...)=main_vasink;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");func_ptr(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=(wchar_t *)malloc(100);b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){if (data!=NULL){wcscpy(data, L"Initialize");printWLine(data);free(data);}}
static void main(){int data;data=b_main_source(data);{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0 && data < 10){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}int b_main_source(int data){{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}return data;}
static void main(){long long * data;data=(long long *)calloc(100, sizeof(long long));if (data!=NULL){data[0]=5L;printLongLongLine(data[0]);free(data);}}
static void main(){short data;data=-1;data=CHAR_MAX-5;{char c=(char)data;printHexCharLine(c);}}
static void main_sink(){char * data=main_data;free(data);}static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));main_data=data;main_sink();}
static void main_sink(wchar_t * data){{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");func_ptr(data);}
static void main(){int * data;{int * data_buf=new int[100];{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}printIntLine(data[0]);delete [] data;}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]="";data=data_buf;strcat(data, "*.*");func_ptr(data);}void b_main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
static void main_sink(twoints * data){delete data;}static void main(){twoints * data;void (*func_ptr) (twoints *)=main_sink;data=NULL;data=new twoints;func_ptr(data);}
void main_sink(int * data_array[]);static void main(){int * data;int * data_array[5];{int * data_buf=new int[100];{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}data_array[2]=data;main_sink(data_array);}void main_sink(int * data_array[]){int * data=data_array[2];printIntLine(data[0]);delete [] data;}
static void main_sink(){wchar_t * data=_main_data;wprintf(L"%s\n", data);}static void main(){wchar_t * data;data=NULL;data=L"Good";_main_data=data;main_sink();}
void b_main_sink();static void main(){int data;data=-1;data=OPEN("BadSource_open.txt", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);_bad_data_for_good_sink=data;b_main_sink();}void b_main_sink(){int data=_bad_data_for_good_sink;if (data!=-1){CLOSE(data);}}
static void main(){unsigned char data;void (*func_ptr) (unsigned char)=b_main_sink;data=' ';data=5;func_ptr(data);}void b_main_sink(unsigned char data){{unsigned char result=data * 2;printHexUnsignedCharLine(result);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{wchar_t data_src[10+1]=SRC_STRING;wcscpy(data, data_src);printWLine(data);free(data);}}
static void main(){char * data;data=NULL;data=new char;{char * data_copy=data;char * data=data_copy;delete data;}}
static void main(){int data;data=-1;data=CHAR_MAX-5;{short s=(short)data;printf("%hd\n", s);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t src[100];wcsncat(data, src, 100);printWLine(data);}}
static void main(){int count;count=-1;count=20;b_main_sink(count);}void b_main_sink(int count){c_main_sink(count);}void c_main_sink(int count){d_main_sink(count);}void d_main_sink(int count){e_main_sink(count);}void e_main_sink(int count){{size_t i=0;FILE *file=NULL;const char *filename="output_bad.txt";file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}
static void main(){int data;_union_type my_union;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}my_union.a=data;{int data=my_union.b;{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than the length of the source string or too large");}}}}
static void main(){unsigned int data;data=0;data=5;{unsigned int result=data * data;printUnsignedLine(result);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}{int i, n, v;if (swscanf(data, L"%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t src[100];wcsncpy(data, src, 100);printWLine(data);}}
static void main(){long long * data;data=NULL;{long long data_goodbuf[100];data=data_goodbuf;data[0]=5L;printLongLongLine(data[0]);}b_main_sink(data);}void b_main_sink(long long * data){c_main_sink(data);}void c_main_sink(long long * data){d_main_sink(data);}void d_main_sink(long long * data){}
static wchar_t * main_source(wchar_t * data){data=(wchar_t *)malloc(100*sizeof(wchar_t));return data;}static void main(){wchar_t * data;data=NULL;data=main_source(data);{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));printWLine(data);free(data);}}
static void main(){long long * data;long long * data_badbuf=(long long *)ALLOCA(50*sizeof(long long));long long * data_goodbuf=(long long *)ALLOCA(100*sizeof(long long));if(global_returns_t_or_f()){data=data_goodbuf;}else{data=data_goodbuf;}{memcpy(data, src, 100*sizeof(long long));printLongLongLine(data[0]);}}
static void main(){unsigned char data;data=' ';data=5;{unsigned char result=data+1;printHexUnsignedCharLine(result);}}
static void main(){wchar_t * data;data=NULL;{wchar_t mystring[]=L"mystring";data=wcsdup(mystring);}main_sink(data);}void main_sink(wchar_t * data){free(data);}
void _main_sink(bad_struct data){* */prev=data.list.prev;next=data.list.next;prev->next=next;next->prev=prev;}static void main(){bad_struct data;linked_list head={&head, &head};data.list.next=head.next;data.list.prev=&head;head.next=&data.list;head.next->prev=&data.list;_main_sink(data);}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, GOOD_OS_COMMAND);my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}
static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));data[0]=L'\0';{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}{size_t i;for (i=0;i < wcslen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100];data=data_buf;func_ptr(data);}void b_main_sink(char * data){{char dest[50]="";memmove(dest, data, strlen(data)*sizeof(char));printLine(data);}}
void main_sink(char * data){{char src[100];memmove(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}main_sink(data);}
static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));b_main_sink(data);}void b_main_sink(long long * data){free(data);}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);_wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}wchar_t * b_main_source(wchar_t * data){wcscat(data, L"*.*");return data;}
static void main(){char * data;char * &data_ref=data;data=NULL;data=new char[100];{char * data=data_ref;{char src[100];memmove(data, src, 100*sizeof(char));printLine(data);delete [] data;}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}b_main_sink(data);}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, L"%s", args);va_end(args);printWLine(dest);}}void b_main_sink(wchar_t * data){main_vasink(data, data);}
char * main_source(char * data);static void main(){char * data;data=new char[100];data=main_source(data);{char dest[50]="";strcat(dest, data);printLine(data);delete [] data;}}char * main_source(char * data){return data;}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=NULL;{char * data=*data_ptr1;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}}{char * data=*data_ptr2;{char dest[100];memcpy(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}}
static void main(){twoints * data;data=NULL;data=NULL;data=(twoints *)realloc(data, 100*sizeof(twoints));main_sink(&data);}void main_sink(void * void_data_ptr){twoints * * data_ptr=(twoints * *)void_data_ptr;twoints * data=(*data_ptr);free(data);}
static void main(){int data;data=-1;data=RAND32();{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than the length of the source string or too large");}}}
void b_main_sink(short data);static void main(){short data;data=0;data=100-1;b_main_sink(data);}void b_main_sink(short data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
void b_main_sink(int data);static void main(){int data;data=-1;data=CHAR_MAX-5;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){{char c=(char)data;printHexCharLine(c);}}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{int i, n, v;if (swscanf(data, L"%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static void main(){char * data;data=NULL;if(global_returns_t_or_f()){data=new char;}else{data=new char;}if(global_returns_t_or_f()){delete data;}else{delete data;}}
void b_main_sink();static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{wchar_t dest[100];memcpy(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){int data;data=7;b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main(){twointsclass data;data.a=1;data.b=2;printIntLine(data.a);printIntLine(data.b);}
void b_main_sink(int data);static void main(){int data;data=-1;data=100-1;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void d_main_sink(int data);void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
void b_main_sink();static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;_spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){twoints * data;twoints * data_array[5];data=NULL;data=new twoints;data_array[2]=data;main_sink(data_array);}void main_sink(twoints * data_array[]){twoints * data=data_array[2];delete data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, L"%s", data);printWLine(dest);}}
void b_main_sink(short * data);static void main(){short data;data=0;data=100-1;b_main_sink(&data);}void b_main_sink(short * data_ptr){short data=*data_ptr;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
void main_sink(wchar_t * data){{wchar_t dest[50]=L"";memmove(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);delete [] data;}}static void main(){wchar_t * data;data=new wchar_t[100];main_sink(data);}
static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));{char * data_copy=data;char * data=data_copy;{char src[100];memcpy(data, src, 100*sizeof(char));printLine(data);free(data);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_t_or_f()){{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}}else{{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}}if(global_returns_t_or_f()){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}else{if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}}
static void main(){long long * data;data=NULL;{long long tmp=5L;data=&tmp;}printLongLongLine(*data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"15");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main(){twoints * data;data=NULL;data=new twoints;main_sink_b(data);}void main_sink_b(twoints * data){main_sink_c(data);}void main_sink_c(twoints * data){main_sink_d(data);}void main_sink_d(twoints * data){delete data;}
void main_sink_b(char * data);static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_d(char * data);void main_sink_c(char * data){main_sink_d(data);}void main_sink_d(char * data){{char dest[100];memmove(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
static void main(){int data;data=-1;data=20;b_main_sink(data);}void b_main_sink(int data){{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}
static void main(){twoints * data;data=NULL;data=new twoints[100];main_sink_b(data);}void main_sink_b(twoints * data){main_sink_c(data);}void main_sink_c(twoints * data){delete [] data;}
static void main(){int data;data=b_main_source(data);{wchar_t data_buf[10]=L"AAAAAAAAA";if (data >=0){printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}int b_main_source(int data){data=7;return data;}
static void main(){unsigned char data;_union_type my_union;data=' ';data=(unsigned char)rand();my_union.a=data;{unsigned char data=my_union.b;{unsigned char result=-1;if (data < UCHAR_MAX){result=data+1;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
static void main(){long long * data;_struct_type my_struct;data=NULL;data=(long long *)malloc(100*sizeof(long long));free(data);my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){long long * data=my_struct.a;}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100];data=data_buf;func_ptr(data);}void b_main_sink(char * data){{char dest[50]="";size_t i, data_len;data_len=strlen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printLine(data);}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]=FULL_COMMAND;data=data_buf;{char * data=*data_ptr1;strcat(data, "*.*");}{char * data=*data_ptr2;system(data);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t dest[50]=L"";size_t i, data_len;data_len=wcslen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printWLine(data);}}
static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, L"%s", args);va_end(args);printWLine(dest);}}static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}}{wchar_t * data=*data_ptr2;main_vasink(data, data);}}
void b_main_sink(char * data);static void main(){char * data;data=(char *)malloc(100*sizeof(char));b_main_sink(data);}void b_main_sink(char * data){{char dest[50]="";strcat(dest, data);printLine(data);free(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;if (wcsncmp(PASSWORD, data, wcslen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");{char * data_copy=data;char * data=data_copy;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnvp(_P_WAIT, COMMAND_INT, args);}}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=NULL;{char * data=*data_ptr1;data=(char *)malloc(100*sizeof(char));}{char * data=*data_ptr2;{size_t i, dest_sz;char dest[100];memset(dest, 'C', 100-1);dest_sz=strlen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);free(data);}}}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}my_struct.a=data;b_main_sink(my_struct);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, L"%s", args);va_end(args);}}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;main_vasink(data, data);}
static void main(){FILE * data;data=fopen("BadSource_fopen.txt", "w+");fclose(data);b_main_sink(data);}void b_main_sink(FILE * data){c_main_sink(data);}void c_main_sink(FILE * data){d_main_sink(data);}void d_main_sink(FILE * data){e_main_sink(data);}void e_main_sink(FILE * data){}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';{wchar_t * data=*data_ptr1;data=data_buf;}{wchar_t * data=*data_ptr2;{wchar_t dest[100];wcsncpy(dest, data, wcslen(dest));dest[100-1]=L'\0';printWLine(dest);}}}
static void main(){char * data;_union_type my_union;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}my_union.a=data;{char * data=my_union.b;{char dest[100];strcpy(dest, data);printLine(dest);}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
void main_sink(struct_type my_struct);static void main(){wchar_t * data;struct_type my_struct;data=new wchar_t[100];my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){wchar_t * data=my_struct.a;{wchar_t dest[50]=L"";wcsncat(dest, data, wcslen(data));printWLine(data);delete [] data;}}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf(data, args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");{char * data_copy=data;char * data=data_copy;main_vasink(data, data);}}
static void main(){int data;data=-1;data=5;_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{int result=data+1;printIntLine(result);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
static void main_sink(wchar_t * data){{wchar_t data_src[10+1]=SRC_STRING;wcsncpy(data, data_src, wcslen(data_src));printWLine(data);free(data);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=NULL;data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));func_ptr(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"C:\\Windows\\System32\\winsrv.dll");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{HMODULE hModule;hModule=LoadLibraryW(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));free(data);}
static void main(){long long * data;long long * data_array[5];data=NULL;data=NULL;data=(long long *)realloc(data, 100*sizeof(long long));data_array[2]=data;main_sink(data_array);}void main_sink(long long * data_array[]){long long * data=data_array[2];free(data);}
static void main(){{int x;int y;x=(rand() % 3);y=0;if (x==0){printLine("x==0");y=1;}if (y) printLine("x was 0\n");}}
static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];fwprintf(stdout, L"%s\n", data);}
static void main(){int data;data=-1;fscanf (stdin, "%d", &data);b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static char * main_source(char * data){{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}return data;}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){wchar_t * data;wchar_t * &data_ref=data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}{wchar_t * data=data_ref;{wchar_t dest[100];wcscpy(dest, data);printWLine(dest);}}}
static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;{char src[100];memcpy(data, src, 100*sizeof(char));printLine(data);}}
static void main(){twointsclass * data;twointsclass * *data_ptr1=&data;twointsclass * *data_ptr2=&data;data=NULL;{twointsclass * data=*data_ptr1;data=new twointsclass;}{twointsclass * data=*data_ptr2;delete data;}}
static void main(){int data;data=-1;data=5;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){{int result=data-1;printIntLine(result);}}
static void main_sink(twoints * data){{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memmove(data, src, 100*sizeof(twoints));printStructLine(&data[0]);free(data);}}static void main(){twoints * data;void (*func_ptr) (twoints *)=main_sink;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));func_ptr(data);}
static void main(){short data;data=0;data=100-1;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t src[100];wcsncpy(data, src, 100);printWLine(data);}}
static void main(){int data;data=-1;data=RAND32();b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);{int result=-1;if (data <=(INT_MAX/2)){result=data * 2;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){if(global_returns_t_or_f()){{int data;data=5;int * pointer=new int;{int data=*pointer;printIntLine(data);}delete pointer;}}else{{int data;data=5;int * pointer=new int;{int data=*pointer;printIntLine(data);}delete pointer;}}}
void _main_sink(char * data){{char dest[50]="";memcpy(dest, data, strlen(data)*sizeof(char));printLine(data);}}static void main(){char * data;char data_buf[100];data=data_buf;_main_sink(data);}
static void main(){wchar_t * password;wchar_t password_buf[100]=L"";password=password_buf;if(global_returns_t_or_f()){wcscpy(password, L"Password1234!");}else{wcscpy(password, L"Password1234!");}{HANDLE pHandle;wchar_t * username=L"User";wchar_t * domain=L"Domain";if (LogonUserW( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}
static void main(){HANDLE data;data=INVALID_HANDLE_VALUE;data=CreateFile("BadSource_w32CreateFile.txt", (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (data!=INVALID_HANDLE_VALUE){CloseHandle(data);}}
static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
static void main(){void * data;void (*func_ptr) (void *)=b_main_sink;data=NULL;data=WIDE_STRING;func_ptr(data);}void b_main_sink(void * data){{size_t data_len=wcslen((wchar_t *)data);void * data_dest=(void *)calloc(data_len+1, sizeof(wchar_t));memcpy(data_dest, data, (data_len+1)*sizeof(wchar_t));printWLine((wchar_t *)data_dest);free(data_dest);}}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;wcscat(data, L"*.*");}{wchar_t * data=*data_ptr2;_wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}}
static void main(){double * data;double data_uninit_array[10];data=data_uninit_array;b_main_sink(&data);}void b_main_sink(double * * data_ptr){double * data=*data_ptr;{int i;for(i=0;i<10;i++){data[i]=(double)i;}}{int i;for(i=0;i<10;i++){printDoubleLine(data[i]);}}}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;if(global_returns_t_or_f()){wcscat(data, L"file.txt");}else{wcscat(data, L"file.txt");}{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){int data;_struct_type my_struct;data=-1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{int result=-1;if (data < INT_MAX){result=data+1;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *, ...)=b_main_vasink;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");func_ptr(data);}void b_main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(data, args);va_end(args);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, L"%s", args);va_end(args);printWLine(dest);}}void e_main_sink(wchar_t * data){main_vasink(data, data);}
static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t src[100];_snwprintf(data, 100, L"%s", src);printWLine(data);}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){int data;fscanf (stdin, "%d", &data);b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{char data_buf[10]="AAAAAAAAA";{printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){long long * data;long long * *data_ptr1=&data;long long * *data_ptr2=&data;data=NULL;{long long * data=*data_ptr1;data=NULL;data=(long long *)realloc(data, 100*sizeof(long long));}{long long * data=*data_ptr2;free(data);}}
void main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;{wchar_t * data_buf=new wchar_t[100];data=data_buf;}func_ptr(data);}void main_sink(wchar_t * data){printWLine(data);delete [] data;}
static void main(){int data;_union_type my_union;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}my_union.a=data;{int data=my_union.b;{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than the length of the source string or too large");}}}}
static void main(){wchar_t * data;data=NULL;data=L"Good";wprintf(L"%s\n", data);}
void main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}data_array[2]=data;main_sink(data_array);}void main_sink(char * data_array[]){char * data=data_array[2];{char src[100];strcpy(data, src);printLine(data);}}
static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));{wchar_t dest[50]=L"";size_t i, data_len;data_len=wcslen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printWLine(data);free(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, L"%s", data);printWLine(dest);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}{wchar_t * data_copy=data;wchar_t * data=data_copy;if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}}
void b_main_sink(int data);static void main(){int data;data=-1;data=100-1;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
static int main_source(int data){data=20;return data;}static void main(){int data;data=-1;data=main_source(data);{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}
static void main_sink(){int data=_main_data;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}static void main(){int data;data=-1;data=100-1;_main_data=data;main_sink();}
static void main(){int data;struct_type my_struct;data=-1;fscanf (stdin, "%d", &data);my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){int data=my_struct.a;{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){twointsclass * data;twointsclass * data_array[5];data=NULL;data=new twointsclass[100];data_array[2]=data;main_sink(data_array);}void main_sink(twointsclass * data_array[]){twointsclass * data=data_array[2];delete [] data;}
void b_main_sink(_struct_type my_struct);static void main(){bad_struct data;_struct_type my_struct;linked_list head={&head, &head};data.list.next=head.next;data.list.prev=&head;head.next=&data.list;head.next->prev=&data.list;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){bad_struct data=my_struct.a;* */prev=data.list.prev;next=data.list.next;prev->next=next;next->prev=prev;}
static void main(){int data;_union_type my_union;data=-1;data=INT_MAX;my_union.a=data;{int data=my_union.b;{int result=-1;if (data <=(int)sqrt((int)INT_MAX)){result=data * data;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
static void main(){short data;data=0;data=100-1;{short data_copy=data;short data=data_copy;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}}
static void main(){char * data;void (*func_ptr) (char *, ...)=b_main_vasink;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}void b_main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, "%s", args);va_end(args);printLine(dest);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
static void main(){int data;data=-1;data=20;{size_t i;int *b;b=(int*)malloc(data * sizeof(int));for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);free(b);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]='\0';printLine(data);}}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}main_sink_b(data);}void main_sink_b(int data){main_sink_c(data);}void main_sink_c(int data){{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static int main_source(int data){fscanf (stdin, "%d", &data);return data;}static void main(){int data;data=-1;data=main_source(data);{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than the length of the source string or too large");}}}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(data, args);va_end(args);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *, ...)=main_vasink;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");func_ptr(data);}
static void main(){wchar_t * data;_union_type my_union;data=(wchar_t *)malloc(100*sizeof(wchar_t));my_union.a=data;{wchar_t * data=my_union.b;{wchar_t dest[50]=L"";memmove(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);free(data);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"15");{wchar_t * data_copy=data;wchar_t * data=data_copy;{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;{char dest[100];memcpy(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnvp(_P_WAIT, COMMAND_INT, args);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(short data);static void main(){short data;void (*func_ptr) (short)=b_main_sink;data=0;data=100-1;func_ptr(data);}void b_main_sink(short data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
void b_main_sink(char * * data);static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char dest[50]="";memmove(dest, data, strlen(data)*sizeof(char));printLine(data);}}
static void main_sink(wchar_t * data){{wchar_t dest[100];wcsncpy(dest, data, wcslen(dest));dest[100-1]=L'\0';printWLine(dest);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;func_ptr(data);}
void b_main_sink(long long * data_array[]);static void main(){long long * data;long long * data_array[5];data=NULL;data=(long long *)malloc(sizeof(*data));data_array[2]=data;b_main_sink(data_array);}void b_main_sink(long long * data_array[]){long long * data=data_array[2];printLongLongLine(*data);free(data);}
static void main(){twointsclass data;twointsclass &data_ref=data;{twointsclass data=data_ref;data.a=1;data.b=2;printIntLine(data.a);printIntLine(data.b);}}
void b_main_sink(int * data_array[]);static void main(){int * data;int * data_array[5];int data_badbuf[50];int data_goodbuf[100];data=data_goodbuf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int * data_array[]){int * data=data_array[2];{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printIntLine(data[0]);}}}
static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;if(global_returns_t_or_f()){strcat(data, "*.*");}else{strcat(data, "*.*");}system(data);}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;wcscpy(data, L"fixedstringtest");}{wchar_t * data=*data_ptr2;fwprintf(stdout, data);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){int data;data=-1;data=7;printIntLine(100/data);}
void b_main_sink(int data);static void main(){int data;data=-1;data=ASSERT_VALUE+1;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void d_main_sink(int data);void c_main_sink(int data){d_main_sink(data);}void e_main_sink(int data);void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){assert(data > ASSERT_VALUE);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){wprintf(L"%s\n", data);}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;data=NULL;{wchar_t * data=*data_ptr1;{wchar_t data_goodbuf[100];data=data_goodbuf;wcscpy(data, L"A String");printWLine(data);}}{wchar_t * data=*data_ptr2;}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(&data);}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);main_vasink(data, data);}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;_wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
void b_main_sink(twoints * data);static void main(){twoints * data;void (*func_ptr) (twoints *)=b_main_sink;data=(twoints *)calloc(100, sizeof(twoints));func_ptr(data);}void b_main_sink(twoints * data){if (data!=NULL){data[0].a=1;data[0].b=1;printStructLine(&data[0]);free(data);}}
void b_main_sink(short data);static void main(){short data;data=0;data=100-1;b_main_sink(data);}void c_main_sink(short data);void b_main_sink(short data){c_main_sink(data);}void d_main_sink(short data);void c_main_sink(short data){d_main_sink(data);}void e_main_sink(short data);void d_main_sink(short data){e_main_sink(data);}void e_main_sink(short data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
static void main(){int data;data=-1;fscanf (stdin, "%d", &data);b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){{int result=-1;if (data <=(INT_MAX/2)){result=data * 2;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){char * data;char * &data_ref=data;data=NULL;data=new char[100];{char * data=data_ref;{char dest[100];memset(dest, 'C', 100-1);memmove(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);delete [] data;}}}
static void main(){int data;data=-1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}b_main_sink(data);}void b_main_sink(int data){{int result=-1;if (data < INT_MAX){result=data+1;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
void main_sink(void * void_data_ptr);static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];main_sink(&data);}void main_sink(void * void_data_ptr){twointsclass * * data_ptr=(twointsclass * *)void_data_ptr;twointsclass * data=(*data_ptr);{twointsclass src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memcpy(data, src, 100*sizeof(twointsclass));printIntLine(data[0].a);delete [] data;}}
static void main(){int data;data=-1;if(global_returns_t_or_f()){data=100-1;}else{data=100-1;}{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
static void main(){struct _twoints * data;struct _twoints * *data_ptr1=&data;struct _twoints * *data_ptr2=&data;data=NULL;{struct _twoints * data=*data_ptr1;struct _twoints data_good;data=&data_good;data->a=0;data->b=0;printStructLine((twoints *)data);}{struct _twoints * data=*data_ptr2;}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];{wchar_t * data_copy=data;wchar_t * data=data_copy;delete [] data;}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;fprintf(stdout, "%s\n", data);}
static void main_sink(){int * data=main_data;delete data;}static void main(){int * data;data=NULL;data=new int;main_data=data;main_sink();}
static void main(){int data;_struct_type my_struct;data=-1;data=5;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{int result=data * 2;printIntLine(result);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);fprintf(stdout, "%s\n", data);}char * b_main_source(char * data){{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}return data;}
static void main(){int data;data=7;{int data_copy=data;int data=data_copy;{wchar_t data_buf[10]=L"AAAAAAAAA";if (data >=0){printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;if(global_returns_t_or_f()){strcpy(data, "fixedstringtest");}else{strcpy(data, "fixedstringtest");}if(global_returns_t_or_f()){printf(data);}else{printf(data);}}
static void main(){int data;data=-1;data=RAND32();b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){{int result=-1;if (data < INT_MAX){result=data+1;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){int data;data=-1;data=main_source(data);{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}int main_source(int data){data=20;return data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;if(global_returns_t_or_f()){strcat(data, "*.*");}else{strcat(data, "*.*");}EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static wchar_t * main_source(wchar_t * data){{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}return data;}static void main(){wchar_t * data;data=NULL;data=main_source(data);{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]=L'\0';printWLine(data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "C:\\Windows\\System32\\winsrv.dll");{HMODULE hModule;hModule=LoadLibraryA(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
static void main(){unsigned int data;void (*func_ptr) (unsigned int)=b_main_sink;data=0;data=UINT_MAX;func_ptr(data);}void b_main_sink(unsigned int data){{unsigned int result=-1;if (data <=(UINT_MAX/2)){result=data * 2;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main_sink(long long * data){if (data!=NULL){data[0]=5L;printLongLongLine(data[0]);free(data);}}static void main(){long long * data;data=(long long *)calloc(100, sizeof(long long));main_sink(data);}
static void main(){wchar_t * data;wchar_t * &data_ref=data;data=NULL;data=new wchar_t[100];{wchar_t * data=data_ref;{wchar_t src[100];wcscpy(data, src);printWLine(data);delete [] data;}}}
static void main(){int * data;data=NULL;data=(int *)calloc(100, sizeof(int));main_sink(&data);}void main_sink(void * void_data_ptr){int * * data_ptr=(int * *)void_data_ptr;int * data=(*data_ptr);free(data);}
static void main_source(twointsclass * &data){data=new twointsclass;}static void main(){twointsclass * data;data=NULL;main_source(data);delete data;}
static void main(){long long * data;data=NULL;data=new long long;delete data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;wprintf(L"%s\n", data);}
void b_main_sink(short data);static void main(){short data;void (*func_ptr) (short)=b_main_sink;data=-1;data=CHAR_MAX-5;func_ptr(data);}void b_main_sink(short data){{char c=(char)data;printHexCharLine(c);}}
static void main_sink(char * data){{HMODULE hModule;hModule=LoadLibraryA(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;strcpy(data, "C:\\Windows\\System32\\winsrv.dll");func_ptr(data);}
static void main(){char * data;union_type my_union;data=NULL;data=new char;delete data;my_union.a=data;{char * data=my_union.b;}}
static void main(){int count;count=-1;count=20;_main_data=count;b_main_sink();}void b_main_sink(){int count=_main_data;{size_t i=0;for (i=0;i < (size_t)count;i++){printLine("Hello");}}}
void main_sink(struct_type my_struct);static void main(){wchar_t * data;struct_type my_struct;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){wchar_t * data=my_struct.a;{wchar_t src[100];wcscpy(data, src);printWLine(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}wchar_t * b_main_source(wchar_t * data){{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}return data;}
static void main_sink(){char * data=_main_data;system(data);}static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");_main_data=data;main_sink();}
static void main(){char * data;data=new char[100];if(global_returns_t_or_f()){}else{}{char dest[50]="";memcpy(dest, data, strlen(data)*sizeof(char));printLine(data);delete [] data;}}
static void main_sink(){twoints * data=main_data;printStructLine(&data[0]);}static void main(){twoints * data;data=NULL;data=new twoints[100];{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}main_data=data;main_sink();}
static void main(){{wchar_t * key=L"TEST\\TestKey";HKEY hKey;if (RegCreateKeyExW( HKEY_CURRENT_USER, key, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, NULL)!=ERROR_SUCCESS){printLine("Registry key could not be created");}else{printLine("Registry key created successfully");}}}
static int main_source(int data){data=7;return data;}static void main(){int data;data=main_source(data);{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main(){unsigned char data;data=' ';fscanf (stdin, "%hc", &data);{unsigned char result=-1;if (data < UCHAR_MAX){result=data+1;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));data[0]=L'\0';{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}{size_t i;for (i=0;i < wcslen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}
void main_sink(void * void_data_ptr);static void main(){wchar_t * data;data=new wchar_t[100];main_sink(&data);}void main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{wchar_t dest[50]=L"";_snwprintf(dest, wcslen(data), L"%s", data);printWLine(data);delete [] data;}}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;wchar_t data_buf[250]=L"PATH=";data=data_buf;wcscat(data, NEW_PATH);b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);PUTENV(data);}
void main_source(wchar_t * &data);static void main(){wchar_t * data;data=NULL;main_source(data);{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}void main_source(wchar_t * &data){{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}}
static void main(){long long * data;long long * &data_ref=data;data=NULL;data=new long long[100];{long long * data=data_ref;delete [] data;}}
static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t dest[50]=L"";wcsncpy(dest, data, wcslen(data));printWLine(data);free(data);}}}
static void main_sink(twointsclass * data){}static void main(){twointsclass * data;void (*func_ptr) (twointsclass *)=main_sink;data=NULL;data=new twointsclass;delete data;func_ptr(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){_wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){char * data;_union_type my_union;data=NULL;data=(char *)malloc(100*sizeof(char));my_union.a=data;{char * data=my_union.b;{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}printLine(data);free(data);}}}
static void main(){int data;data=-1;data=5;{int data_copy=data;int data=data_copy;{int result=data * 2;printIntLine(result);}}}
void b_main_sink(wchar_t * password);static void main(){wchar_t * password;wchar_t password_buf[100]=L"";password=password_buf;{size_t password_len=0;fgetws(password, 100, stdin);password_len=wcslen(password);if (password_len > 0){password[password_len-1]=L'\0';}}b_main_sink(password);}void b_main_sink(wchar_t * password){{HANDLE pHandle;wchar_t * username=L"User";wchar_t * domain=L"Domain";if (LogonUserW( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}
static void main(){twoints * data;data=NULL;data=(twoints *)calloc(100, sizeof(twoints));main_sink(&data);}void main_sink(void * void_data_ptr){twoints * * data_ptr=(twoints * *)void_data_ptr;twoints * data=(*data_ptr);free(data);}
void b_main_sink();static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}printWLine(data);}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));{wchar_t * data=*data_ptr1;data=data_goodbuf;}{wchar_t * data=*data_ptr2;{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));printWLine(data);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}void e_main_sink(wchar_t * data){main_vasink(data, data);}
void b_main_sink(int data);static void main(){int data;data=-1;data=100-1;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void d_main_sink(int data);void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;printf(data);}
static int main_source(int data){fscanf (stdin, "%d", &data);return data;}static void main(){int data;data=main_source(data);{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){int data;data=-1;fscanf (stdin, "%d", &data);{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main_sink(){char * data=main_data;delete data;}static void main(){char * data;data=NULL;data=new char;main_data=data;main_sink();}
static void main_source(int * &data){data=new int[100];}static void main(){int * data;data=NULL;main_source(data);delete [] data;}
static void main_sink(){int * data=_main_data;}static void main(){int * data;data=NULL;data=(int *)malloc(100*sizeof(int));free(data);_main_data=data;main_sink();}
static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_sink(data);}void main_sink(wchar_t * data){delete [] data;}
static twoints * main_source(twoints * data){data=(twoints *)calloc(100, sizeof(twoints));return data;}static void main(){twoints * data;data=NULL;data=main_source(data);free(data);}
static void main(){char * data;data=NULL;data=new char;main_sink(&data);}void main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);delete data;}
static void main(){int data;_struct_type my_struct;data=-1;data=20;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{char * char_string;if (data > 0){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than 0");}}}
static char main_source(char data){fscanf (stdin, "%c", &data);return data;}static void main(){char data;data=' ';data=main_source(data);{char result=0;if (data > CHAR_MIN){result=data-1;printHexCharLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static void main(){char * data;data=NULL;data=NULL;data=(char *)realloc(data, 100*sizeof(char));main_data=data;main_sink();}void main_sink(){char * data=main_data;free(data);}
static void main(){long long * data;void (*func_ptr) (long long *)=b_main_sink;data=NULL;{long long data_goodbuf[100];data=data_goodbuf;data[0]=5L;printLongLongLine(data[0]);}func_ptr(data);}void b_main_sink(long long * data){}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void b_main_sink(char * data){_spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static int * main_source(int * data){{int tmp=5;data=&tmp;}return data;}static void main(){int * data;data=NULL;data=main_source(data);printIntLine(*data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;if (strstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(int data){{int result=-1;if (data <=(INT_MAX/2)){result=data * 2;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){int count;count=-1;if(global_returns_t_or_f()){count=20;}else{count=20;}if(global_returns_t_or_f()){{size_t i=0;FILE *file=NULL;const char *filename="output_bad.txt";file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}else{{size_t i=0;FILE *file=NULL;const char *filename="output_bad.txt";file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{wchar_t src[100];wcscpy(data, src);printWLine(data);}}
static void main(){twoints * data;twoints * &data_ref=data;data=NULL;data=new twoints[100];{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}{twoints * data=data_ref;printStructLine(&data[0]);}}
static void main(){char data;data=' ';data=5;{char result=data * data;printHexCharLine(result);}}
static void main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;strcat(data, "*.*");func_ptr(data);}
static void main(){int * data;int * *data_ptr1=&data;int * *data_ptr2=&data;data=NULL;{int * data=*data_ptr1;data=new int[100];}{int * data=*data_ptr2;{memcpy(data, src, 100*sizeof(int));printIntLine(data[0]);delete [] data;}}}
static void main_source(wchar_t * &data){data=new wchar_t[100];}static void main(){wchar_t * data;data=NULL;main_source(data);{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));printWLine(data);delete [] data;}}
static long long * main_source(long long * data){data=(long long *)malloc(100*sizeof(long long));free(data);return data;}static void main(){long long * data;data=NULL;data=main_source(data);}
static void main(){int data;_union_type my_union;data=-1;data=100-1;my_union.a=data;{int data=my_union.b;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}}
static void main_sink(int data){{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=20;func_ptr(data);}
static void main(){int data;data=-1;data=5;b_main_sink(data);}void b_main_sink(int data){{int result=data * 2;printIntLine(result);}}
static void main(){wchar_t * data;wchar_t data_buf[250]=L"PATH=";data=data_buf;wcscat(data, NEW_PATH);PUTENV(data);}
static void main(){long long * data;data=NULL;data=new long long[100];delete [] data;{long long * data_copy=data;long long * data=data_copy;}}
void b_main_sink(char * * data);static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char dest[50]="";size_t i, data_len;data_len=strlen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printLine(data);}}
static void main(){char data;data=' ';data=5;b_main_sink(data);}void b_main_sink(char data){{char result=data * 2;printHexCharLine(result);}}
static void main_sink(int * data){free(data);}static void main(){int * data;data=NULL;data=NULL;data=(int *)realloc(data, 100*sizeof(int));main_sink(data);}
static void main(){unsigned int data;data=0;data=b_main_source(data);{unsigned int result=data-1;printUnsignedLine(result);}}unsigned int b_main_source(unsigned int data){data=5;return data;}
void _main_sink(wchar_t * data){{size_t i;wchar_t dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);}}static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;_main_sink(data);}
void b_main_sink();static void main(){int data;data=-1;data=100-1;_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"15");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;func_ptr(data);}void b_main_sink(wchar_t * data){if (wcsstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
static void main_sink(char * data){fprintf(stdout, data);}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");func_ptr(data);}
static void main(){wchar_t * data;wchar_t data_buf[250]=L"PATH=";data=data_buf;wcscat(data, NEW_PATH);PUTENV(data);}
static void main(){unsigned int data;void (*func_ptr) (unsigned int)=b_main_sink;data=0;fscanf (stdin, "%u", &data);func_ptr(data);}void b_main_sink(unsigned int data){{unsigned int result=0;if (data > 0){result=data-1;printUnsignedLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static void main_sink(){char * data=_main_data;system(data);}static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");_main_data=data;main_sink();}
static void main(){int data;_union_type my_union;data=-1;data=5;my_union.a=data;{int data=my_union.b;{int result=data-1;printIntLine(result);}}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=5;}{int data=*data_ptr2;{int result=data-1;printIntLine(result);}}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;data=NULL;{wchar_t * data=*data_ptr1;data=(wchar_t *)malloc(100*sizeof(wchar_t));}{wchar_t * data=*data_ptr2;free(data);}}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{size_t i;char dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);}}
static void main(){wchar_t * data;_union_type my_union;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}my_union.a=data;{wchar_t * data=my_union.b;{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]=L'\0';printWLine(data);}}}
static void main_sink(){long long * data=main_data;free(data);}static void main(){long long * data;data=NULL;data=NULL;data=(long long *)realloc(data, 100*sizeof(long long));main_data=data;main_sink();}
void b_main_sink();static void main(){int data;data=-1;data=ASSERT_VALUE+1;_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;assert(data > ASSERT_VALUE);}
static void main(){unsigned char data;data=' ';if(global_returns_t_or_f()){data=5;}else{data=5;}if(global_returns_t_or_f()){{unsigned char result=data * data;printHexUnsignedCharLine(result);}}else{{unsigned char result=data * data;printHexUnsignedCharLine(result);}}}
static void main(){int * data;data=NULL;data=NULL;data=(int *)realloc(data, 100*sizeof(int));main_data=data;main_sink();}void main_sink(){int * data=main_data;free(data);}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;data=b_main_source(data);{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}wchar_t * b_main_source(wchar_t * data){wcscat(data, L"file.txt");return data;}
static void main(){int count;count=-1;if(global_returns_t_or_f()){count=20;}else{count=20;}if(global_returns_t_or_f()){{size_t i=0;for (i=0;i < (size_t)count;i++){printLine("Hello");}}}else{{size_t i=0;for (i=0;i < (size_t)count;i++){printLine("Hello");}}}}
void b_main_sink(int data);static void main(){int data;data=-1;data=7;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void d_main_sink(int data);void c_main_sink(int data){d_main_sink(data);}void e_main_sink(int data);void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){printIntLine(100/data);}
static void main(){int count;count=-1;count=20;_main_data=count;b_main_sink();}void b_main_sink(){int count=_main_data;{size_t i=0;FILE *file=NULL;const char *filename="output_bad.txt";file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}
static void main(){int data;data=-1;data=5;b_main_sink(data);}void b_main_sink(int data){{int result=data+1;printIntLine(result);}}
void b_main_sink(float data);static void main(){float data;data=0.0F;data=7.0F;b_main_sink(data);}void c_main_sink(float data);void b_main_sink(float data){c_main_sink(data);}void d_main_sink(float data);void c_main_sink(float data){d_main_sink(data);}void d_main_sink(float data){printDoubleLine((double)(100.0/data));}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100];data=data_buf;my_union.a=data;{wchar_t * data=my_union.b;{size_t src_len;wchar_t src[100];src_len=wcslen(src);wcsncat(data, src, src_len);printWLine(data);}}}
static void main(){int count;count=-1;count=20;_main_data=count;b_main_sink();}void b_main_sink(){int count=_main_data;{size_t i=0;for (i=0;i < (size_t)count;i++){printLine("Hello");}}}
static void main(){unsigned char data;data=' ';data=(unsigned char)rand();{unsigned char result=-1;if (data < UCHAR_MAX){result=data+1;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){unsigned int data;data=0;data=5;_main_data=data;b_main_sink();}void b_main_sink(){unsigned int data=_main_data;{unsigned int result=data * 2;printUnsignedLine(result);}}
static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));free(data);}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100];data=data_buf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{char dest[50]="";memcpy(dest, data, strlen(data)*sizeof(char));printLine(data);}}
void _main_sink(double * data){printDoubleLine(*data);free(data);}static void main(){double * data;data=NULL;data=(double *)malloc(sizeof(*data));_main_sink(data);}
static char * main_source(char * data){{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}return data;}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);fprintf(stdout, "%s\n", data);}
static void main_sink(char * data){printf("%s\n", data);}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}func_ptr(data);}
void b_main_sink();static void main(){int data;data=-1;data=ASSERT_VALUE+1;_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;assert(data > ASSERT_VALUE);}
void main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];data=new wchar_t[100];data_array[2]=data;main_sink(data_array);}void main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t dest[50]=L"";wcscat(dest, data);printWLine(data);delete [] data;}}
static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}{char dest[100];memcpy(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;data=(char *)calloc(100, sizeof(char));func_ptr(data);}void main_sink(char * data){free(data);}
static void main(){wchar_t * data;data=NULL;data=main_source(data);delete [] data;}wchar_t * main_source(wchar_t * data){data=new wchar_t[100];return data;}
static void main_source(int * &data){data=(int *)malloc(100*sizeof(int));}static void main(){int * data;data=NULL;main_source(data);free(data);}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';{wchar_t * data=*data_ptr1;data=data_buf;}{wchar_t * data=*data_ptr2;{wchar_t dest[100];wcscpy(dest, data);printWLine(dest);}}}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{wchar_t dest[50]=L"";size_t i, data_len;data_len=wcslen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printWLine(data);}}
static void main(){int data;data=5;printIntLine(data);}
static void main(){int data;_struct_type my_struct;data=-1;data=20;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}
static void main_vasinkg(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, "%s", args);va_end(args);printLine(dest);}}static void main_vasinkb(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, data, args);va_end(args);printLine(dest);}}static void main(){char * data;char data_buf[100]="";data=data_buf;if(global_returns_f()){strcpy(data, "fixedstringtest");}else{strcpy(data, "fixedstringtest");}if(global_returns_t()){main_vasinkb(data, data);}else{main_vasinkb(data, data);}}
static void main(){wchar_t * data;_union_type my_union;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;my_union.a=data;{wchar_t * data=my_union.b;{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]=L'\0';printWLine(data);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(L"%s", args);va_end(args);}}void d_main_sink(wchar_t * data){main_vasink(data, data);}
static void main(){unsigned int data;_struct_type my_struct;data=0;fscanf (stdin, "%u", &data);my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){unsigned int data=my_struct.a;{unsigned int result=-1;if (data <=(unsigned int)sqrt((unsigned int)UINT_MAX)){result=data * data;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){wchar_t * data;wchar_t * &data_ref=data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));{wchar_t * data=data_ref;free(data);}}
static void main(){int data;data=-1;data=5;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){{int result=data * data;printIntLine(result);}}
static void main(){{size_t i;wchar_t dst[DST_SZ];const wchar_t *src=COPY_STR;for (i=0;i < DST_SZ;i++){dst[i]=src[i];}printWLine(dst);}}
static void main(){unsigned char data;data=' ';data=UCHAR_MAX;b_main_sink(data);}void b_main_sink(unsigned char data){{unsigned char result=-1;if (data <=(unsigned char)sqrt((unsigned char)UCHAR_MAX)){result=data * data;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){char * data;data=NULL;data=new char[100];delete [] data;}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;{wchar_t * data=*data_ptr1;}{wchar_t * data=*data_ptr2;{wchar_t dest[50]=L"";wcsncat(dest, data, wcslen(data));printWLine(data);}}}
static char * main_source(char * data){data=PASSWORD;return data;}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);if (strncmp(PASSWORD, data, strlen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink();static void main(){long long * data;{long long * data_buf=(long long *)malloc(100*sizeof(long long));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5L;}}data=data_buf;}_main_data=data;b_main_sink();}void b_main_sink(){long long * data=_main_data;printLongLongLine(data[0]);free(data);}
static void main(){twoints * data;{twoints * data_buf=new twoints[100];{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}printStructLine(&data[0]);delete [] data;}
static void main(){char * data;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;{char * data_copy=data;char * data=data_copy;{char src[100];strncpy(data, src, 100);data[100-1]='\0';printLine(data);}}}
static char * main_source(char * data){{char mystring[]="mystring";data=strdup(mystring);printLine(data);}return data;}static void main(){char * data;data=NULL;data=main_source(data);free(data);}
static void main(){wchar_t * data;wchar_t * data_array[5];data=NULL;data=new wchar_t[100];delete [] data;data_array[2]=data;main_sink(data_array);}void main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{int i, n, v;if (swscanf(data, L"%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
void b_main_sink(int * data);static void main(){int * data;data=NULL;{int tmp=5;data=&tmp;}b_main_sink(data);}void c_main_sink(int * data);void b_main_sink(int * data){c_main_sink(data);}void c_main_sink(int * data){printIntLine(*data);}
static void main_sink(){char data=_main_data;{char result=data * data;printHexCharLine(result);}}static void main(){char data;data=' ';data=5;_main_data=data;main_sink();}
static void main(){struct _twoints * data;data=NULL;data=NULL;data=(struct _twoints *)realloc(data, 100*sizeof(struct _twoints));data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);{struct _twoints * data_copy=data;struct _twoints * data=data_copy;free(data);}}
static void main(){unsigned char data;data=' ';data=5;{unsigned char result=data-1;printHexUnsignedCharLine(result);}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=NULL;{char * data=*data_ptr1;{char data_goodbuf[100];data=data_goodbuf;strcpy(data, "A String");printLine(data);}}{char * data=*data_ptr2;}}
static void main_sink(char * data){delete [] data;}static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;data=new char[100];func_ptr(data);}
static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;{wchar_t dest[50]=L"";wcscat(dest, data);printWLine(data);}}
static void main(){{char * filename;char * template="fnXXXXXX";int fd;filename=mktemp(template);printLine(filename);fd=OPEN(filename, O_CREAT|O_EXCL, S_IREAD|S_IWRITE);if (fd!=-1){printLine("Temporary file was opened...now closing file");CLOSE(fd);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");wprintf(data);}
static void main(){char * data;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}{char src[100];strncpy(data, src, 100);data[100-1]='\0';printLine(data);}}
static void main(){unsigned int data;data=0;data=5;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){unsigned int * data_ptr=(unsigned int *)void_data_ptr;unsigned int data=(*data_ptr);{unsigned int result=data+1;printUnsignedLine(result);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"C:\\Windows\\System32\\winsrv.dll");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{HMODULE hModule;hModule=LoadLibraryW(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
static wchar_t * main_source(wchar_t * data){wcscat(data, L"*.*");return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);_wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){int data;_union_type my_union;data=-1;data=7;my_union.a=data;{int data=my_union.b;printIntLine(100 % data);}}
static void main(){char data;_union_type my_union;data=' ';data=(char)rand();my_union.a=data;{char data=my_union.b;{char result=-1;if (data <=(CHAR_MAX/2)){result=data * 2;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));main_sink_b(data);}void main_sink_b(long long * data){main_sink_c(data);}void main_sink_c(long long * data){main_sink_d(data);}void main_sink_d(long long * data){main_sink_e(data);}void main_sink_e(long long * data){free(data);}
void b_main_sink(wchar_t * password);static void main(){wchar_t * password;wchar_t password_buf[100]=L"";password=password_buf;{size_t password_len=0;fgetws(password, 100, stdin);password_len=wcslen(password);if (password_len > 0){password[password_len-1]=L'\0';}}b_main_sink(password);}void c_main_sink(wchar_t * password);void b_main_sink(wchar_t * password){c_main_sink(password);}void c_main_sink(wchar_t * password){{HANDLE pHandle;wchar_t * username=L"User";wchar_t * domain=L"Domain";if (LogonUserW( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}
static void main_sink(){char * data=main_data;printf("%c\n", *data);}static void main(){char * data;data=NULL;data=new char;main_data=data;main_sink();}
static void main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}
static void main(){{wchar_t data_buf[100]=L"";wchar_t * data=data_buf;wcscpy(data, L"abcdefghijklmnopqrstuvwxyz");memmove(data+6, data+4, 10*sizeof(wchar_t));printWLine(data);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));printWLine(data);free(data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static wchar_t * main_source(wchar_t * data){data=new wchar_t[100];return data;}static void main(){wchar_t * data;data=NULL;data=main_source(data);delete [] data;}
static void main(){int data;data=-1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){int data;_union_type my_union;data=-1;data=7;my_union.a=data;{int data=my_union.b;printIntLine(100 % data);}}
static void main_sink(twoints * data){if (data!=NULL){data[0].a=1;data[0].b=1;printStructLine(&data[0]);free(data);}}static void main(){twoints * data;void (*func_ptr) (twoints *)=main_sink;data=(twoints *)realloc(data, 100);func_ptr(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(&data);}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}void b_main_sink(char * * data_ptr){char * data=*data_ptr;main_vasink(data, data);}
static void main(){int * data;data=NULL;if(global_returns_t_or_f()){data=new int;}else{data=new int;}if(global_returns_t_or_f()){delete data;}else{delete data;}}
static void main_sink(twointsclass * data){delete [] data;}static void main(){twointsclass * data;void (*func_ptr) (twointsclass *)=main_sink;data=NULL;data=new twointsclass[100];func_ptr(data);}
static char * main_source(char * data){{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}return data;}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, "%s", args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);main_vasink(data, data);}
static long long * main_source(long long * data){data=new long long;delete data;return data;}static void main(){long long * data;data=NULL;data=main_source(data);}
static void main_source(char * &data){}static void main(){char * data;data=new char[100];main_source(data);{char dest[50]="";strncat(dest, data, strlen(data));printLine(data);delete [] data;}}
void main_sink(wchar_t * data){{wchar_t dest[100];wcsncpy(dest, data, wcslen(dest));dest[100-1]=L'\0';printWLine(dest);}}static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}main_sink(data);}
static void main(){int count;int *count_ptr1=&count;int *count_ptr2=&count;count=-1;{int count=*count_ptr1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);count=atoi(input_buf);}}{int count=*count_ptr2;{size_t i=0;FILE *file=NULL;const char *filename="output_good.txt";if (count > 0 && count <=20){file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}}}
void b_main_sink(short data_array[]);static void main(){short data;short data_array[5];data=0;data=100-1;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(short data_array[]){short data=data_array[2];{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
static void main(){long long * data;data=(long long *)calloc(100, sizeof(long long));{long long * data_copy=data;long long * data=data_copy;if (data!=NULL){data[0]=5L;printLongLongLine(data[0]);free(data);}}}
static void main(){twoints * data;twoints * &data_ref=data;data=NULL;data=new twoints;{twoints * data=data_ref;delete data;}}
void b_main_sink(short data);static void main(){short data;data=0;data=100-1;b_main_sink(data);}void b_main_sink(short data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){short data;data=0;if(global_returns_t_or_f()){data=100-1;}else{data=100-1;}{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
static void main_sink(twoints * data){}static void main(){twoints * data;data=NULL;{twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine(&data[0]);}main_sink(data);}
void main_sink(char * * data);static void main(){char * data;data=NULL;data=new char[100];main_sink(&data);}void main_sink(char * * data_ptr){char * data=*data_ptr;{size_t i, dest_sz;char dest[100];memset(dest, 'C', 100-1);dest_sz=strlen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);delete [] data;}}
static void main_sink(bad_struct data){* */prev=data.list.prev;next=data.list.next;prev->next=next;next->prev=prev;}static void main(){bad_struct data;void (*func_ptr) (bad_struct)=main_sink;linked_list head={&head, &head};data.list.next=head.next;data.list.prev=&head;head.next=&data.list;head.next->prev=&data.list;func_ptr(data);}
static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));strcpy(data, "A String");printLine(data);b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;free(data);}
static void main(){wchar_t * data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';if(global_returns_t_or_f()){data=data_buf;}else{data=data_buf;}{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}
static void main_sink(){wchar_t * data=_main_data;}static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));free(data);_main_data=data;main_sink();}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t data_buf[250]=L"PATH=";data=data_buf;wcscat(data, NEW_PATH);b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;PUTENV(data);}
void _main_sink(wchar_t * data){{wchar_t src[100];wcsncat(data, src, 100);printWLine(data);free(data);}}static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));_main_sink(data);}
static void main(){wchar_t * data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';if(global_returns_t_or_f()){data=data_buf;}else{data=data_buf;}{wchar_t src[100];wcscpy(data, src);printWLine(data);}}
void main_sink_b(char * data);static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_d(char * data);void main_sink_c(char * data){main_sink_d(data);}void main_sink_d(char * data){{char dest[100];strcpy(dest, data);printLine(dest);}}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf("%s", args);va_end(args);}}static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]="";data=data_buf;{char * data=*data_ptr1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}}{char * data=*data_ptr2;main_vasink(data, data);}}
void b_main_sink();static void main(){int data;data=-1;data=20;_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{size_t i;int *b;b=(int*)malloc(data * sizeof(int));for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);free(b);}}
static void main(){long long * data;data=NULL;data=new long long;main_sink(&data);}void main_sink(long long * * data_ptr){long long * data=*data_ptr;delete data;}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){{int result=-1;if (data <=(int)sqrt((int)INT_MAX)){result=data * data;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){int data;data=-1;data=20;{int data_copy=data;int data=data_copy;{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}}
static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, "%s", args);va_end(args);printLine(dest);}}static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}my_union.a=data;{char * data=my_union.b;main_vasink(data, data);}}
void main_source(char * &data);static void main(){char * data;data=NULL;main_source(data);{char src[100];strcpy(data, src);printLine(data);}}void main_source(char * &data){{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}}
static void main_source(char * &data){data=new char[100];}static void main(){char * data;data=NULL;main_source(data);delete [] data;}
static void main(){{twoints * data=(twoints *)malloc(100*sizeof(twoints));twoints * tmp;data[0].a=0;data[0].b=0;printStructLine(&data[0]);tmp=(twoints *)realloc(data, (130000)*sizeof(twoints));if (tmp!=NULL){data=tmp;data[0].a=1;data[0].b=1;printStructLine(&data[0]);}free(data);}}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"C:\\Windows\\System32\\winsrv.dll");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{HMODULE hModule;hModule=LoadLibraryW(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
void _main_sink(wchar_t * data){EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_sink(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;wprintf(data);}
static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=-1;fscanf (stdin, "%d", &data);func_ptr(data);}void b_main_sink(int data){{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_t_or_f()){wcscat(data, L"*.*");}else{wcscat(data, L"*.*");}{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
static void main(){int * data;data=new int[10];{int i;for(i=0;i<10;i++){data[i]=i;}}main_sink(&data);}void main_sink(int * * data_ptr){int * data=*data_ptr;{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}delete [] data;}
void _main_sink(wchar_t * data){{wchar_t dest[50]=L"";memmove(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);free(data);}}static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));_main_sink(data);}
static void main_sink(){unsigned int data=_main_data;{unsigned int result=data * 2;printUnsignedLine(result);}}static void main(){unsigned int data;data=0;data=5;_main_data=data;main_sink();}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main_sink(){wchar_t * data=_main_data;{wchar_t dest[50]=L"";memcpy(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);free(data);}}static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));_main_data=data;main_sink();}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}{char dest[100]="";SNPRINTF(dest, 100-1, "%s", data);printLine(dest);}}
static void main(){int data;int data_array[5];data=-1;data=20;data_array[2]=data;main_sink(data_array);}void main_sink(int data_array[]){int data=data_array[2];{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}
static int main_source(int data){data=20;return data;}static void main(){int data;data=-1;data=main_source(data);{char * char_string;if (data > 0){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than 0");}}}
static void main(){int data;_union_type my_union;data=-1;data=20;my_union.a=data;{int data=my_union.b;{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(data, args);va_end(args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");main_vasink(data, data);}
static char * main_source(char * data){data=new char;return data;}static void main(){char * data;data=NULL;data=main_source(data);delete data;}
static void main_sink(wchar_t * data){{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"15");main_sink(data);}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=NULL;data=new wchar_t[100];func_ptr(data);}void main_sink(wchar_t * data){delete [] data;}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
static void main(){int data;union_type my_union;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}my_union.a=data;{int data=my_union.b;{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}}
void main_sink_b(char * data);static void main(){char * data;data=NULL;data=new char[100];main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){{char src[100];_snprintf(data, 100, "%s", src);printLine(data);delete [] data;}}
static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");{char * data_copy=data;char * data=data_copy;{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}}
static void main_vasinkb(char * data, ...){{va_list args;va_start(args, data);vprintf(data, args);va_end(args);}}static void main_vasinkg(char * data, ...){{va_list args;va_start(args, data);vprintf("%s", args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}main_vasinkg(data, data);}
static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;{wchar_t dest[100];memmove(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){unsigned int data;data=0;data=0;_main_data=data;b_main_sink();}void b_main_sink(){unsigned int data=_main_data;{unsigned int result=0;if (data > 0){result=data-1;printUnsignedLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t data_src[10+1]=SRC_STRING;wcsncpy(data, data_src, wcslen(data_src));printWLine(data);free(data);}}
static int main_source(int data){data=20;return data;}static void main(){int data;data=-1;data=main_source(data);{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}
static void main_source(wchar_t * &data){data=new wchar_t;}static void main(){wchar_t * data;data=NULL;main_source(data);printWcharLine(*data);}
static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main_sink(){twoints * data=_main_data;printStructLine(data);free(data);}static void main(){twoints * data;data=NULL;data=(twoints *)malloc(sizeof(*data));data->a=1;data->b=2;_main_data=data;main_sink();}
static void main(){int data;_struct_type my_struct;data=10;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0 && data < 10){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){struct _twoints * data;struct_type my_struct;data=NULL;data=new struct _twoints;data->a=0;data->b=0;printStructLine((twoints *)data);my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){struct _twoints * data=my_struct.a;delete data;}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];{twointsclass src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memcpy(data, src, 100*sizeof(twointsclass));printIntLine(data[0].a);delete [] data;}}
static int * main_source(int * data){data=new int;return data;}static void main(){int * data;data=NULL;data=main_source(data);delete data;}
void main_sink_b(char * data);static void main(){char * data;data=NULL;data=new char[100];main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){{char src[100];strcat(data, src);printLine(data);delete [] data;}}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));data=data_buf;}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);printWLine(data);free(data);}
static void main_source(twointsclass * &data){data=NULL;data=(twointsclass *)realloc(data, 100*sizeof(twointsclass));}static void main(){twointsclass * data;data=NULL;main_source(data);free(data);}
static void main(){int * data;data=new int[10];main_sink(&data);}void main_sink(int * * data_ptr){int * data=*data_ptr;{int i;for(i=0;i<10;i++){data[i]=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}delete [] data;}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=(char *)malloc(100*sizeof(char));{char * data=*data_ptr1;}{char * data=*data_ptr2;{char dest[50]="";strcat(dest, data);printLine(data);free(data);}}}
static void main(){unsigned char data;data=' ';data=5;_main_data=data;b_main_sink();}void b_main_sink(){unsigned char data=_main_data;{unsigned char result=data-1;printHexUnsignedCharLine(result);}}
static unsigned int main_source(unsigned int data){data=UINT_MAX;return data;}static void main(){unsigned int data;data=0;data=main_source(data);{unsigned int result=-1;if (data <=(unsigned int)sqrt((unsigned int)UINT_MAX)){result=data * data;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){twoints * data;data=NULL;{twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine(&data[0]);}main_data=data;main_sink();}void main_sink(){twoints * data=main_data;}
void b_main_sink(int data);static void main(){int data;data=-1;data=100-1;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void d_main_sink(int data);void c_main_sink(int data){d_main_sink(data);}void e_main_sink(int data);void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
void b_main_sink(long long * data);static void main(){long long * data;void (*func_ptr) (long long *)=b_main_sink;data=NULL;data=(long long *)malloc(sizeof(*data));func_ptr(data);}void b_main_sink(long long * data){printLongLongLine(*data);free(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{wchar_t dest[50]=L"";memmove(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);}}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{wchar_t src[100];wcsncat(data, src, 100);printWLine(data);free(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_t_or_f()){wcscat(data, L"*.*");}else{wcscat(data, L"*.*");}{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnvp(_P_WAIT, COMMAND_INT, args);}}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{wchar_t dest[100];memmove(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf(data, args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");main_vasink(data, data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, data);printWLine(dest);}}
void _main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}static void main(){int data;data=-1;data=100-1;_main_sink(data);}
static void main(){int count;count=-1;fscanf (stdin, "%d", &count);b_main_sink(&count);}void b_main_sink(int * count_ptr){int count=*count_ptr;{size_t i=0;if (count > 0 && count <=20){for (i=0;i < (size_t)count;i++){printLine("Hello");}}}}
static void main_sink(int data){{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}static void main(){int data;data=-1;data=20;main_sink(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");_main_data=data;b_main_sink();}static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, data, args);va_end(args);printLine(dest);}}void b_main_sink(){char * data=_main_data;main_vasink(data, data);}
static void main(){long long * data;data=NULL;data=new long long;delete data;main_sink_b(data);}void main_sink_b(long long * data){main_sink_c(data);}void main_sink_c(long long * data){main_sink_d(data);}void main_sink_d(long long * data){}
static void main(){int count;_union_type my_union;count=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;count=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}my_union.a=count;{int count=my_union.b;{size_t i=0;if (count > 0 && count <=20){for (i=0;i < (size_t)count;i++){printLine("Hello");}}}}}
static void main(){twoints * data;union_type my_union;data=NULL;data=new twoints[100];my_union.a=data;{twoints * data=my_union.b;delete [] data;}}
static void main(){int data;data=-1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}{int result=-1;if (data <=(INT_MAX/2)){result=data * 2;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{wchar_t dest[50]=L"";wcsncpy(dest, data, wcslen(data));printWLine(data);}}
void b_main_sink(int data_array[]);static void main(){int data;int data_array[5];data=-1;data=100-1;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
static void main(){int data;int data_array[5];data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));wcscpy(data, L"A String");printWLine(data);b_main_sink(data);}void b_main_sink(wchar_t * data){free(data);}
void _main_sink(int data){{size_t i;int *b;b=(int*)malloc(data * sizeof(int));for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);free(b);}}static void main(){int data;data=-1;data=20;_main_sink(data);}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];data=NULL;data=(char *)malloc((10+1)*sizeof(char));data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{char data_src[10+1]=SRC_STRING;memmove(data, data_src, strlen(data_src)*sizeof(char));printLine(data);free(data);}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_badbuf[50];char data_goodbuf[100];{char * data=*data_ptr1;data=data_goodbuf;}{char * data=*data_ptr2;{char dest[100];memset(dest, 'C', 100-1);memmove(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);}}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;data=(char *)malloc(100*sizeof(char));my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char dest[50]="";strncpy(dest, data, strlen(data));printLine(data);free(data);}}
static void main(){char * data;char * data_array[5];data=NULL;data=new char[100];data_array[2]=data;main_sink(data_array);}void main_sink(char * data_array[]){char * data=data_array[2];delete [] data;}
static void main(){char data;data=' ';if(global_returns_t_or_f()){data=CHAR_MAX;}else{data=CHAR_MAX;}if(global_returns_t_or_f()){{char result=-1;if (data <=(CHAR_MAX/2)){result=data * 2;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}else{{char result=-1;if (data <=(CHAR_MAX/2)){result=data * 2;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
static void main(){char * data;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}{char dest[100];memmove(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
static void main(){int * data;data=NULL;data=new int[100];delete [] data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static char * main_source(char * data){strcat(data, "*.*");return data;}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
void b_main_sink(short data);static void main(){short data;void (*func_ptr) (short)=b_main_sink;data=0;data=100-1;func_ptr(data);}void b_main_sink(short data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, data);printWLine(dest);}}
static void main(){if(global_returns_t_or_f()){{FILE *f;f=FOPEN("temp.txt", "w");if (f!=NULL){fprintf(f, "Temporary file");fclose(f);}}}else{{FILE *f;f=FOPEN("temp.txt", "w");if (f!=NULL){fprintf(f, "Temporary file");fclose(f);}}}}
void b_main_sink(int data);static void main(){int data;data=-1;data=CHAR_MAX-5;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void d_main_sink(int data);void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){{short s=(short)data;printf("%hd\n", s);}}
static void main(){int count;_struct_type my_struct;count=-1;count=20;my_struct.a=count;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int count=my_struct.a;{size_t i=0;for (i=0;i < (size_t)count;i++){printLine("Hello");}}}
static void main(){int * data;data=NULL;data=new int[100];main_sink(data);}void main_sink(int * data){delete [] data;}
static void main(){int count;count=-1;fscanf (stdin, "%d", &count);b_main_sink(count);}void b_main_sink(int count){c_main_sink(count);}void c_main_sink(int count){d_main_sink(count);}void d_main_sink(int count){e_main_sink(count);}void e_main_sink(int count){{size_t i=0;FILE *file=NULL;const char *filename="output_good.txt";if (count > 0 && count <=20){file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}}
static void main(){char data;_union_type my_union;data=' ';fscanf (stdin, "%c", &data);my_union.a=data;{char data=my_union.b;{char result=-1;if (data < CHAR_MAX){result=data+1;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
void _main_sink(char * data){{char src[100];memcpy(data, src, 100*sizeof(char));printLine(data);free(data);}}static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));_main_sink(data);}
static void main_sink(twoints * data){delete data;}static void main(){twoints * data;void (*func_ptr) (twoints *)=main_sink;data=NULL;data=new twoints;data->a=0;data->b=0;printStructLine(data);func_ptr(data);}
static void main(){int data;data=-1;fscanf (stdin, "%d", &data);{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static void main(){int * data;data=NULL;data=new int[100];main_sink(&data);}void main_sink(int * * data_ptr){int * data=*data_ptr;delete [] data;}
static void main(){char * data;_union_type my_union;data=NULL;{char data_goodbuf[100];data=data_goodbuf;strcpy(data, "A String");printLine(data);}my_union.a=data;{char * data=my_union.b;}}
static void main(){char data;data=' ';if(global_returns_t_or_f()){data=(char)rand();}else{data=(char)rand();}if(global_returns_t_or_f()){{char result=-1;if (data <=(CHAR_MAX/2)){result=data * 2;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}else{{char result=-1;if (data <=(CHAR_MAX/2)){result=data * 2;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
void _main_sink(wchar_t * data){{wchar_t dest[100];wmemset(dest, L'C', 100-1);memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;_main_sink(data);}
static void main(){char * data;data=NULL;data=new char[100];main_sink_b(data);}void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){main_sink_d(data);}void main_sink_d(char * data){delete [] data;}
void main_sink_b(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_sink_b(data);}void main_sink_c(wchar_t * data);void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){{wchar_t src[100];wcscat(data, src);printWLine(data);delete [] data;}}
static void main(){int * data;union_type my_union;data=NULL;data=(int *)malloc(100*sizeof(int));my_union.a=data;{int * data=my_union.b;free(data);}}
static void main(){int * data;data=NULL;data=new int[100];main_sink(data);}void main_sink(int * data){delete [] data;}
static void main(){{twointsclass data;data.a=1;data.b=2;twointsclass * pointer=new twointsclass;{twointsclass data=*pointer;printIntLine(data.a);printIntLine(data.b);}delete pointer;}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{int i, n, v;if (sscanf(data, "%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;data=NULL;{wchar_t mystring[]=L"mystring";data=wcsdup(mystring);printWLine(data);}func_ptr(data);}void b_main_sink(wchar_t * data){free(data);}
static void main(){char * data;char * data_array[5];char data_buf[100]="";data=data_buf;strcpy(data, "15");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{int i, n, v;if (sscanf(data, "%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main(){int data;data=-1;data=INT_MIN;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static void main(){char * data;data=NULL;data=new char;main_sink_b(data);}void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){main_sink_d(data);}void main_sink_d(char * data){delete data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
static void main(){int data;data=-1;fscanf (stdin, "%d", &data);b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than the length of the source string or too large");}}}
static void main_source(twoints * &data){data=(twoints *)malloc(100*sizeof(twoints));}static void main(){twoints * data;data=NULL;main_source(data);free(data);}
static void main(){char * data;data=NULL;data=new char[100];delete [] data;main_sink_b(data);}void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){}
static void main(){int data;data=-1;data=5;{int result=data * data;printIntLine(result);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t src[100];wcscpy(data, src);printWLine(data);free(data);}}
static long long * main_source(long long * data){{long long tmp=5L;data=&tmp;}return data;}static void main(){long long * data;data=NULL;data=main_source(data);printLongLongLine(*data);}
static void main(){int data;data=-1;data=20;{size_t a,i;int *b;b=(int*)new char[a];for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);delete [] b;}}
static void main(){unsigned char data;data=' ';data=5;b_main_sink(data);}void b_main_sink(unsigned char data){c_main_sink(data);}void c_main_sink(unsigned char data){d_main_sink(data);}void d_main_sink(unsigned char data){e_main_sink(data);}void e_main_sink(unsigned char data){{unsigned char result=data * 2;printHexUnsignedCharLine(result);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void b_main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnvp(_P_WAIT, COMMAND_INT, args);}}
static void main(){twoints * data;data=new twoints[10];if(global_returns_t_or_f()){{int i;for(i=0;i<(10/2);i++){data[i].a=i;data[i].b=i;}}}else{{int i;for(i=0;i<(10/2);i++){data[i].a=i;data[i].b=i;}}}if(global_returns_t_or_f()){{int i;for(i=0;i<10;i++){data[i].a=i;data[i].b=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}delete [] data;}else{{int i;for(i=0;i<10;i++){data[i].a=i;data[i].b=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}delete [] data;}}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"C:\\Windows\\System32\\winsrv.dll");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{HMODULE hModule;hModule=LoadLibraryW(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
static void main(){struct _twoints * data;data=NULL;data=new struct _twoints[100];data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);main_data=data;main_sink();}void main_sink(){struct _twoints * data=main_data;delete[] data;}
void b_main_sink();static void main(){int * data;int * data_badbuf=(int *)ALLOCA(50*sizeof(int));int * data_goodbuf=(int *)ALLOCA(100*sizeof(int));data=data_goodbuf;_main_data=data;b_main_sink();}void b_main_sink(){int * data=_main_data;{memmove(data, src, 100*sizeof(int));printIntLine(data[0]);}}
static void main(){char * data;data=NULL;data=(char *)calloc(100, sizeof(char));strcpy(data, "A String");printLine(data);b_main_sink(data);}void b_main_sink(char * data){free(data);}
static void main(){char * data;void (*func_ptr) (char *, ...)=b_main_vasink;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}void b_main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, "%s", args);va_end(args);printLine(dest);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, data, args);va_end(args);printLine(dest);}}void c_main_sink(char * data){main_vasink(data, data);}
static void main(){twoints * data;data=NULL;data=new twoints;data->a=1;data->b=2;delete data;main_sink_b(data);}void main_sink_b(twoints * data){main_sink_c(data);}void main_sink_c(twoints * data){main_sink_d(data);}void main_sink_d(twoints * data){main_sink_e(data);}void main_sink_e(twoints * data){}
static void main(){long long * data;data=NULL;data=(long long *)calloc(100, sizeof(long long));main_sink(data);}void main_sink(long long * data){free(data);}
static void main(){int count;count=-1;if(global_returns_t_or_f()){count=20;}else{count=20;}if(global_returns_t_or_f()){{size_t i=0;for (i=0;i < (size_t)count;i++){printLine("Hello");}}}else{{size_t i=0;for (i=0;i < (size_t)count;i++){printLine("Hello");}}}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{wchar_t dest[50]=L"";_snwprintf(dest, wcslen(data), L"%s", data);printWLine(data);}}
static void main_sink(){wchar_t * data=_main_data;if (wcsstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;_main_data=data;main_sink();}
static void main_sink(HANDLE data){if (data!=INVALID_HANDLE_VALUE){CloseHandle(data);}}static void main(){HANDLE data;void (*func_ptr) (HANDLE)=main_sink;data=INVALID_HANDLE_VALUE;data=CreateFile("BadSource_w32CreateFile.txt", (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);func_ptr(data);}
static void main(){twoints * data;data=NULL;if(global_returns_t_or_f()){data=new twoints[100];delete [] data;}else{data=new twoints[100];delete [] data;}if(global_returns_t_or_f()){}else{}}
static void main_sink(long long * data){free(data);}static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));main_sink(data);}
static void main(){unsigned char data;data=' ';fscanf (stdin, "%hc", &data);b_main_sink(data);}void b_main_sink(unsigned char data){{unsigned char result=-1;if (data <=(UCHAR_MAX/2)){result=data * 2;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static struct _twoints * main_source(struct _twoints * data){data=new struct _twoints;data->a=0;data->b=0;printStructLine((twoints *)data);return data;}static void main(){struct _twoints * data;data=NULL;data=main_source(data);delete data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}main_sink(data);}void main_sink(int data){{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static wchar_t * main_source(wchar_t * data){{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}return data;}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, L"%s", args);va_end(args);printWLine(dest);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);main_vasink(data, data);}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];main_data=data;main_sink();}void main_sink(){twointsclass * data=main_data;delete [] data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){wprintf(L"%s\n", data);}
static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}{wchar_t dest[100];memcpy(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){char * data;char data_buf[100];data=data_buf;{char dest[50]="";strncpy(dest, data, strlen(data));printLine(data);}}
static void main(){int * data;data=NULL;data=(int *)malloc(100*sizeof(int));main_sink_b(data);}void main_sink_b(int * data){main_sink_c(data);}void main_sink_c(int * data){main_sink_d(data);}void main_sink_d(int * data){free(data);}
static void main(){int data;_union_type my_union;data=-1;data=OPEN("BadSource_open.txt", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);my_union.a=data;{int data=my_union.b;if (data!=-1){CLOSE(data);}}}
static void main(){long long * data;data=NULL;{long long data_goodbuf[100];data=data_goodbuf;data[0]=5L;printLongLongLine(data[0]);}b_main_sink(data);}void b_main_sink(long long * data){c_main_sink(data);}void c_main_sink(long long * data){d_main_sink(data);}void d_main_sink(long long * data){}
void main_sink(long long * * data);static void main(){long long * data;{long long * data_buf=new long long[100];{size_t i;for (i=0;i < 100;i++){data_buf[i]=5L;}}data=data_buf;}main_sink(&data);}void main_sink(long long * * data_ptr){long long * data=*data_ptr;printLongLongLine(data[0]);delete [] data;}
static void main(){char data;char *data_ptr1=&data;char *data_ptr2=&data;data=' ';{char data=*data_ptr1;data=5;}{char data=*data_ptr2;{char result=data * data;printHexCharLine(result);}}}
static void main_sink(char * data){if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;data=PASSWORD;func_ptr(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{wchar_t dest[50]=L"";size_t i, data_len;data_len=wcslen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printWLine(data);}}
int b_main_source(int data);static void main(){int data;data=-1;data=b_main_source(data);if (data!=-1){CLOSE(data);}}int b_main_source(int data){data=OPEN("BadSource_open.txt", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);return data;}
void _main_sink(char * data){{char src[100];memmove(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}static void main(){char * data;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}_main_sink(data);}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}printLine(data);}}
static void main(){double * data;data=(double *)ALLOCA(10*sizeof(double));{int i;for(i=0;i<10;i++){data[i]=(double)i;}}{int i;for(i=0;i<10;i++){printDoubleLine(data[i]);}}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t;delete data;main_sink(&data);}void main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;}
static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");data_array[2]=data;b_main_sink(data_array);}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];main_vasink(data, data);}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];_wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
void b_main_sink(int data);static void main(){int data;data=-1;data=CHAR_MAX-5;b_main_sink(data);}void b_main_sink(int data){{char c=(char)data;printHexCharLine(c);}}
void b_main_sink(long long * * data);static void main(){long long * data;long long * data_badbuf=(long long *)ALLOCA(50*sizeof(long long));long long * data_goodbuf=(long long *)ALLOCA(100*sizeof(long long));data=data_goodbuf;b_main_sink(&data);}void b_main_sink(long long * * data_ptr){long long * data=*data_ptr;{memcpy(data, src, 100*sizeof(long long));printLongLongLine(data[0]);}}
static void main(){unsigned char data;data=' ';data=5;b_main_sink(data);}void b_main_sink(unsigned char data){c_main_sink(data);}void c_main_sink(unsigned char data){d_main_sink(data);}void d_main_sink(unsigned char data){{unsigned char result=data * 2;printHexUnsignedCharLine(result);}}
static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=20;func_ptr(data);}void main_sink(int data){{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}
static void main_sink(unsigned char data){{unsigned char result=0;if (data > 0){result=data-1;printHexUnsignedCharLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}static void main(){unsigned char data;data=' ';data=(unsigned char)rand();main_sink(data);}
static void main(){int * data;data=(int *)malloc(10*sizeof(int));{int i;for(i=0;i<10;i++){data[i]=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i]);}}}
static wchar_t * main_source(wchar_t * data){data=(wchar_t *)calloc(100, sizeof(wchar_t));return data;}static void main(){wchar_t * data;data=NULL;data=main_source(data);free(data);}
void b_main_sink(char * data);static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{char dest[50]="";size_t i, data_len;data_len=strlen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printLine(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_t_or_f()){wcscat(data, L"*.*");}else{wcscat(data, L"*.*");}EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
void b_main_sink(char * * data);static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{char dest[100];memset(dest, 'C', 100-1);memcpy(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);free(data);}}
static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=-1;data=20;func_ptr(data);}void b_main_sink(int data){{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}
static void main_sink(){char * data=_main_data;printf(data);}static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");_main_data=data;main_sink();}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, data, args);va_end(args);printLine(dest);}}void c_main_sink(char * data){main_vasink(data, data);}
static char * main_source(char * data){data=(char *)malloc(100*sizeof(char));return data;}static void main(){char * data;data=NULL;data=main_source(data);{char dest[100];memset(dest, 'C', 100-1);memcpy(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);free(data);}}
static void main(){{HDESK hDesk;wchar_t * dtName=L"DesktopExample";hDesk=CreateDesktopW( dtName, NULL, NULL, 0, GENERIC_READ, NULL);if (hDesk==NULL){printLine("Desktop could not be created");}else{printLine("Desktop created successfully");CloseDesktop(hDesk);}}}
static void main_sink(){twointsclass * data=main_data;free(data);}static void main(){twointsclass * data;data=NULL;data=NULL;data=(twointsclass *)realloc(data, 100*sizeof(twointsclass));main_data=data;main_sink();}
static void main(){int data;data=-1;data=7;printIntLine(100 % data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){fwprintf(stdout, data);}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];data=(wchar_t *)malloc(100*sizeof(wchar_t));data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t dest[50]=L"";wcscpy(dest, data);printWLine(data);free(data);}}
static void main(){twointsclass * data;union_type my_union;data=NULL;data=(twointsclass *)calloc(100, sizeof(twointsclass));my_union.a=data;{twointsclass * data=my_union.b;free(data);}}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]="";data=data_buf;strcat(data, "*.*");func_ptr(data);}void b_main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
static void main(){long long * data;data=NULL;if(global_returns_t_or_f()){data=new long long;delete data;}else{data=new long long;delete data;}if(global_returns_t_or_f()){}else{}}
void b_main_sink();static void main(){int data;data=-1;data=100-1;_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
static void main(){{char * pipeName="\\\\.\\pipe\\mypipe";HANDLE hPipe=INVALID_HANDLE_VALUE;hPipe=CreateNamedPipeA( pipeName, FILE_FLAG_FIRST_PIPE_INSTANCE, PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, BUFSIZE, BUFSIZE, NMPWAIT_USE_DEFAULT_WAIT, NULL);if (hPipe==INVALID_HANDLE_VALUE){exit(1);}if (GetLastError()==ERROR_ACCESS_DENIED){exit(1);}if (!ImpersonateNamedPipeClient(hPipe)){exit(1);}CloseHandle(hPipe);}}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{char dest[50]="";strncpy(dest, data, strlen(data));printLine(data);}}
static void main_sink(){unsigned int data=_main_data;{unsigned int result=data+1;printUnsignedLine(result);}}static void main(){unsigned int data;data=0;data=5;_main_data=data;main_sink();}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;fprintf(stdout, "%s\n", data);}
static void main(){char * data;data=NULL;{char mystring[]="mystring";data=strdup(mystring);}free(data);}
static void main(){twoints * data;data=NULL;data=new twoints[100];delete [] data;main_sink_b(data);}void main_sink_b(twoints * data){main_sink_c(data);}void main_sink_c(twoints * data){}
void _main_sink(char * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");_main_sink(data);}
static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=10;func_ptr(data);}void b_main_sink(int data){{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0 && data < 10){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];main_data=data;main_sink();}void main_sink(){twointsclass * data=main_data;delete [] data;}
static void main(){int * data;union_type my_union;data=NULL;data=(int *)malloc(100*sizeof(int));my_union.a=data;{int * data=my_union.b;free(data);}}
void _main_sink(wchar_t * data){{wchar_t dest[100];wcscpy(dest, data);printWLine(dest);}}static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}_main_sink(data);}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){int data;data=-1;data=5;{int data_copy=data;int data=data_copy;{int result=data * data;printIntLine(result);}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");b_main_sink(data);}void b_main_sink(char * data){system(data);}
static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;data->a=1;data->b=2;main_sink(&data);}void main_sink(twointsclass * * data_ptr){twointsclass * data=*data_ptr;printIntLine(data->a);}
static void main(){unsigned char data;data=' ';data=(unsigned char)rand();b_main_sink(data);}void b_main_sink(unsigned char data){{unsigned char result=-1;if (data < UCHAR_MAX){result=data+1;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main_source(long long * &data){data=new long long[100];}static void main(){long long * data;data=NULL;main_source(data);delete [] data;}
static char * main_source(char * data){data=new char[100];return data;}static void main(){char * data;data=NULL;data=main_source(data);{char src[100];_snprintf(data, 100, "%s", src);printLine(data);delete [] data;}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, "%s", args);va_end(args);printLine(dest);}}void d_main_sink(char * data){main_vasink(data, data);}
static void main(){long long * data;struct_type my_struct;data=NULL;data=new long long;printLongLongLine(*data);my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){long long * data=my_struct.a;delete data;}
static char * main_source(char * data){data=(char *)malloc(100*sizeof(char));free(data);return data;}static void main(){char * data;data=NULL;data=main_source(data);}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){char * data;_union_type my_union;char data_buf[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;my_union.a=data;{char * data=my_union.b;{char src[100];strcpy(data, src);printLine(data);}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, GOOD_OS_COMMAND);{FILE *pipe;pipe=POPEN(data, "wb");if (pipe!=NULL) PCLOSE(pipe);}}
static void main_vasinkg(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, L"%s", args);va_end(args);}}static void main_vasinkb(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, data, args);va_end(args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");main_vasinkb(data, data);}
static void main_sink(int data){{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}static void main(){int data;data=7;main_sink(data);}
static void main(){char * data;char * data_array[5];char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{char dest[100]="";SNPRINTF(dest, 100-1, "%s", data);printLine(dest);}}
static wchar_t * main_source(wchar_t * data){{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}return data;}static void main(){wchar_t * data;data=NULL;data=main_source(data);{wchar_t src[100];wcsncpy(data, src, 100);data[100-1]=L'\0';printWLine(data);}}
static void main(){{wchar_t * data=SRC_STR;wchar_t dst[100]=L"";wchar_t * end=wcschr(data, L'/');wcsncpy(dst, data, end-data);printWLine(dst);}}
static void main_sink(long long * data){{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printLongLongLine(data[0]);}}}static void main(){long long * data;void (*func_ptr) (long long *)=main_sink;long long * data_badbuf=(long long *)ALLOCA(50*sizeof(long long));long long * data_goodbuf=(long long *)ALLOCA(100*sizeof(long long));data=data_goodbuf;func_ptr(data);}
static void main(){twoints * data;data=NULL;main_source(data);delete [] data;}void main_source(twoints * &data){data=new twoints[100];}
static void main(){int data;data=-1;data=100-1;{int data_copy=data;int data=data_copy;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}}
static void main(){FILE * data;if(global_returns_t_or_f()){data=fopen("BadSource_fopen.txt", "w+");fclose(data);}else{data=fopen("BadSource_fopen.txt", "w+");fclose(data);}if(global_returns_t_or_f()){}else{}}
static void main(){char * data;data=NULL;{char data_goodbuf[100];data=data_goodbuf;strcpy(data, "A String");printLine(data);}main_sink(data);}void main_sink(char * data){}
static void main_sink(char * data){{char dest[50]="";memmove(dest, data, strlen(data)*sizeof(char));printLine(data);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;func_ptr(data);}
char * b_main_source(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}char * b_main_source(char * data){strcat(data, "*.*");return data;}
void b_main_sink(short data);static void main(){short data;data=0;data=100-1;b_main_sink(data);}void c_main_sink(short data);void b_main_sink(short data){c_main_sink(data);}void c_main_sink(short data){{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
void b_main_sink();static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;system(data);}
void main_sink(wchar_t * data);static void main(){wchar_t * data;data=new wchar_t[100];main_sink(data);}void main_sink(wchar_t * data){{wchar_t dest[50]=L"";wcscpy(dest, data);printWLine(data);delete [] data;}}
static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}my_union.a=data;{char * data=my_union.b;printf("%s\n", data);}}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){wchar_t * data;wchar_t * &data_ref=data;data=NULL;data=new wchar_t[100];{wchar_t * data=data_ref;delete [] data;}}
void main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];data=NULL;data=new char[100];data_array[2]=data;main_sink(data_array);}void main_sink(char * data_array[]){char * data=data_array[2];{char src[100];memcpy(data, src, 100*sizeof(char));printLine(data);delete [] data;}}
static void main_sink(){int data=_main_data;{int result=-1;if (data <=(INT_MAX/2)){result=data * 2;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}static void main(){int data;data=-1;data=RAND32();_main_data=data;main_sink();}
static void main(){unsigned int data;data=0;data=(unsigned int)RAND32();_main_data=data;b_main_sink();}void b_main_sink(){unsigned int data=_main_data;{unsigned int result=-1;if (data < UINT_MAX){result=data+1;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]="";data=data_buf;{char * data=*data_ptr1;strcat(data, "*.*");}{char * data=*data_ptr2;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}}
static void main(){char data;data=' ';data=(char)rand();b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * data_ptr=(char *)void_data_ptr;char data=(*data_ptr);{char result=-1;if (data <=(CHAR_MAX/2)){result=data * 2;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){twointsclass * data;data=NULL;data=(twointsclass *)malloc(100*sizeof(twointsclass));main_sink_b(data);}void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_c(twointsclass * data){main_sink_d(data);}void main_sink_d(twointsclass * data){free(data);}
static int * main_source(int * data){data=new int[100];delete [] data;return data;}static void main(){int * data;data=NULL;data=main_source(data);}
static void main(){twoints * data;data=NULL;{twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine(&data[0]);}{twoints * data_copy=data;twoints * data=data_copy;}}
void _main_sink(wchar_t * data){{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");_main_sink(data);}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}my_union.a=data;{wchar_t * data=my_union.b;wprintf(L"%s\n", data);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);{int i, n, v;if (sscanf(data, "%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}char * b_main_source(char * data){strcpy(data, "15");return data;}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");my_union.a=data;{char * data=my_union.b;main_vasink(data, data);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static float main_source(float data){data=7.0F;return data;}static void main(){float data;data=0.0F;data=main_source(data);printDoubleLine((double)(100.0/data));}
static void main(){int data;data=-1;data=20;{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");{char * data_copy=data;char * data=data_copy;fprintf(stdout, data);}}
static void main_sink(char * data){{char dest[100];strcpy(dest, data);printLine(dest);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}func_ptr(data);}
static void main(){int data;_struct_type my_struct;data=RAND32();my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{char data_buf[10]="AAAAAAAAA";{printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){long long * data;union_type my_union;data=NULL;data=new long long;my_union.a=data;{long long * data=my_union.b;delete data;}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;{wchar_t * data=*data_ptr1;wcscat(data, L"file.txt");}{wchar_t * data=*data_ptr2;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}}
static void main(){char * data;char data_buf[250]="PATH=";data=data_buf;if(global_returns_t_or_f()){strcat(data, NEW_PATH);}else{strcat(data, NEW_PATH);}PUTENV(data);}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;data=NULL;data=(char *)malloc((10+1)*sizeof(char));func_ptr(data);}void b_main_sink(char * data){{char data_src[10+1]=SRC_STRING;memcpy(data, data_src, strlen(data_src)*sizeof(char));printLine(data);free(data);}}
static void main(){int data;_union_type my_union;data=-1;data=7;my_union.a=data;{int data=my_union.b;printIntLine(100 % data);}}
static void main_sink(int data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=100-1;func_ptr(data);}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");my_union.a=data;{wchar_t * data=my_union.b;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnvp(_P_WAIT, COMMAND_INT, args);}}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100];data=data_buf;{char * data=*data_ptr1;}{char * data=*data_ptr2;{char dest[50]="";strcpy(dest, data);printLine(data);}}}
static void main(){long long * data;data=NULL;main_source(data);free(data);}void main_source(long long * &data){data=(long long *)malloc(100*sizeof(long long));}
static char * main_source(char * data){return data;}static void main(){char * data;data=new char[100];data=main_source(data);{char dest[50]="";strcat(dest, data);printLine(data);delete [] data;}}
void b_main_sink(char * data);static void main(){char * data;data=(char *)malloc(100*sizeof(char));b_main_sink(data);}void b_main_sink(char * data){{char dest[50]="";memmove(dest, data, strlen(data)*sizeof(char));printLine(data);free(data);}}
static void main(){unsigned char data;unsigned char *data_ptr1=&data;unsigned char *data_ptr2=&data;data=' ';{unsigned char data=*data_ptr1;data=5;}{unsigned char data=*data_ptr2;{unsigned char result=data+1;printHexUnsignedCharLine(result);}}}
static void main(){wchar_t * data;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));data=data_buf;}{wchar_t * data_copy=data;wchar_t * data=data_copy;printWLine(data);free(data);}}
static void main(){unsigned int data;_struct_type my_struct;data=0;data=(unsigned int)RAND32();my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){unsigned int data=my_struct.a;{unsigned int result=0;if (data > 0){result=data-1;printUnsignedLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}main_sink(&data);}void main_sink(twointsclass * * data_ptr){twointsclass * data=*data_ptr;printIntLine(data[0].a);}
static void main(){char data;data=' ';data=5;{char result=data-1;printHexCharLine(result);}}
static void main(){char * data;data=NULL;{char mystring[]="mystring";data=strdup(mystring);}main_sink_b(data);}void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){free(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");{wchar_t * data_copy=data;wchar_t * data=data_copy;{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
static void main(){twointsclass * data;data=NULL;data=(twointsclass *)calloc(100, sizeof(twointsclass));main_data=data;main_sink();}void main_sink(){twointsclass * data=main_data;free(data);}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;{char * data=*data_ptr1;strcat(data, "file.txt");}{char * data=*data_ptr2;{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}}
static void main(){int data;int data_array[5];data=-1;data=20;data_array[2]=data;main_sink(data_array);}void main_sink(int data_array[]){int data=data_array[2];{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;strcat(data, "*.*");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;_spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){unsigned char data;unsigned char data_array[5];data=' ';data=5;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(unsigned char data_array[]){unsigned char data=data_array[2];{unsigned char result=data+1;printHexUnsignedCharLine(result);}}
static void main(){twointsclass * data;data=NULL;data=main_source(data);delete [] data;}twointsclass * main_source(twointsclass * data){data=new twointsclass[100];return data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(&data);}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;main_vasink(data, data);}
static void main(){unsigned int data;data=0;data=5;b_main_sink(data);}void b_main_sink(unsigned int data){c_main_sink(data);}void c_main_sink(unsigned int data){d_main_sink(data);}void d_main_sink(unsigned int data){{unsigned int result=data * 2;printUnsignedLine(result);}}
void main_sink_b(char * data);static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){{char dest[100];memcpy(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}{char dest[100]="";SNPRINTF(dest, 100-1, "%s", data);printLine(dest);}}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
void main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];{wchar_t * data_buf=new wchar_t[100];data=data_buf;}data_array[2]=data;main_sink(data_array);}void main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];printWLine(data);delete [] data;}
static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;{char src[100];strcpy(data, src);printLine(data);}}
static void main(){char * data;data=NULL;data=new char[100];delete [] data;}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"15");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main(){unsigned int data;data=0;data=(unsigned int)RAND32();_main_data=data;b_main_sink();}void b_main_sink(){unsigned int data=_main_data;{unsigned int result=-1;if (data <=(unsigned int)sqrt((unsigned int)UINT_MAX)){result=data * data;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, L"%s", args);va_end(args);printWLine(dest);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}main_vasink(data, data);}
void main_sink_b(char * data);static void main(){char * data;data=NULL;data=new char[100];main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_d(char * data);void main_sink_c(char * data){main_sink_d(data);}void main_sink_d(char * data){{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}printLine(data);delete [] data;}}
static void main(){long long * data;data=NULL;data=main_source(data);}long long * main_source(long long * data){long long data_good;data=&data_good;printLongLongLine(*data);return data;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"15");{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main(){int * data;{int * data_buf=(int *)malloc(100*sizeof(int));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}printIntLine(data[0]);free(data);}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
static void main(){int data;fscanf (stdin, "%d", &data);b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}printLine(data);free(data);}}
static void main(){int count;void (*func_ptr) (int)=b_main_sink;count=-1;count=20;func_ptr(count);}void b_main_sink(int count){{size_t i=0;FILE *file=NULL;const char *filename="output_bad.txt";file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}
static void main_sink(char * data){{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");func_ptr(data);}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;strcpy(data, "C:\\Windows\\System32\\winsrv.dll");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{HMODULE hModule;hModule=LoadLibraryA(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{char dest[100]="";SNPRINTF(dest, 100-1, "%s", data);printLine(dest);}}
static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;{char * data_copy=data;char * data=data_copy;{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}printLine(data);}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){if (strstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink();static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{wchar_t dest[50]=L"";memmove(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);}}
static void main(){char * data;union_type my_union;data=NULL;data=new char[100];my_union.a=data;{char * data=my_union.b;delete [] data;}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;if (wcsncmp(PASSWORD, data, wcslen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;strcat(data, "*.*");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
char * b_main_source(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnv(_P_WAIT, COMMAND_INT_PATH, args);}}char * b_main_source(char * data){strcat(data, "*.*");return data;}
static void main(){int data;_union_type my_union;data=-1;data=20;my_union.a=data;{int data=my_union.b;{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){fprintf(stdout, "%s\n", data);}
static void main(){{if (!ImpersonateSelf(SecurityImpersonation)){exit(1);}}}
static void main_sink(){int data=_main_data;{char data_buf[10]="AAAAAAAAA";if (data >=0){printHexCharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}static void main(){int data;data=7;_main_data=data;main_sink();}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;wcscat(data, L"*.*");}{wchar_t * data=*data_ptr2;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}}
static void main_sink(int * data){{int data_src[10]={0};size_t i;for (i=0;i < 10;i++){data[i]=data_src[i];}printIntLine(data[0]);free(data);}}static void main(){int * data;void (*func_ptr) (int *)=main_sink;data=NULL;data=(int *)malloc(10*sizeof(int));func_ptr(data);}
static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));main_sink(data);}void main_sink(long long * data){free(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(float data);static void main(){float data;data=0.0F;data=7.0F;b_main_sink(data);}void c_main_sink(float data);void b_main_sink(float data){c_main_sink(data);}void d_main_sink(float data);void c_main_sink(float data){d_main_sink(data);}void e_main_sink(float data);void d_main_sink(float data){e_main_sink(data);}void e_main_sink(float data){printDoubleLine((double)(100.0/data));}
static void main(){wchar_t * password;wchar_t password_buf[100]=L"";password=password_buf;{size_t password_len=0;fgetws(password, 100, stdin);password_len=wcslen(password);if (password_len > 0){password[password_len-1]=L'\0';}}{wchar_t * password_copy=password;wchar_t * password=password_copy;{HANDLE pHandle;wchar_t * username=L"User";wchar_t * domain=L"Domain";if (LogonUserW( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;_spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));free(data);}
void b_main_sink(int data_array[]);static void main(){int data;int data_array[5];data=-1;data=100-1;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
static void main_sink(){char * data=_main_data;fprintf(stdout, "%s\n", data);}static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}_main_data=data;main_sink();}
static void main(){char * data;data=NULL;data=new char;main_sink(&data);}void main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);printf("%c\n", *data);}
void main_sink(long long * data);static void main(){long long * data;void (*func_ptr) (long long *)=main_sink;{long long * data_buf=new long long[100];{size_t i;for (i=0;i < 100;i++){data_buf[i]=5L;}}data=data_buf;}func_ptr(data);}void main_sink(long long * data){printLongLongLine(data[0]);delete [] data;}
static void main(){struct _twoints * data;struct _twoints * data_array[5];data=NULL;data=NULL;data=(struct _twoints *)realloc(data, 100*sizeof(struct _twoints));data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);data_array[2]=data;b_main_sink(data_array);}void b_main_sink(struct _twoints * data_array[]){struct _twoints * data=data_array[2];free(data);}
void b_main_sink(int data);static void main(){int data;data=-1;data=CHAR_MAX-5;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void d_main_sink(int data);void c_main_sink(int data){d_main_sink(data);}void e_main_sink(int data);void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{short s=(short)data;printf("%hd\n", s);}}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}my_union.a=data;{wchar_t * data=my_union.b;if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}}
static void main(){int data;data=-1;data=100-1;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main(){struct _twoints * data;data=NULL;main_source(data);}void main_source(struct _twoints * &data){{struct _twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);}}
static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));{size_t i;for(i=0;i < 100;i++){data[i]=5L;}}free(data);_main_data=data;b_main_sink();}void b_main_sink(){long long * data=_main_data;}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;main_sink_b(data);}void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_c(twointsclass * data){main_sink_d(data);}void main_sink_d(twointsclass * data){main_sink_e(data);}void main_sink_e(twointsclass * data){delete data;}
void b_main_sink(_struct_type my_struct);static void main(){twoints * data;_struct_type my_struct;twoints * data_badbuf=(twoints *)ALLOCA(50*sizeof(twoints));twoints * data_goodbuf=(twoints *)ALLOCA(100*sizeof(twoints));data=data_goodbuf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){twoints * data=my_struct.a;{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memcpy(data, src, 100*sizeof(twoints));printStructLine(&data[0]);}}
static long long * main_source(long long * data){data=(long long *)malloc(100*sizeof(long long));return data;}static void main(){long long * data;data=NULL;data=main_source(data);{memcpy(data, src, 100*sizeof(long long));printLongLongLine(data[0]);free(data);}}
static void main_sink(long long * data){if (data!=NULL){data[0]=5L;printLongLongLine(data[0]);free(data);}}static void main(){long long * data;void (*func_ptr) (long long *)=main_sink;data=(long long *)malloc(100);func_ptr(data);}
static void main(){char * data;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}{char src[100];memmove(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}
static void main(){char data;data=' ';fscanf (stdin, "%c", &data);{char result=-1;if (data <=(CHAR_MAX/2)){result=data * 2;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){int data;int data_array[5];data=-1;data=20;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}
static void main(){twoints * data;data=(twoints *)malloc(10*sizeof(twoints));{int i;for(i=0;i<10;i++){data[i].a=i;data[i].b=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];{char * data_buf=(char *)malloc(100*sizeof(char));data=data_buf;}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];printLine(data);free(data);}
static void main(){int data;data=-1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{int result=-1;if (data < INT_MAX){result=data+1;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));free(data);}
static void main(){int * data;int * &data_ref=data;data=NULL;data=(int *)calloc(100, sizeof(int));{int * data=data_ref;free(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"C:\\Windows\\System32\\winsrv.dll");{HMODULE hModule;hModule=LoadLibraryW(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){long long * data;data=NULL;data=new long long;delete data;}
static void main_sink(int data){{int result=-1;if (data <=(INT_MAX/2)){result=data * 2;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(void * void_data_ptr);static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));b_main_sink(&data);}void b_main_sink(void * void_data_ptr){long long * * data_ptr=(long long * *)void_data_ptr;long long * data=(*data_ptr);{memcpy(data, src, 100*sizeof(long long));printLongLongLine(data[0]);free(data);}}
static void main(){twointsclass * data;data=NULL;if(global_returns_t_or_f()){{twointsclass data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printIntLine(data[0].a);printIntLine(data[0].b);}}else{{twointsclass data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printIntLine(data[0].a);printIntLine(data[0].b);}}if(global_returns_t_or_f()){}else{}}
static void main(){char * data;data=NULL;data=new char[100];strcpy(data, "A String");printLine(data);main_sink_b(data);}void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){delete[] data;}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;wcscpy(data, L"fixedstringtest");}{wchar_t * data=*data_ptr2;{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, data);printWLine(dest);}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");{char * data_copy=data;char * data=data_copy;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;main_sink_b(data);}void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_c(twointsclass * data){main_sink_d(data);}void main_sink_d(twointsclass * data){main_sink_e(data);}void main_sink_e(twointsclass * data){delete data;}
static int main_source(int data){data=5;return data;}static void main(){int data;data=-1;data=main_source(data);{int result=data * data;printIntLine(result);}}
static void main(){twoints * data;data=NULL;data=new twoints[100];{twoints * data_copy=data;twoints * data=data_copy;delete [] data;}}
static void main(){void * data;data=NULL;data=WIDE_STRING;{size_t data_len=wcslen((wchar_t *)data);void * data_dest=(void *)calloc(data_len+1, sizeof(wchar_t));memcpy(data_dest, data, (data_len+1)*sizeof(wchar_t));printWLine((wchar_t *)data_dest);free(data_dest);}}
static void main_source(int * &data){data=new int;delete data;}static void main(){int * data;data=NULL;main_source(data);}
static char * main_source(char * data){data=PASSWORD;return data;}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;{wchar_t * data_copy=data;wchar_t * data=data_copy;if (wcsncmp(PASSWORD, data, wcslen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}}
static void main(){int data;data=-1;if(global_returns_t_or_f()){data=20;}else{data=20;}if(global_returns_t_or_f()){{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}else{{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}}
void _main_sink(wchar_t * data){PUTENV(data);}static void main(){wchar_t * data;wchar_t data_buf[250]=L"PATH=";data=data_buf;wcscat(data, NEW_PATH);_main_sink(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}void d_main_sink(char * data){main_vasink(data, data);}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;{twointsclass * data_copy=data;twointsclass * data=data_copy;delete data;}}
static void main(){short data;data=0;data=100-1;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}printWLine(data);delete [] data;}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=100-1;}{int data=*data_ptr2;{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}}
void b_main_sink(char * data);static void main(){char * data;data=NULL;data=(char *)malloc((10+1)*sizeof(char));b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{char data_src[10+1]=SRC_STRING;memcpy(data, data_src, strlen(data_src)*sizeof(char));printLine(data);free(data);}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;data=new wchar_t[100];{wchar_t * data=*data_ptr1;}{wchar_t * data=*data_ptr2;{wchar_t dest[50]=L"";wcscpy(dest, data);printWLine(data);delete [] data;}}}
static void main(){int * data;int * data_array[5];data=NULL;data=new int[100];{size_t i;for(i=0;i < 100;i++){data[i]=5;}}data_array[2]=data;main_sink(data_array);}void main_sink(int * data_array[]){int * data=data_array[2];printIntLine(data[0]);}
static void main_sink(){long long * data=main_data;delete [] data;}static void main(){long long * data;data=NULL;data=new long long[100];main_data=data;main_sink();}
static void main(){int data;data=-1;data=5;_main_data=data;b_main_sink();}void b_main_sink(){int data=_main_data;{int result=data * data;printIntLine(result);}}
void b_main_sink(short data);static void main(){short data;data=0;data=100-1;b_main_sink(data);}void c_main_sink(short data);void b_main_sink(short data){c_main_sink(data);}void c_main_sink(short data){{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static short main_source(short data){data=100-1;return data;}static void main(){short data;data=0;data=main_source(data);{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}
static void main_sink(long long * data){delete data;}static void main(){long long * data;void (*func_ptr) (long long *)=main_sink;data=NULL;data=new long long;func_ptr(data);}
static void main(){int data;data=-1;data=20;main_sink_b(data);}void main_sink_b(int data){main_sink_c(data);}void main_sink_c(int data){main_sink_d(data);}void main_sink_d(int data){{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);system(data);}
static void main(){int data;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "C:\\Windows\\System32\\winsrv.dll");{char * data_copy=data;char * data=data_copy;{HMODULE hModule;hModule=LoadLibraryA(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}}
static void main(){wchar_t * data;wchar_t * data_array[5];data=NULL;{wchar_t mystring[]=L"mystring";data=wcsdup(mystring);}data_array[2]=data;main_sink(data_array);}void main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];free(data);}
static void main(){wchar_t * data;union_type my_union;data=NULL;data=new wchar_t[100];my_union.a=data;{wchar_t * data=my_union.b;delete [] data;}}
void _main_sink(wchar_t * data){{wchar_t dest[50]=L"";wcsncpy(dest, data, wcslen(data));printWLine(data);}}static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;_main_sink(data);}
static void main(){{char data_buf[100]="";char * data=data_buf;if (_snprintf(data,100-strlen(SRC)-1, "%s\n", SRC) < 0){printLine("snprintf failed!");}}}
static void main(){unsigned char data;data=' ';data=5;{unsigned char data_copy=data;unsigned char data=data_copy;{unsigned char result=data * 2;printHexUnsignedCharLine(result);}}}
static void main_sink(){int data=_main_data;{size_t i;int *b;b=(int*)malloc(data * sizeof(int));for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);free(b);}}static void main(){int data;data=-1;data=20;_main_data=data;main_sink();}
static void main(){int count;count=-1;if(global_returns_t_or_f()){count=20;}else{count=20;}if(global_returns_t_or_f()){{size_t i=0;FILE *file=NULL;const char *filename="output_bad.txt";file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}else{{size_t i=0;FILE *file=NULL;const char *filename="output_bad.txt";file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]="";data=data_buf;{char * data=*data_ptr1;strcat(data, "*.*");}{char * data=*data_ptr2;EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}}
static void main_sink(twointsclass * data){delete data;}static void main(){twointsclass * data;data=NULL;data=new twointsclass;main_sink(data);}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnvp(_P_WAIT, COMMAND_INT, args);}}
static char * main_source(char * data){return data;}static void main(){char * data;data=new char[100];data=main_source(data);{char dest[50]="";memmove(dest, data, strlen(data)*sizeof(char));printLine(data);delete [] data;}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void b_main_sink(wchar_t * data){_wsystem(data);}
void b_main_sink();static void main(){char * data;char data_badbuf[50];char data_goodbuf[100];data=data_goodbuf;_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}printLine(data);}}
static void main(){{WSADATA wsadata;BOOL wsa_init=FALSE;SOCKET listener=INVALID_SOCKET;SOCKET client=INVALID_SOCKET;struct sockaddr_in s_in;char username[USERNAME_SZ+1];char password[PASSWORD_SZ+1];do{if (0!=WSAStartup(MAKEWORD(2, 2), &wsadata)) break;wsa_init=TRUE;listener=socket(PF_INET, SOCK_STREAM, 0);if (listener==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(LISTEN_PORT);if (SOCKET_ERROR==bind(listener, (struct sockaddr*)&s_in, sizeof(s_in))) break;if (SOCKET_ERROR==listen(listener, LISTEN_BACKLOG)) break;client=accept(listener, NULL, NULL);if (client==INVALID_SOCKET) break;*/if (sizeof(username)-sizeof(char)!=recv(client, username, sizeof(username)-sizeof(char), 0)) break;username[USERNAME_SZ]='\0';if (sizeof(password)-sizeof(char)!=recv(client, password, sizeof(password)-sizeof(char), 0)) break;password[PASSWORD_SZ]='\0';if (strcmp(username, THE_USER)!=0 || strcmp(password, THE_PASSWORD)!=0){char msg[]="Invalid attempt";if (sizeof(msg)-sizeof(char)!=send(client, msg, sizeof(msg)-sizeof(char), 0)) break;}else{char msg[]="Welcome";if (sizeof(msg)-sizeof(char)!=send(client, msg, sizeof(msg)-sizeof(char), 0)) break;}}while (0);if (client!=INVALID_SOCKET) CLOSESOCKET(client);if (listener!=INVALID_SOCKET) CLOSESOCKET(listener);if (wsa_init) WSACleanup();}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=NULL;{char * data=*data_ptr1;data=new char;}{char * data=*data_ptr2;delete data;}}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{FILE *pipe;pipe=POPEN(data, "wb");if (pipe!=NULL) PCLOSE(pipe);}}
static void main(){{twoints data;twoints * pointer=(twoints *)malloc(sizeof(twoints));data.a=1;data.b=2;{twoints data=*pointer;printIntLine(data.a);printIntLine(data.b);}free(pointer);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnvp(_P_WAIT, COMMAND_INT, args);}}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");my_union.a=data;{wchar_t * data=my_union.b;wprintf(data);}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_sink_b(data);}void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_d(wchar_t * data){delete [] data;}
static void main_sink(int * data){if (data!=NULL){data[0]=5;printIntLine(data[0]);free(data);}}static void main(){int * data;data=(int *)realloc(data, 100);main_sink(data);}
static void main_sink(wchar_t * data){{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}func_ptr(data);}
static char main_source(char data){data=5;return data;}static void main(){char data;data=' ';data=main_source(data);{char result=data+1;printHexCharLine(result);}}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, "%s", args);va_end(args);}}static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}my_union.a=data;{char * data=my_union.b;main_vasink(data, data);}}
static void main(){twointsclass * data;{twointsclass * data_buf=new twointsclass[100];{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}{twointsclass * data_copy=data;twointsclass * data=data_copy;printIntLine(data[0].a);delete [] data;}}
void b_main_sink(char * data);static void main(){char * data;data=(char *)malloc(100*sizeof(char));data[0]='\0';{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(data);}void b_main_sink(char * data){{size_t i;for (i=0;i < strlen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}
static void main(){wchar_t * data;data=new wchar_t[100];{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t dest[50]=L"";wcsncpy(dest, data, wcslen(data));printWLine(data);delete [] data;}}}
void main_sink();static void main(){twoints * data;{twoints * data_buf=new twoints[100];{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}_main_data=data;main_sink();}void main_sink(){twoints * data=_main_data;printStructLine(&data[0]);delete [] data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;fprintf(stdout, data);}
static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];fwprintf(stdout, data);}
static void main(){char data;data=' ';data=5;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * data_ptr=(char *)void_data_ptr;char data=(*data_ptr);{char result=data+1;printHexCharLine(result);}}
static void main(){int * data;int * &data_ref=data;data=NULL;data=(int *)malloc(100*sizeof(int));{int * data=data_ref;free(data);}}
static void main(){int data;data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=-1;data=INT_MIN;func_ptr(data);}void b_main_sink(int data){{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
void main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}func_ptr(data);}void main_sink(wchar_t * data){{wchar_t dest[100];memmove(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_t_or_f()){wcscpy(data, L"fixedstringtest");}else{wcscpy(data, L"fixedstringtest");}if(global_returns_t_or_f()){fwprintf(stdout, data);}else{fwprintf(stdout, data);}}
static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){int count;int count_array[5];count=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;count=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}count_array[2]=count;b_main_sink(count_array);}void b_main_sink(int count_array[]){int count=count_array[2];{size_t i=0;FILE *file=NULL;const char *filename="output_good.txt";if (count > 0 && count <=20){file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}}
static void main_sink(FILE * data){}static void main(){FILE * data;void (*func_ptr) (FILE *)=main_sink;data=freopen("BadSource_freopen.txt","w+",stdin);fclose(data);func_ptr(data);}
static void main(){unsigned int data;data=0;data=5;{unsigned int result=data * 2;printUnsignedLine(result);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;wchar_t *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=wcslen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]=L'\0';replace=wcschr(data, L'\r');if (replace) *replace=L'\0';replace=wcschr(data, L'\n');if (replace) *replace=L'\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;fwprintf(stdout, L"%s\n", data);}
static void main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}func_ptr(data);}
static void main_sink(){wchar_t * data=_main_data;wprintf(L"%s\n", data);}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}_main_data=data;main_sink();}
static void main_sink(int data){{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}static void main(){int data;data=-1;data=20;main_sink(data);}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
static void main(){wchar_t * data;wchar_t data_buf[250]=L"PATH=";data=data_buf;if(global_returns_t_or_f()){wcscat(data, NEW_PATH);}else{wcscat(data, NEW_PATH);}PUTENV(data);}
static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");system(data);}
static void main_sink(int data){{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than 0");}}}static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=20;func_ptr(data);}
void b_main_sink(twoints * data_array[]);static void main(){twoints * data;twoints * data_array[5];twoints * data_badbuf=(twoints *)ALLOCA(50*sizeof(twoints));twoints * data_goodbuf=(twoints *)ALLOCA(100*sizeof(twoints));data=data_goodbuf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(twoints * data_array[]){twoints * data=data_array[2];{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memmove(data, src, 100*sizeof(twoints));printStructLine(&data[0]);}}
void b_main_sink(int data);static void main(){int data;data=-1;data=CHAR_MAX-5;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void d_main_sink(int data);void c_main_sink(int data){d_main_sink(data);}void e_main_sink(int data);void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{short s=(short)data;printf("%hd\n", s);}}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");func_ptr(data);}void b_main_sink(char * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];{wchar_t * data_copy=data;wchar_t * data=data_copy;delete [] data;}}
static void main(){long long data;data=5L;printLongLongLine(data);data=10L;printLongLongLine(data);}
static void main(){if(global_returns_t_or_f()){{char * filename;int fd;filename=tempnam(NULL, NULL);printLine(filename);fd=OPEN(filename, O_CREAT|O_EXCL, S_IREAD|S_IWRITE);if (fd!=-1){printLine("Temporary file was opened...now closing file");CLOSE(fd);}if (filename!=NULL){free(filename);}}}else{{char * filename;int fd;filename=tempnam(NULL, NULL);printLine(filename);fd=OPEN(filename, O_CREAT|O_EXCL, S_IREAD|S_IWRITE);if (fd!=-1){printLine("Temporary file was opened...now closing file");CLOSE(fd);}if (filename!=NULL){free(filename);}}}}
static void main(){int data;_union_type my_union;data=-1;data=20;my_union.a=data;{int data=my_union.b;{char * char_string;if (data > 0){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than 0");}}}}
static void main(){int count;count=-1;count=20;{size_t i=0;for (i=0;i < (size_t)count;i++){printLine("Hello");}}}
static void main(){unsigned int data;data=0;fscanf (stdin, "%u", &data);_main_data=data;b_main_sink();}void b_main_sink(){unsigned int data=_main_data;{unsigned int result=-1;if (data <=(unsigned int)sqrt((unsigned int)UINT_MAX)){result=data * data;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, "%s", args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);main_vasink(data, data);}char * b_main_source(char * data){{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}return data;}
void main_sink(char * data);static void main(){char * data;data=new char[100];main_sink(data);}void main_sink(char * data){{char dest[50]="";memmove(dest, data, strlen(data)*sizeof(char));printLine(data);delete [] data;}}
static wchar_t * main_source(wchar_t * data){wcscat(data, L"*.*");return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);_wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){char * data;char data_buf[100];data=data_buf;{char dest[50]="";size_t i, data_len;data_len=strlen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printLine(data);}}
static void main_sink(FILE * data){if (data!=NULL){fclose(data);}}static void main(){FILE * data;data=NULL;data=WFOPEN(L"file.txt", L"w+");main_sink(data);}
static void main_source(char * &data){{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}}static void main(){char * data;data=NULL;main_source(data);{char src[100];memmove(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}
static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");{FILE *pipe;pipe=POPEN(data, "wb");if (pipe!=NULL) PCLOSE(pipe);}}
static void main(){char data;_struct_type my_struct;data=' ';data=5;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char data=my_struct.a;{char result=data * 2;printHexCharLine(result);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t src[100];wcscat(data, src);printWLine(data);}}
static void main(){char data;void (*func_ptr) (char)=b_main_sink;data=' ';fscanf (stdin, "%c", &data);func_ptr(data);}void b_main_sink(char data){{char result=-1;if (data < CHAR_MAX){result=data+1;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;if (wcsncmp(PASSWORD, data, wcslen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}
static void main_sink(long long * data){if (data!=NULL){data[0]=5L;printLongLongLine(data[0]);free(data);}}static void main(){long long * data;void (*func_ptr) (long long *)=main_sink;data=(long long *)calloc(100, sizeof(long long));func_ptr(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");func_ptr(data);}void b_main_sink(wchar_t * data){{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main_sink(){char data=_main_data;{char result=-1;if (data <=(char)sqrt((char)CHAR_MAX)){result=data * data;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}static void main(){char data;data=' ';data=(char)rand();_main_data=data;main_sink();}
static void main(){long long * data;data=NULL;data=new long long[100];main_sink_b(data);}void main_sink_b(long long * data){main_sink_c(data);}void main_sink_c(long long * data){main_sink_d(data);}void main_sink_d(long long * data){main_sink_e(data);}void main_sink_e(long long * data){delete [] data;}
static void main(){twoints * data;_union_type my_union;twoints * data_badbuf=(twoints *)ALLOCA(50*sizeof(twoints));twoints * data_goodbuf=(twoints *)ALLOCA(100*sizeof(twoints));data=data_goodbuf;my_union.a=data;{twoints * data=my_union.b;{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printStructLine(&data[0]);}}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, L"%s", data);printWLine(dest);}}
static void main(){twoints * data;data=NULL;data=new twoints;main_sink_b(data);}void main_sink_b(twoints * data){main_sink_c(data);}void main_sink_c(twoints * data){main_sink_d(data);}void main_sink_d(twoints * data){delete data;}
void b_main_sink(char * data);static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{size_t i, dest_sz;char dest[100];memset(dest, 'C', 100-1);dest_sz=strlen(dest);for (i=0;i < dest_sz;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);free(data);}}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}static void main(){char * data;void (*func_ptr) (char *, ...)=main_vasink;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");func_ptr(data);}
static void main(){{time_t time_val;time(&time_val);if (time_val > TIME_CHECK){printLine("Happy New Year!");}}}
static void main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");func_ptr(data);}
static void main(){wchar_t * data;data=NULL;data=new wchar_t;main_sink_b(data);}void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){main_sink_d(data);}void main_sink_d(wchar_t * data){main_sink_e(data);}void main_sink_e(wchar_t * data){delete data;}
static wchar_t * main_source(wchar_t * data){data=L"P";return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf(data, args);va_end(args);}}void d_main_sink(char * data){main_vasink(data, data);}
static void main(){FILE * data;data=NULL;data=fopen("file.txt", "w+");if(global_returns_t_or_f()){if (data!=NULL){fclose(data);}}else{if (data!=NULL){fclose(data);}}}
void b_main_sink();static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
static void main(){int data;data=-1;if(global_returns_t_or_f()){data=RAND32();}else{data=RAND32();}if(global_returns_t_or_f()){{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}else{{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than the length of the source string or too large");}}}}
static void main_sink(wchar_t * data){delete [] data;}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=NULL;data=new wchar_t[100];func_ptr(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){fwprintf(stdout, L"%s\n", data);}
static void main(){char data;data=' ';fscanf (stdin, "%c", &data);b_main_sink(&data);}void b_main_sink(char * data_ptr){char data=*data_ptr;{char result=-1;if (data < CHAR_MAX){result=data+1;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){twoints * data;twoints * *data_ptr1=&data;twoints * *data_ptr2=&data;data=NULL;{twoints * data=*data_ptr1;data=new twoints[100];}{twoints * data=*data_ptr2;delete [] data;}}
static void main(){twoints * data;data=NULL;data=new twoints;data->a=1;data->b=2;main_sink(&data);}void main_sink(twoints * * data_ptr){twoints * data=*data_ptr;printStructLine(data);}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;fscanf (stdin, "%d", &data);}{int data=*data_ptr2;{int result=-1;if (data <=(INT_MAX/2)){result=data * 2;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=b_main_source(data);{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}wchar_t * b_main_source(wchar_t * data){wcscpy(data, L"15");return data;}
static wchar_t * main_source(wchar_t * data){wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");return data;}static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;data=main_source(data);{HANDLE hFile;hFile=CreateFileW(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main_sink(unsigned char data){{unsigned char result=data+1;printHexUnsignedCharLine(result);}}static void main(){unsigned char data;data=' ';data=5;main_sink(data);}
void b_main_sink();static void main(){wchar_t * data;data=(wchar_t *)malloc(100*sizeof(wchar_t));_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{wchar_t dest[50]=L"";memcpy(dest, data, wcslen(data)*sizeof(wchar_t));printWLine(data);free(data);}}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)calloc(100, sizeof(wchar_t));main_sink(&data);}void main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;free(data);}
static void main_sink(wchar_t * data){{size_t i;for (i=0;i < wcslen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=(wchar_t *)malloc(100*sizeof(wchar_t));data[0]=L'\0';{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}func_ptr(data);}
static void main(){char * data;_union_type my_union;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");my_union.a=data;{char * data=my_union.b;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}}
void main_sink(wchar_t * data){{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}main_sink(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
static short main_source(short data){data=CHAR_MAX-5;return data;}static void main(){short data;data=-1;data=main_source(data);{char c=(char)data;printHexCharLine(c);}}
static void main(){wchar_t * data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t src[100];wcsncpy(data, src, 100);data[100-1]=L'\0';printWLine(data);}}}
static void main(){unsigned int data;data=0;if(global_returns_t_or_f()){data=5;}else{data=5;}if(global_returns_t_or_f()){{unsigned int result=data-1;printUnsignedLine(result);}}else{{unsigned int result=data-1;printUnsignedLine(result);}}}
static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));free(data);_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;}
void b_main_sink(void * void_data_ptr);static void main(){bad_struct data;linked_list head={&head, &head};data.list.next=head.next;data.list.prev=&head;head.next=&data.list;head.next->prev=&data.list;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){bad_struct * data_ptr=(bad_struct *)void_data_ptr;bad_struct data=(*data_ptr);* */prev=data.list.prev;next=data.list.next;prev->next=next;next->prev=prev;}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;{char * data_copy=data;char * data=data_copy;if (strncmp(PASSWORD, data, strlen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}}
static void main_source(wchar_t * &data){wchar_t data_good;data=&data_good;printHexCharLine((char)*data);}static void main(){wchar_t * data;data=NULL;main_source(data);}
static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;wcscpy(data, L"fixedstringtest");}{wchar_t * data=*data_ptr2;main_vasink(data, data);}}
static void main(){int data;data=-1;data=10000;main_data=data;main_sink();}void main_sink(){int data=main_data;{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main_vasinkb(char * data, ...){{va_list args;va_start(args, data);vprintf(data, args);va_end(args);}}static void main_vasinkg(char * data, ...){{va_list args;va_start(args, data);vprintf("%s", args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}main_vasinkg(data, data);}
static twoints * main_source(twoints * data){twoints data_good;data=&data_good;data->a=0;data->b=0;printStructLine(data);return data;}static void main(){twoints * data;data=NULL;data=main_source(data);}
static void main(){wchar_t * data;_union_type my_union;data=NULL;data=(wchar_t *)malloc((10+1)*sizeof(wchar_t));my_union.a=data;{wchar_t * data=my_union.b;{wchar_t data_src[10+1]=SRC_STRING;memmove(data, data_src, wcslen(data_src)*sizeof(wchar_t));printWLine(data);free(data);}}}
void b_main_sink();static void main(){char * password;password="";password=(char *)malloc(100*sizeof(char));if(!VirtualLock(password, 100*sizeof(char))){printLine("Memory could not be locked");exit(1);}strcpy(password, "Password1234!");_main_data=password;b_main_sink();}void b_main_sink(){char * password=_main_data;{HANDLE pHandle;char * username="User";char * domain="Domain";if (LogonUserA( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}
static void main(){int * data;void (*func_ptr) (int *)=b_main_sink;data=NULL;data=(int *)calloc(100, sizeof(int));data[0]=5;printIntLine(data[0]);func_ptr(data);}void b_main_sink(int * data){free(data);}
static void main(){int data;union_type my_union;data=-1;data=20;my_union.a=data;{int data=my_union.b;{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}}
static void main_sink(char data){{char result=-1;if (data <=(char)sqrt((char)CHAR_MAX)){result=data * data;printHexCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}static void main(){char data;void (*func_ptr) (char)=main_sink;data=' ';data=(char)rand();func_ptr(data);}
void _main_sink(char * data){{char dest[100];memset(dest, 'C', 100-1);memmove(dest, data, strlen(dest)*sizeof(char));dest[100-1]='\0';printLine(dest);}}static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;_main_sink(data);}
static void main_sink(){int * data=main_data;delete [] data;}static void main(){int * data;data=NULL;data=new int[100];main_data=data;main_sink();}
static void main(){twoints * data;data=NULL;{twoints tmp;tmp.a=0;tmp.b=0;data=&tmp;}printStructLine(data);}
static void main_sink(){wchar_t * data=main_data;printWLine(data);delete [] data;}static void main(){wchar_t * data;{wchar_t * data_buf=new wchar_t[100];data=data_buf;}main_data=data;main_sink();}
static void main(){twoints * data;data=NULL;if(global_returns_t_or_f()){data=(twoints *)malloc(100*sizeof(twoints));}else{data=(twoints *)malloc(100*sizeof(twoints));}if(global_returns_t_or_f()){free(data);}else{free(data);}}
static void main(){struct _twoints * data;void (*func_ptr) (struct _twoints *)=main_sink;data=NULL;struct _twoints data_good;data=&data_good;data->a=0;data->b=0;printStructLine((twoints *)data);func_ptr(data);}void main_sink(struct _twoints * data){}
void b_main_sink(char * data);static void main(){char * data;data=NULL;data=(char *)malloc((10+1)*sizeof(char));b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{char data_src[10+1]=SRC_STRING;strcpy(data, data_src);printLine(data);free(data);}}
static void main(){void * data;data=NULL;data=CHAR_STRING;{size_t data_len=strlen((char *)data);void * data_dest=(void *)calloc(data_len+1, 1);memcpy(data_dest, data, (data_len+1));printLine((char *)data_dest);free(data_dest);}}
static void main(){int data;_union_type my_union;data=-1;data=5;my_union.a=data;{int data=my_union.b;{int result=data+1;printIntLine(result);}}}
static void main(){int data;data=-1;data=RAND32();b_main_sink(data);}void b_main_sink(int data){{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than the length of the source string or too large");}}}
void main_source(char * &data);static void main(){char * data;data=NULL;main_source(data);{char src[100];memcpy(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}void main_source(char * &data){{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}}
void main_sink(char * data){{char src[100];memcpy(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}main_sink(data);}
static void main(){long long * data;data=NULL;{long long data_goodbuf[100];data=data_goodbuf;data[0]=5L;printLongLongLine(data[0]);}b_main_sink(data);}void b_main_sink(long long * data){c_main_sink(data);}void c_main_sink(long long * data){}
static void main(){unsigned char data;data=' ';data=UCHAR_MAX;b_main_sink(data);}void b_main_sink(unsigned char data){c_main_sink(data);}void c_main_sink(unsigned char data){{unsigned char result=-1;if (data <=(unsigned char)sqrt((unsigned char)UCHAR_MAX)){result=data * data;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
short b_main_source(short data);static void main(){short data;data=0;data=b_main_source(data);{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}short b_main_source(short data){data=100-1;return data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;if (strncmp(PASSWORD, data, strlen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){char * data;char * data_array[5];char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnvp(_P_WAIT, COMMAND_INT, args);}}
static wchar_t * main_source(wchar_t * data){wchar_t data_good;data=&data_good;printHexCharLine((char)*data);return data;}static void main(){wchar_t * data;data=NULL;data=main_source(data);}
static void main_vasinkg(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, "%s", args);va_end(args);}}static void main_vasinkb(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");main_vasinkb(data, data);}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));data=data_buf;}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];printWLine(data);free(data);}
void b_main_sink(char * data);static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{char src[100];memcpy(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");fwprintf(stdout, data);}
static void main(){int data;data=-1;data=5;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){e_main_sink(data);}void e_main_sink(int data){{int result=data+1;printIntLine(result);}}
void b_main_sink(int * data);static void main(){int * data;data=NULL;data=(int *)malloc(10*sizeof(int));b_main_sink(data);}void c_main_sink(int * data);void b_main_sink(int * data){c_main_sink(data);}void d_main_sink(int * data);void c_main_sink(int * data){d_main_sink(data);}void d_main_sink(int * data){{int data_src[10]={0};size_t i;for (i=0;i < 10;i++){data[i]=data_src[i];}printIntLine(data[0]);free(data);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){_wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static long long * main_source(long long * data){data=new long long[100];delete [] data;return data;}static void main(){long long * data;data=NULL;data=main_source(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){{int i, n, v;if (sscanf(data, "%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static void main(){long long * data;union_type my_union;data=NULL;data=new long long;my_union.a=data;{long long * data=my_union.b;delete data;}}
void b_main_sink(long long * data);static void main(){long long * data;{long long * data_buf=(long long *)malloc(100*sizeof(long long));{size_t i;for (i=0;i < 100;i++){data_buf[i]=5L;}}data=data_buf;}b_main_sink(data);}void c_main_sink(long long * data);void b_main_sink(long long * data){c_main_sink(data);}void d_main_sink(long long * data);void c_main_sink(long long * data){d_main_sink(data);}void d_main_sink(long long * data){printLongLongLine(data[0]);free(data);}
static void main(){int data;data=-1;data=RAND32();b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static void main(){twointsclass * data;data=NULL;data=(twointsclass *)calloc(100, sizeof(twointsclass));free(data);}
static long long * main_source(long long * data){data=NULL;data=(long long *)realloc(data, 100*sizeof(long long));data[0]=5L;printLongLongLine(data[0]);return data;}static void main(){long long * data;data=NULL;data=main_source(data);free(data);}
static void main(){long long * data;data=NULL;main_source(data);delete data;}void main_source(long long * &data){data=new long long;}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){if (wcsncmp(PASSWORD, data, wcslen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}{wchar_t dest[100];wcscpy(dest, data);printWLine(dest);}}
static void main(){twointsclass * data;twointsclass * *data_ptr1=&data;twointsclass * *data_ptr2=&data;data=NULL;{twointsclass * data=*data_ptr1;data=new twointsclass[100];}{twointsclass * data=*data_ptr2;{twointsclass src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memcpy(data, src, 100*sizeof(twointsclass));printIntLine(data[0].a);delete [] data;}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;if(global_returns_t_or_f()){data=PASSWORD;}else{data=PASSWORD;}if(global_returns_t_or_f()){if (strstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}else{if (strstr(PASSWORD, data)!=NULL) printLine("Access granted");else printLine("Access denied!");}}
void main_sink(void * void_data_ptr);static void main(){int * data;{int * data_buf=new int[100];{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}main_sink(&data);}void main_sink(void * void_data_ptr){int * * data_ptr=(int * *)void_data_ptr;int * data=(*data_ptr);printIntLine(data[0]);delete [] data;}
void b_main_sink();static void main(){twoints * data;data=(twoints *)realloc(data, 100);_bad_data_for_good_sink=data;b_main_sink();}void b_main_sink(){twoints * data=_bad_data_for_good_sink;if (data!=NULL){data[0].a=1;data[0].b=1;printStructLine(&data[0]);free(data);}}
void main_sink(char * data){{char dest[50]="";strncat(dest, data, strlen(data));printLine(data);delete [] data;}}static void main(){char * data;data=new char[100];main_sink(data);}
static twoints * main_source(twoints * data){{twoints * data_buf=new twoints[100];{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}return data;}static void main(){twoints * data;data=main_source(data);printStructLine(&data[0]);delete [] data;}
static void main(){{if (putc((int)'A', stdout)==EOF){printLine("putc failed!");}}}
void b_main_sink();static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;_spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(&data);}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(data, args);va_end(args);}}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;main_vasink(data, data);}
static void main(){int data;data=-1;data=RAND32();b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{int result=-1;if (data <=(INT_MAX/2)){result=data * 2;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){{FILE *f;f=FOPEN(L"temp.txt", L"w");if (f!=NULL){fwprintf(f, L"Temporary file");fclose(f);}}}
static void main_sink(long long * data){{memcpy(data, src, 100*sizeof(long long));printLongLongLine(data[0]);}}static void main(){long long * data;void (*func_ptr) (long long *)=main_sink;long long data_badbuf[50];long long data_goodbuf[100];data=data_goodbuf;func_ptr(data);}
static void main(){int * data;data=NULL;data=(int *)malloc(100*sizeof(int));main_sink_b(data);}void main_sink_b(int * data){main_sink_c(data);}void main_sink_c(int * data){main_sink_d(data);}void main_sink_d(int * data){main_sink_e(data);}void main_sink_e(int * data){free(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){wprintf(data);}
static void main(){double * data;data=new double[10];if(global_returns_t_or_f()){}else{}if(global_returns_t_or_f()){{int i;for(i=0;i<10;i++){data[i]=(double)i;}}{int i;for(i=0;i<10;i++){printDoubleLine(data[i]);}}delete [] data;}else{{int i;for(i=0;i<10;i++){data[i]=(double)i;}}{int i;for(i=0;i<10;i++){printDoubleLine(data[i]);}}delete [] data;}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{wchar_t dest[50]=L"";wcsncpy(dest, data, wcslen(data));printWLine(data);}}
static void main(){unsigned int data;unsigned int *data_ptr1=&data;unsigned int *data_ptr2=&data;data=0;{unsigned int data=*data_ptr1;data=(unsigned int)RAND32();}{unsigned int data=*data_ptr2;{unsigned int result=-1;if (data <=(unsigned int)sqrt((unsigned int)UINT_MAX)){result=data * data;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;data=PASSWORD;my_union.a=data;{wchar_t * data=my_union.b;if (wcsncmp(PASSWORD, data, wcslen(data))==0) printLine("Access granted");else printLine("Access denied!");}}
static void main(){int data;int data_array[5];data=-1;data=10000;data_array[2]=data;main_sink(data_array);}void main_sink(int data_array[]){int data=data_array[2];{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){int data;data=-1;if(global_returns_t_or_f()){data=100-1;}else{data=100-1;}{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memcpy(dest, src, data);}printLine(dest);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=PASSWORD;b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;main_sink(&data);}void main_sink(twointsclass * * data_ptr){twointsclass * data=*data_ptr;delete data;}
void b_main_sink(char * data);static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;b_main_sink(data);}void b_main_sink(char * data){{char dest[50]="";_snprintf(dest, strlen(data), "%s", data);printLine(data);}}
static void main(){int data;_struct_type my_struct;data=-1;fscanf (stdin, "%d", &data);my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(&data);}static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, data, args);va_end(args);printLine(dest);}}void b_main_sink(char * * data_ptr){char * data=*data_ptr;main_vasink(data, data);}
static void main(){long long * data;data=NULL;data=new long long;main_sink(&data);}void main_sink(void * void_data_ptr){long long * * data_ptr=(long long * *)void_data_ptr;long long * data=(*data_ptr);delete data;}
static void main(){unsigned int data;data=0;fscanf (stdin, "%u", &data);b_main_sink(data);}void b_main_sink(unsigned int data){c_main_sink(data);}void c_main_sink(unsigned int data){d_main_sink(data);}void d_main_sink(unsigned int data){e_main_sink(data);}void e_main_sink(unsigned int data){{unsigned int result=-1;if (data < UINT_MAX){result=data+1;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){twoints * data;void (*func_ptr) (twoints *)=b_main_sink;data=NULL;{twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine(&data[0]);}func_ptr(data);}void b_main_sink(twoints * data){}
static void main(){twoints * data;data=NULL;if(global_returns_t_or_f()){data=new twoints;}else{data=new twoints;}if(global_returns_t_or_f()){delete data;}else{delete data;}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(data);}void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){int * data;data=NULL;main_source(data);delete data;}void main_source(int * &data){data=new int;}
static void main(){int * data;data=NULL;data=NULL;data=(int *)realloc(data, 100*sizeof(int));main_sink_b(data);}void main_sink_b(int * data){main_sink_c(data);}void main_sink_c(int * data){free(data);}
static void main(){int * data;data=NULL;data=new int[100];{size_t i;for(i=0;i < 100;i++){data[i]=5;}}printIntLine(data[0]);}
static void main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}func_ptr(data);}
static void main(){twoints * data;data=NULL;data=new twoints;main_sink_b(data);}void main_sink_b(twoints * data){main_sink_c(data);}void main_sink_c(twoints * data){main_sink_d(data);}void main_sink_d(twoints * data){main_sink_e(data);}void main_sink_e(twoints * data){delete data;}
static void main(){char data;data=' ';data=5;b_main_sink(data);}void b_main_sink(char data){{char result=data+1;printHexCharLine(result);}}
char * b_main_source(char * data);static void main(){char * data;data=(char *)malloc(100*sizeof(char));data=b_main_source(data);{char dest[50]="";strcat(dest, data);printLine(data);free(data);}}char * b_main_source(char * data){return data;}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100];data=data_buf;{char * data=*data_ptr1;}{char * data=*data_ptr2;{char dest[50]="";size_t i, data_len;data_len=strlen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printLine(data);}}}
static void main(){short data;short *data_ptr1=&data;short *data_ptr2=&data;data=0;{short data=*data_ptr1;data=100-1;}{short data=*data_ptr2;{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=NULL;{char * data=*data_ptr1;data=NULL;data=(char *)realloc(data, 100*sizeof(char));strcpy(data, "A String");printLine(data);}{char * data=*data_ptr2;free(data);}}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char data_buf[100];data=data_buf;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{size_t src_len;char src[100];src_len=strlen(src);strncat(data, src, src_len);printLine(data);}}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}
static void main(){if(global_returns_t_or_f()){{char * password=(char *)malloc(100*sizeof(char));size_t password_len=0;HANDLE pHandle;char * username="User";char * domain="Domain";password[0]='\0';fgets(password, 100, stdin);password_len=strlen(password);if (password_len > 0){password[password_len-1]='\0';}if (LogonUserA( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}password_len=strlen(password);SecureZeroMemory(password, password_len * sizeof(char));}}else{{char * password=(char *)malloc(100*sizeof(char));size_t password_len=0;HANDLE pHandle;char * username="User";char * domain="Domain";password[0]='\0';fgets(password, 100, stdin);password_len=strlen(password);if (password_len > 0){password[password_len-1]='\0';}if (LogonUserA( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}password_len=strlen(password);SecureZeroMemory(password, password_len * sizeof(char));}}}
void main_sink(int * data);static void main(){int * data;{int * data_buf=new int[100];{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}main_sink(data);}void main_sink(int * data){printIntLine(data[0]);delete [] data;}
static void main(){int data;data=-1;data=100-1;{if (data < 100){char * data_buf=(char *)malloc(data);memset(data_buf, 'A', data-1);data_buf[data-1]='\0';printLine(data_buf);free(data_buf);}}}
static void main_source(wchar_t * &data){data=new wchar_t[100];}static void main(){wchar_t * data;data=NULL;main_source(data);delete [] data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}
static char * main_source(char * data){strcpy(data, "C:\\Windows\\System32\\winsrv.dll");return data;}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);{HMODULE hModule;hModule=LoadLibraryA(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
void main_sink(void * void_data_ptr);static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}main_sink(&data);}void main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{size_t i;char dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);}}
static void main_sink(twoints * data){delete data;}static void main(){twoints * data;data=NULL;data=new twoints;data->a=0;data->b=0;printStructLine(data);main_sink(data);}
static void main(){twointsclass * data;data=NULL;data=(twointsclass *)malloc(100*sizeof(twointsclass));main_sink(&data);}void main_sink(void * void_data_ptr){twointsclass * * data_ptr=(twointsclass * *)void_data_ptr;twointsclass * data=(*data_ptr);free(data);}
void b_main_sink(int * data);static void main(){int * data;void (*func_ptr) (int *)=b_main_sink;int * data_badbuf=(int *)ALLOCA(50*sizeof(int));int * data_goodbuf=(int *)ALLOCA(100*sizeof(int));data=data_goodbuf;func_ptr(data);}void b_main_sink(int * data){{memcpy(data, src, 100*sizeof(int));printIntLine(data[0]);}}
void b_main_sink(char * * data);static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}printLine(data);free(data);}}
void b_main_sink(void * void_data_ptr);static void main(){int data;data=-1;data=7;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);printIntLine(100 % data);}
void main_sink_b(char * data);static void main(){char * data;{char * data_buf=new char[100];data=data_buf;}main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_d(char * data);void main_sink_c(char * data){main_sink_d(data);}void main_sink_d(char * data){printLine(data);delete [] data;}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]="";data=data_buf;strcat(data, "*.*");func_ptr(data);}void b_main_sink(char * data){EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=FULL_COMMAND;data=data_buf;wcscat(data, L"*.*");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){{FILE *pipe;pipe=POPEN(data, L"wb");if (pipe!=NULL) PCLOSE(pipe);}}
static void main_sink(){twointsclass * data=main_data;free(data);}static void main(){twointsclass * data;data=NULL;data=(twointsclass *)malloc(100*sizeof(twointsclass));main_data=data;main_sink();}
static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, data, args);va_end(args);printLine(dest);}}static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]="";data=data_buf;{char * data=*data_ptr1;strcpy(data, "fixedstringtest");}{char * data=*data_ptr2;main_vasink(data, data);}}
static void main(){int data;data=-1;data=5;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){{int result=data+1;printIntLine(result);}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;main_sink(&data);}void main_sink(twointsclass * * data_ptr){twointsclass * data=*data_ptr;delete data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{wchar_t src[100];wcsncpy(data, src, 100);data[100-1]=L'\0';printWLine(data);}}
static void main(){twoints * data;data=NULL;{twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine(&data[0]);}b_main_sink(data);}void b_main_sink(twoints * data){c_main_sink(data);}void c_main_sink(twoints * data){d_main_sink(data);}void d_main_sink(twoints * data){}
void b_main_sink(char * * data);static void main(){char * data;data=(char *)malloc(100*sizeof(char));data[0]='\0';{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{size_t i;for (i=0;i < strlen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;data=(char *)malloc(100*sizeof(char));data[0]='\0';{char * data=*data_ptr1;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}}{char * data=*data_ptr2;{size_t i;for (i=0;i < strlen(data);i++){if (data[i]==SEARCH_CHAR){printLine("We have a match!");break;}}free(data);}}}
void main_sink_b(char * data);static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_d(char * data);void main_sink_c(char * data){main_sink_d(data);}void main_sink_e(char * data);void main_sink_d(char * data){main_sink_e(data);}void main_sink_e(char * data){{size_t i;char dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);}}
void _main_sink(wchar_t * data){{wchar_t src[100];wcscpy(data, src);printWLine(data);free(data);}}static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));_main_sink(data);}
void _main_sink(char * data){PUTENV(data);}static void main(){char * data;char data_buf[250]="PATH=";data=data_buf;strcat(data, NEW_PATH);_main_sink(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100];data=data_buf;b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t dest[50]=L"";_snwprintf(dest, wcslen(data), L"%s", data);printWLine(data);}}
static void main(){unsigned int data;data=0;data=5;{unsigned int data_copy=data;unsigned int data=data_copy;{unsigned int result=data+1;printUnsignedLine(result);}}}
static twointsclass * main_source(twointsclass * data){data=new twointsclass[100];return data;}static void main(){twointsclass * data;data=NULL;data=main_source(data);delete [] data;}
static void main(){int * data;data=NULL;data=new int;delete data;{int * data_copy=data;int * data=data_copy;}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t;main_sink_b(data);}void main_sink_b(wchar_t * data){main_sink_c(data);}void main_sink_c(wchar_t * data){delete data;}
static int main_source(int data){data=100-1;return data;}static void main(){int data;data=-1;data=main_source(data);{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf("%s", args);va_end(args);}}static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}{char * data_copy=data;char * data=data_copy;main_vasink(data, data);}}
static twoints * main_source(twoints * data){data=new twoints;data->a=1;data->b=2;return data;}static void main(){twoints * data;data=NULL;data=main_source(data);printStructLine(data);}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{size_t i;char dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){struct _twoints * data;data=NULL;data=b_main_source(data);free(data);}struct _twoints * b_main_source(struct _twoints * data){data=(struct _twoints *)calloc(100, sizeof(struct _twoints));data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);return data;}
void b_main_sink(char * data);static void main(){char * data;data=(char *)malloc(100*sizeof(char));b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void c_main_sink(char * data){{char dest[50]="";memmove(dest, data, strlen(data)*sizeof(char));printLine(data);free(data);}}
static long long * main_source(long long * data){data=new long long[100];return data;}static void main(){long long * data;data=NULL;data=main_source(data);delete [] data;}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;{char dest[100];memmove(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
void b_main_sink();static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{wchar_t src[100];wcscpy(data, src);printWLine(data);free(data);}}
static void main(){{int data;int * pointer=(int *)malloc(sizeof(int));data=5;{int data=*pointer;printIntLine(data);}free(pointer);}}
static void main_sink(){int data=_main_data;{wchar_t data_buf[10]=L"AAAAAAAAA";if (data >=0){printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}static void main(){int data;data=7;_main_data=data;main_sink();}
static void main(){wchar_t * data;wchar_t * &data_ref=data;data=NULL;data=(wchar_t *)calloc(100, sizeof(wchar_t));{wchar_t * data=data_ref;free(data);}}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"C:\\Windows\\System32\\winsrv.dll");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){{HMODULE hModule;hModule=LoadLibraryW(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
static void main_sink(int data){{int result=data-1;printIntLine(result);}}static void main(){int data;data=-1;data=5;main_sink(data);}
void b_main_sink(_struct_type my_struct);static void main(){int * data;_struct_type my_struct;int data_badbuf[50];int data_goodbuf[100];data=data_goodbuf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int * data=my_struct.a;{memcpy(data, src, 100*sizeof(int));printIntLine(data[0]);}}
static void main(){int data;if(global_returns_t_or_f()){data=7;}else{data=7;}if(global_returns_t_or_f()){{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}else{{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}}
static void main_sink(twointsclass * data){printIntLine(data[0].a);}static void main(){twointsclass * data;void (*func_ptr) (twointsclass *)=main_sink;data=NULL;{twointsclass * tmp=new twointsclass;tmp->a=0;tmp->b=0;data=tmp;}func_ptr(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){char * data;union_type my_union;data=NULL;data=new char[100];memset(data, 'A', 100-1);data[100-1]='\0';my_union.a=data;{char * data=my_union.b;printLine(data);}}
static void main_sink(char * data){_spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char data_buf[100]="";data=data_buf;strcat(data, "*.*");func_ptr(data);}
static void main(){wchar_t * data;data=NULL;{wchar_t mystring[]=L"mystring";data=wcsdup(mystring);}{wchar_t * data_copy=data;wchar_t * data=data_copy;free(data);}}
static void main_sink(char * data){{char src[100];memcpy(data, src, 100*sizeof(char));printLine(data);}}static void main(){char * data;void (*func_ptr) (char *)=main_sink;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;func_ptr(data);}
static void main_sink(char * data){printLine(data);free(data);}static void main(){char * data;void (*func_ptr) (char *)=main_sink;{char * data_buf=(char *)malloc(100*sizeof(char));data=data_buf;}func_ptr(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, L"%s", args);va_end(args);printWLine(dest);}}void c_main_sink(wchar_t * data){main_vasink(data, data);}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *, ...)=b_main_vasink;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}func_ptr(data);}void b_main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, L"%s", args);va_end(args);}}
static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));b_main_sink(&data);}void b_main_sink(void * void_data_ptr){long long * * data_ptr=(long long * *)void_data_ptr;long long * data=(*data_ptr);free(data);}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char * data_buf=(char *)ALLOCA(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';{char * data=*data_ptr1;data=data_buf;}{char * data=*data_ptr2;{char dest[100];strncpy(dest, data, strlen(dest));dest[100-1]='\0';printLine(dest);}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}fprintf(stdout, "%s\n", data);}
static void main(){if(global_returns_t_or_f()){{wchar_t data_buf[100]=L"";wchar_t * data=data_buf;if (_snwprintf(data,100-wcslen(SRC)-1, L"%s\n", SRC) < 0){printLine("snwprintf failed!");exit(1);}}}else{{wchar_t data_buf[100]=L"";wchar_t * data=data_buf;if (_snwprintf(data,100-wcslen(SRC)-1, L"%s\n", SRC) < 0){printLine("snwprintf failed!");exit(1);}}}}
static void main(){long long * data;data=NULL;long long data_good;data=&data_good;printLongLongLine(*data);}
static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, L"%s", args);va_end(args);printWLine(dest);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}{wchar_t * data_copy=data;wchar_t * data=data_copy;main_vasink(data, data);}}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");my_union.a=data;{wchar_t * data=my_union.b;EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}}
static void main(){twointsclass * data;data=new twointsclass[10];for(int i=0;i<10;i++){data[i].a=i;data[i].b=i;}for(int i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;{int data=*data_ptr1;data=7;}{int data=*data_ptr2;{wchar_t data_buf[10]=L"AAAAAAAAA";if (data >=0){printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}}
void _main_sink(int data){printIntLine(100 % data);}static void main(){int data;data=-1;data=7;_main_sink(data);}
static void main(){int data;void (*func_ptr) (int)=b_main_sink;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}func_ptr(data);}void b_main_sink(int data){{wchar_t data_buf[10]=L"AAAAAAAAA";{printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}
static void main(){int data;data=-1;if(global_returns_t_or_f()){data=100-1;}else{data=100-1;}{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main(){int count;void (*func_ptr) (int)=b_main_sink;count=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;count=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}func_ptr(count);}void b_main_sink(int count){{size_t i=0;if (count > 0 && count <=20){for (i=0;i < (size_t)count;i++){printLine("Hello");}}}}
static void main_sink(){int data=_main_data;{int result=data+1;printIntLine(result);}}static void main(){int data;data=-1;data=5;_main_data=data;main_sink();}
static void main_sink(){wchar_t * data=_main_data;{size_t i;wchar_t dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]=L'\0';printWLine(dest);}}static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;_main_data=data;main_sink();}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");func_ptr(data);}void b_main_sink(wchar_t * data){wprintf(data);}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];{char src[100];strncat(data, src, 100);printLine(data);}}
static void main(){unsigned int data;data=0;data=UINT_MAX;b_main_sink(data);}void b_main_sink(unsigned int data){{unsigned int result=-1;if (data < UINT_MAX){result=data+1;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main_sink(twointsclass * data){}static void main(){twointsclass * data;void (*func_ptr) (twointsclass *)=main_sink;data=NULL;data=new twointsclass[100];delete [] data;func_ptr(data);}
void _main_sink(wchar_t * data){{wchar_t src[100];wcsncpy(data, src, 100);data[100-1]=L'\0';printWLine(data);}}static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}_main_sink(data);}
void b_main_sink(float data);static void main(){float data;data=0.0F;data=7.0F;b_main_sink(data);}void b_main_sink(float data){printDoubleLine((double)(100.0/data));}
static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, L"%s", args);va_end(args);printWLine(dest);}}static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100]=L"";data=data_buf;{wchar_t * data=*data_ptr1;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}}{wchar_t * data=*data_ptr2;main_vasink(data, data);}}
static void main(){long long * data;data=NULL;data=(long long *)malloc(100*sizeof(long long));main_sink(&data);}void main_sink(void * void_data_ptr){long long * * data_ptr=(long long * *)void_data_ptr;long long * data=(*data_ptr);free(data);}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");b_main_sink(data);}void c_main_sink(wchar_t * data);void b_main_sink(wchar_t * data){c_main_sink(data);}void d_main_sink(wchar_t * data);void c_main_sink(wchar_t * data){d_main_sink(data);}void e_main_sink(wchar_t * data);void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
static void main(){int data;data=-1;data=5;{int result=data-1;printIntLine(result);}}
static int main_source(int data){data=CHAR_MAX-5;return data;}static void main(){int data;data=-1;data=main_source(data);{short s=(short)data;printf("%hd\n", s);}}
static void main(){twoints * data;data=NULL;data=new twoints;delete data;}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));printWLine(data);}}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));printWLine(data);free(data);}}
static void main(){int data;int data_array[5];data=7;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{wchar_t data_buf[10]=L"AAAAAAAAA";if (data >=0){printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
char * b_main_source(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}char * b_main_source(char * data){strcat(data, "*.*");return data;}
void b_main_sink(char * data);static void main(){char * data;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}b_main_sink(data);}void b_main_sink(char * data){{char dest[100];memcpy(dest, data, 100*sizeof(char));dest[100-1]='\0';printLine(dest);}}
void main_sink();static void main(){int data;data=-1;data=20;_main_data=data;main_sink();}void main_sink(){int data=_main_data;{size_t a,i;int *b;b=(int*)new char[a];for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);delete [] b;}}
static void main(){char * data;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));if(global_returns_t_or_f()){data=data_goodbuf;}else{data=data_goodbuf;}{char src[100];strncpy(data, src, 100);printLine(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;{wchar_t src[100];memmove(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}
static void main(){int data;_struct_type my_struct;data=-1;data=20;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{char * char_string;if (data > 0){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than 0");}}}
static void main(){list<int> data;data.push_back(100);data.push_back(200);{list<int>::iterator i;cout << "The list contains: ";for( i=data.begin();i!=data.end();i++){if (!*i){data.clear();}cout << " " << *i;}cout << endl;}}
static void main_sink(HANDLE data){if (data!=INVALID_HANDLE_VALUE){CloseHandle(data);}}static void main(){HANDLE data;data=INVALID_HANDLE_VALUE;data=CreateFile("BadSource_w32CreateFile.txt", (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);main_sink(data);}
static void main(){int * data;_union_type my_union;data=(int *)realloc(data, 100);my_union.a=data;{int * data=my_union.b;if (data!=NULL){data[0]=5;printIntLine(data[0]);free(data);}}}
static void main_sink(){int data=_main_data;{char c=(char)data;printHexCharLine(c);}}static void main(){int data;data=-1;data=CHAR_MAX-5;_main_data=data;main_sink();}
static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=-1;data=5;func_ptr(data);}void b_main_sink(int data){{int result=data * data;printIntLine(result);}}
static void main(){double * data;data=(double *)malloc(10*sizeof(double));{int i;for(i=0;i<10;i++){data[i]=(double)i;}}b_main_sink(&data);}void b_main_sink(double * * data_ptr){double * data=*data_ptr;{int i;for(i=0;i<10;i++){printDoubleLine(data[i]);}}}
static void main_source(twoints * &data){{int i;for(i=0;i<(10/2);i++){data[i].a=i;data[i].b=i;}}}static void main(){twoints * data;data=new twoints[10];main_source(data);{int i;for(i=0;i<10;i++){data[i].a=i;data[i].b=i;}}{int i;for(i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}delete [] data;}
static void main(){twoints * data;twoints * *data_ptr1=&data;twoints * *data_ptr2=&data;{twoints * data=*data_ptr1;data=(twoints *)realloc(data, 100);}{twoints * data=*data_ptr2;if (data!=NULL){data[0].a=1;data[0].b=1;printStructLine(&data[0]);free(data);}}}
static void main(){int data;int data_array[5];data=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{wchar_t * wchar_t_string;if ((size_t)data > wcslen(HELLO_STRING) && data < 100){wchar_t_string=(wchar_t *)malloc(data*sizeof(wchar_t));wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);free(wchar_t_string);}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){wchar_t * data;union_type my_union;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}my_union.a=data;{wchar_t * data=my_union.b;{wchar_t dest[100];memcpy(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}}
static void main(){long long * data;data=NULL;if(global_returns_t_or_f()){data=(long long *)malloc(100*sizeof(long long));}else{data=(long long *)malloc(100*sizeof(long long));}{memcpy(data, src, 100*sizeof(long long));printLongLongLine(data[0]);free(data);}}
static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;data=PASSWORD;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;if (strncmp(PASSWORD, data, strlen(data))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=20;}{int data=*data_ptr2;{size_t i;int *b;b=(int*)malloc(data * sizeof(int));for (i=0;i < (size_t)data;i++){}printIntLine(b[0]);free(b);}}}
static void main(){unsigned int data;unsigned int *data_ptr1=&data;unsigned int *data_ptr2=&data;data=0;{unsigned int data=*data_ptr1;data=(unsigned int)RAND32();}{unsigned int data=*data_ptr2;{unsigned int result=-1;if (data < UINT_MAX){result=data+1;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
static void main(){int data;data=-1;fscanf (stdin, "%d", &data);{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}
static void main(){int data;data=b_main_source(data);{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0 && data < 10){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is out-of-bounds");}}}int b_main_source(int data){{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}return data;}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;if(global_returns_t_or_f()){wcscat(data, L"file.txt");}else{wcscat(data, L"file.txt");}{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
static void main_sink(){twointsclass * data=main_data;{twointsclass src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memcpy(data, src, 100*sizeof(twointsclass));printIntLine(data[0].a);delete [] data;}}static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];main_data=data;main_sink();}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"15");{int i, n, v;if (swscanf(data, L"%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}
static void main(){char * data;char data_buf[100];data=data_buf;if(global_returns_t_or_f()){}else{}{char dest[50]="";memcpy(dest, data, strlen(data)*sizeof(char));printLine(data);}}
static void main(){char * data;data=NULL;data=new char;delete data;{char * data_copy=data;char * data=data_copy;}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;strcat(data, "*.*");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void e_main_sink(char * data);void d_main_sink(char * data){e_main_sink(data);}void e_main_sink(char * data){system(data);}
static void main_sink(int data){{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}static void main(){int data;data=-1;fscanf (stdin, "%d", &data);main_sink(data);}
void b_main_sink(twoints * * data);static void main(){twoints * data;{twoints * data_buf=(twoints *)malloc(100*sizeof(twoints));{size_t i;for (i=0;i < 100;i++){data_buf[i].a=1;data_buf[i].b=1;}}data=data_buf;}b_main_sink(&data);}void b_main_sink(twoints * * data_ptr){twoints * data=*data_ptr;printStructLine(&data[0]);free(data);}
static void main_vasinkb(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, data, args);va_end(args);printWLine(dest);}}static void main_vasinkg(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, L"%s", args);va_end(args);printWLine(dest);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_t_or_f()){{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}}else{{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}}if(global_returns_t_or_f()){main_vasinkg(data, data);}else{main_vasinkg(data, data);}}
void b_main_sink(void * void_data_ptr);static void main(){FILE * data;data=NULL;data=fopen("file.txt", "w+");b_main_sink(&data);}void b_main_sink(void * void_data_ptr){FILE * * data_ptr=(FILE * *)void_data_ptr;FILE * data=(*data_ptr);if (data!=NULL){fclose(data);}}
static void main(){char * data;char * data_array[5];char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];fprintf(stdout, "%s\n", data);}
static void main(){int count;count=-1;fscanf (stdin, "%d", &count);{size_t i=0;FILE *file=NULL;const char *filename="output_good.txt";if (count > 0 && count <=20){file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}}
static void main(){unsigned char data;data=' ';data=5;b_main_sink(data);}void b_main_sink(unsigned char data){c_main_sink(data);}void c_main_sink(unsigned char data){d_main_sink(data);}void d_main_sink(unsigned char data){e_main_sink(data);}void e_main_sink(unsigned char data){{unsigned char result=data+1;printHexUnsignedCharLine(result);}}
static void main(){int * data;data=NULL;if(global_returns_t_or_f()){data=(int *)malloc(100*sizeof(int));}else{data=(int *)malloc(100*sizeof(int));}if(global_returns_t_or_f()){free(data);}else{free(data);}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';{wchar_t * data=*data_ptr1;data=data_buf;}{wchar_t * data=*data_ptr2;{wchar_t src[100];memcpy(data, src, 100*sizeof(wchar_t));data[100-1]=L'\0';printWLine(data);}}}
static void main(){int data;struct_type my_struct;data=-1;data=20;my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){int data=my_struct.a;{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "C:\\Windows\\System32\\winsrv.dll");b_main_sink(data);}void b_main_sink(char * data){{HMODULE hModule;hModule=LoadLibraryA(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main_sink(wchar_t * data){free(data);}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;data=NULL;data=(wchar_t *)malloc(100*sizeof(wchar_t));func_ptr(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, data);printWLine(dest);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}{int i, n, v;if (sscanf(data, "%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;if(global_returns_t_or_f()){strcat(data, "*.*");}else{strcat(data, "*.*");}_spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}
static void main(){{HANDLE hMutex=NULL;hMutex=CreateMutexW(NULL, FALSE, NULL);if (hMutex==NULL){exit(1);}if (GetLastError()==ERROR_ALREADY_EXISTS){exit(1);}CloseHandle(hMutex);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);{int i, n, v;if (sscanf(data, "%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}char * b_main_source(char * data){{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}return data;}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;if(global_returns_t_or_f()){wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");}else{wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");}{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
int b_main_source(int data);static void main(){int data;data=-1;data=b_main_source(data);assert(data > ASSERT_VALUE);}int b_main_source(int data){data=ASSERT_VALUE+1;return data;}
static void main(){wchar_t * data;wchar_t data_buf[250]=L"PATH=";data=data_buf;if(global_returns_t_or_f()){wcscat(data, NEW_PATH);}else{wcscat(data, NEW_PATH);}PUTENV(data);}
void b_main_sink(char * data);static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "C:\\Windows\\System32\\winsrv.dll");b_main_sink(data);}void c_main_sink(char * data);void b_main_sink(char * data){c_main_sink(data);}void d_main_sink(char * data);void c_main_sink(char * data){d_main_sink(data);}void d_main_sink(char * data){{HMODULE hModule;hModule=LoadLibraryA(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}
void b_main_sink();static void main(){wchar_t * data;wchar_t data_buf[250]=L"PATH=";data=data_buf;wcscat(data, NEW_PATH);_main_data=data;b_main_sink();}void b_main_sink(){wchar_t * data=_main_data;PUTENV(data);}
static void main(){int data;void (*func_ptr) (int)=main_sink;data=-1;data=20;func_ptr(data);}void main_sink(int data){{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}
static void main(){if(global_returns_t_or_f()){printLine("Hello");}else{printLine("Hello");}}
wchar_t * b_main_source(wchar_t * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;data=b_main_source(data);{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}wchar_t * b_main_source(wchar_t * data){wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");return data;}
static char * main_source(char * data){strcpy(data, GOOD_OS_COMMAND);return data;}static void main(){char * data;char data_buf[100]="";data=data_buf;data=main_source(data);system(data);}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;{wchar_t * data=*data_ptr1;}{wchar_t * data=*data_ptr2;{wchar_t dest[50]=L"";size_t i, data_len;data_len=wcslen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printWLine(data);}}}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
static void main(){short data;data=-1;data=CHAR_MAX-5;{char c=(char)data;printHexCharLine(c);}}
static void main(){int * data;data=NULL;if(global_returns_t_or_f()){data=new int;}else{data=new int;}if(global_returns_t_or_f()){delete data;}else{delete data;}}
static void main(){twointsclass * data;data=NULL;main_source(data);}void main_source(twointsclass * &data){{twointsclass data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printIntLine(data[0].a);printIntLine(data[0].b);}}
char * b_main_source(char * data);static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;data=b_main_source(data);system(data);}char * b_main_source(char * data){strcat(data, "*.*");return data;}
static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");{char * data_copy=data;char * data=data_copy;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}}
void b_main_sink(void * void_data_ptr);static void main(){char * data;data=(char *)realloc(data, 100);b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);if (data!=NULL){strcpy(data, "Initialize");printLine(data);free(data);}}
static void main(){int data;int data_array[5];data=7;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{wchar_t data_buf[10]=L"AAAAAAAAA";if (data >=0){printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main(){int data;data=7;b_main_sink(data);}void b_main_sink(int data){{int data_buf[10]={0,1,2,3,4,5,6,7,8,9};if (data >=0){printIntLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]="";data=data_buf;{char * data=*data_ptr1;strcpy(data, "C:\\Windows\\System32\\winsrv.dll");}{char * data=*data_ptr2;{HMODULE hModule;hModule=LoadLibraryA(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}}
static void main(){char data;data=' ';data=b_main_source(data);{char result=data-1;printHexCharLine(result);}}char b_main_source(char data){data=5;return data;}
static void main(){twoints * data;data=NULL;data=main_source(data);delete data;}twoints * main_source(twoints * data){data=new twoints;return data;}
static void main(){int data;int data_array[5];data=-1;{char input_buf[CHAR_ARRAY_SIZE]="";fgets(input_buf, CHAR_ARRAY_SIZE, stdin);data=atoi(input_buf);}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=(char *)malloc(data*sizeof(char));strcpy(char_string, HELLO_STRING);printLine(char_string);free(char_string);}else{printLine("Input is less than the length of the source string or too large");}}}
static void main_source(twoints * &data){data=new twoints[100];}static void main(){twoints * data;data=NULL;main_source(data);delete [] data;}
static void main(){if(global_returns_t_or_f()){{if (fputc((int)'A', stdout)==EOF){printLine("fputc failed!");}}}else{{if (fputc((int)'A', stdout)==EOF){printLine("fputc failed!");}}}}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");func_ptr(data);}void b_main_sink(char * data){{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[FILENAME_MAX]=L"";data=data_buf;{wchar_t * data=*data_ptr1;wcscpy(data, L"c:\\temp\\file.txt");wcscpy(data, L"/tmp/file.txt");}{wchar_t * data=*data_ptr2;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}}
void main_sink(long long * data_array[]);static void main(){long long * data;long long * data_array[5];data=NULL;data=new long long[100];data_array[2]=data;main_sink(data_array);}void main_sink(long long * data_array[]){long long * data=data_array[2];{memcpy(data, src, 100*sizeof(long long));printLongLongLine(data[0]);delete [] data;}}
void b_main_sink(char * password);static void main(){char * password;void (*func_ptr) (char *)=b_main_sink;char password_buf[100]="";password=password_buf;strcpy(password, "Password1234!");func_ptr(password);}void b_main_sink(char * password){{HANDLE pHandle;char * username="User";char * domain="Domain";if (LogonUserA( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}
static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;data=NULL;{wchar_t data_goodbuf[100];data=data_goodbuf;wcscpy(data, L"A String");printWLine(data);}func_ptr(data);}void b_main_sink(wchar_t * data){}
void b_main_sink(_struct_type my_struct);static void main(){char * data;_struct_type my_struct;char data_buf[100]="";data=data_buf;strcat(data, "*.*");my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){char * data=my_struct.a;{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_spawnvp(_P_WAIT, COMMAND_INT, args);}}
static wchar_t * main_source(wchar_t * data){wcscpy(data, L"fixedstringtest");return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);wprintf(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(&data);}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);main_vasink(data, data);}
static void main(){if(global_returns_t_or_f()){{char password[100]="";size_t password_len=0;HANDLE pHandle;char * username="User";char * domain="Domain";FILE * file=fopen("debug.txt", "a+");fgets(password, 100, stdin);password_len=strlen(password);if (password_len > 0){password[password_len-1]='\0';}if (LogonUserA( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}fprintf(file, "User attempted access\n");fclose(file);}}else{{char password[100]="";size_t password_len=0;HANDLE pHandle;char * username="User";char * domain="Domain";FILE * file=fopen("debug.txt", "a+");fgets(password, 100, stdin);password_len=strlen(password);if (password_len > 0){password[password_len-1]='\0';}if (LogonUserA( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}fprintf(file, "User attempted access\n");fclose(file);}}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscpy(data, L"fixedstringtest");b_main_sink(data);}void b_main_sink(wchar_t * data){c_main_sink(data);}void c_main_sink(wchar_t * data){d_main_sink(data);}void d_main_sink(wchar_t * data){e_main_sink(data);}void e_main_sink(wchar_t * data){{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, data);printWLine(dest);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};_wspawnv(_P_WAIT, COMMAND_INT_PATH, args);}}
static void main(){twointsclass * data;data=NULL;twointsclass data_good;data=&data_good;data->a=0;data->b=0;printIntLine(data->a);printIntLine(data->b);main_sink(&data);}void main_sink(void * void_data_ptr){twointsclass * * data_ptr=(twointsclass * *)void_data_ptr;twointsclass * data=(*data_ptr);}
static void main(){twointsclass * data;data=new twointsclass[10];for(int i=0;i<10;i++){data[i].a=i;data[i].b=i;}for(int i=0;i<10;i++){printIntLine(data[i].a);printIntLine(data[i].b);}}
static void main(){twoints * data;data=NULL;data=(twoints *)calloc(100, sizeof(twoints));free(data);}
static void main_sink(){twoints * data=main_data;delete [] data;}static void main(){twoints * data;data=NULL;data=new twoints[100];main_data=data;main_sink();}
static void main(){long long * data;_union_type my_union;long long data_badbuf[50];long long data_goodbuf[100];data=data_goodbuf;my_union.a=data;{long long * data=my_union.b;{memmove(data, src, 100*sizeof(long long));printLongLongLine(data[0]);}}}
static void main(){wchar_t * data;data=NULL;data=(wchar_t *)calloc(100, sizeof(wchar_t));main_sink(&data);}void main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;free(data);}
static void main(){int data;data=-1;fscanf (stdin, "%d", &data);b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{int result=-1;if (data <=(int)sqrt((int)INT_MAX)){result=data * data;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET connect_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}fprintf(stdout, "%s\n", data);}
static void main_sink(wchar_t * data){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=L"P";main_sink(data);}
void b_main_sink();static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t src[100];wcscpy(data, src);printWLine(data);}}
static void main(){char data;char data_array[5];data=' ';data=5;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char data_array[]){char data=data_array[2];{char result=data * data;printHexCharLine(result);}}
static void main(){int data;data=-1;data=100-1;{int data_copy=data;int data=data_copy;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){strncpy(dest, src, data);}printLine(dest);}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);fprintf(stdout, "%s\n", data);}char * b_main_source(char * data){{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}return data;}
static void main(){twoints * data;data=NULL;data=new twoints[100];delete [] data;}
static void main(){char data;data=' ';data=5;b_main_sink(&data);}void b_main_sink(char * data_ptr){char data=*data_ptr;{char result=data-1;printHexCharLine(result);}}
static void main(){int data;data=-1;data=5;b_main_sink(data);}void b_main_sink(int data){c_main_sink(data);}void c_main_sink(int data){{int result=data+1;printIntLine(result);}}
static void main(){wchar_t * data;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}data[100-1]=L'\0';printWLine(data);}}
static void main(){if(global_returns_t_or_f()){{if (putwc((wchar_t)L'A', stdout)==WEOF){printLine("putwc failed!");exit(1);}}}else{{if (putwc((wchar_t)L'A', stdout)==WEOF){printLine("putwc failed!");exit(1);}}}}
void b_main_sink(int * data);static void main(){int * data;int * data_badbuf=(int *)ALLOCA(50*sizeof(int));int * data_goodbuf=(int *)ALLOCA(100*sizeof(int));data=data_goodbuf;b_main_sink(data);}void c_main_sink(int * data);void b_main_sink(int * data){c_main_sink(data);}void d_main_sink(int * data);void c_main_sink(int * data){d_main_sink(data);}void d_main_sink(int * data){{memmove(data, src, 100*sizeof(int));printIntLine(data[0]);}}
static void main_sink(){char * data=_main_data;{HMODULE hModule;hModule=LoadLibraryA(data);if (hModule!=NULL){FreeLibrary(hModule);printLine("Library loaded and freed successfully");}else{printLine("Unable to load library");}}}static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "C:\\Windows\\System32\\winsrv.dll");_main_data=data;main_sink();}
void b_main_sink(_struct_type my_struct);static void main(){int data;_struct_type my_struct;data=-1;data=100-1;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){int data=my_struct.a;{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main_sink(){wchar_t * data=main_data;delete data;}static void main(){wchar_t * data;data=NULL;data=new wchar_t;main_data=data;main_sink();}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_badbuf[50];wchar_t data_goodbuf[100];data=data_goodbuf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{wchar_t dest[100];wmemset(dest, L'C', 100-1);memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
void main_sink(long long * data){{memcpy(data, src, 100*sizeof(long long));printLongLongLine(data[0]);delete [] data;}}static void main(){long long * data;data=NULL;data=new long long[100];main_sink(data);}
static void main(){wchar_t * data;data=L"string";printWLine(data);}
static void main(){wchar_t * data;{wchar_t * data_buf=(wchar_t *)malloc(100*sizeof(wchar_t));data=data_buf;}printWLine(data);free(data);}
void b_main_sink(void * void_data_ptr);static void main(){twoints * data;data=NULL;data=(twoints *)malloc(100*sizeof(twoints));b_main_sink(&data);}void b_main_sink(void * void_data_ptr){twoints * * data_ptr=(twoints * *)void_data_ptr;twoints * data=(*data_ptr);{twoints src[100];{size_t i;for (i=0;i < 100;i++){src[i].a=0;src[i].b=0;}}memmove(data, src, 100*sizeof(twoints));printStructLine(&data[0]);free(data);}}
static void main_sink(twointsclass * data){delete [] data;}static void main(){twointsclass * data;void (*func_ptr) (twointsclass *)=main_sink;data=NULL;data=new twointsclass[100];func_ptr(data);}
void b_main_sink(double * data);static void main(){double * data;data=NULL;data=(double *)malloc(sizeof(*data));b_main_sink(data);}void c_main_sink(double * data);void b_main_sink(double * data){c_main_sink(data);}void d_main_sink(double * data);void c_main_sink(double * data){d_main_sink(data);}void e_main_sink(double * data);void d_main_sink(double * data){e_main_sink(data);}void e_main_sink(double * data){printDoubleLine(*data);free(data);}
void main_sink(int * data){{memcpy(data, src, 100*sizeof(int));printIntLine(data[0]);delete [] data;}}static void main(){int * data;data=NULL;data=new int[100];main_sink(data);}
static wchar_t * main_source(wchar_t * data){data=(wchar_t *)malloc(100*sizeof(wchar_t));return data;}static void main(){wchar_t * data;data=NULL;data=main_source(data);{wchar_t src[100];wcscpy(data, src);printWLine(data);free(data);}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_badbuf[50];char data_goodbuf[100];{char * data=*data_ptr1;data=data_goodbuf;}{char * data=*data_ptr2;{char src[100];_snprintf(data, 100, "%s", src);printLine(data);}}}
static void main(){{if (fwrite((wchar_t *)L"string", sizeof(wchar_t), wcslen(L"string"), stdout)!=wcslen(L"string")){printLine("fwrite failed!");exit(1);}}}
void b_main_sink(char * data_array[]);static void main(){char * data;char * data_array[5];{char * data_buf=(char *)malloc(100*sizeof(char));data=data_buf;}data_array[2]=data;b_main_sink(data_array);}void b_main_sink(char * data_array[]){char * data=data_array[2];printLine(data);free(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}_main_data=data;b_main_sink();}static void main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, "%s", args);va_end(args);printLine(dest);}}void b_main_sink(){char * data=_main_data;main_vasink(data, data);}
static void main(){twointsclass * data;data=NULL;twointsclass data_good;data=&data_good;data->a=0;data->b=0;printIntLine(data->a);printIntLine(data->b);}
static void main(){wchar_t * data;wchar_t * data_badbuf=(wchar_t *)ALLOCA(50*sizeof(wchar_t));wchar_t * data_goodbuf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_goodbuf;{wchar_t * data_copy=data;wchar_t * data=data_copy;{size_t i;wchar_t src[100];for (i=0;i < 100;i++){data[i]=src[i];}printWLine(data);}}}
static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
static void main(){wchar_t * data;union_type my_union;data=NULL;{wchar_t mystring[]=L"mystring";data=wcsdup(mystring);}my_union.a=data;{wchar_t * data=my_union.b;free(data);}}
static void main(){twoints * data;data=NULL;if(global_returns_t_or_f()){data=(twoints *)calloc(100, sizeof(twoints));}else{data=(twoints *)calloc(100, sizeof(twoints));}if(global_returns_t_or_f()){free(data);}else{free(data);}}
static void main(){int * data;struct_type my_struct;data=NULL;data=new int[100];my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){int * data=my_struct.a;delete [] data;}
static void main(){long long * data;data=NULL;data=new long long[100];main_sink_b(data);}void main_sink_b(long long * data){main_sink_c(data);}void main_sink_c(long long * data){main_sink_d(data);}void main_sink_d(long long * data){delete [] data;}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf("%s", args);va_end(args);}}static void main_sink(char * data){main_vasink(data, data);}static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}main_sink(data);}
static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);char * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){strncat(data+data_len, environment, 100-data_len-1);}}my_union.a=data;{char * data=my_union.b;if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}}
static void main_sink(wchar_t * data){EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");func_ptr(data);}
static void main_sink(){wchar_t * data=_main_data;_wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");_main_data=data;main_sink();}
void main_sink_b(char * data);static void main(){char * data;data=new char[100];main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_d(char * data);void main_sink_c(char * data){main_sink_d(data);}void main_sink_e(char * data);void main_sink_d(char * data){main_sink_e(data);}void main_sink_e(char * data){{char dest[50]="";size_t i, data_len;data_len=strlen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printLine(data);delete [] data;}}
static void main_sink(){char * data=_main_data;printf("%s\n", data);}static void main(){char * data;char data_buf[100]="";data=data_buf;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;char *replace;SOCKET listen_socket=INVALID_SOCKET;SOCKET accept_socket=INVALID_SOCKET;size_t data_len=strlen(data);do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;listen_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (listen_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=INADDR_ANY;s_in.sin_port=htons(TCP_PORT);if (bind(listen_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;if (listen(listen_socket, LISTEN_BACKLOG)==SOCKET_ERROR) break;accept_socket=accept(listen_socket, NULL, NULL);if (accept_socket==SOCKET_ERROR) break;recv_rv=recv(accept_socket, (char *)data+data_len, (int)(100-data_len-1), 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data[recv_rv]='\0';replace=strchr(data, '\r');if (replace) *replace='\0';replace=strchr(data, '\n');if (replace) *replace='\0';}while (0);if (listen_socket!=INVALID_SOCKET) CLOSE_SOCKET(listen_socket);if (accept_socket!=INVALID_SOCKET) CLOSE_SOCKET(accept_socket);if (wsa_data_init) WSACleanup();}_main_data=data;main_sink();}
void b_main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100];data=data_buf;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t dest[50]=L"";wcscat(dest, data);printWLine(data);}}
static void main(){twoints * data;data=NULL;data=new twoints;main_sink_b(data);}void main_sink_b(twoints * data){main_sink_c(data);}void main_sink_c(twoints * data){main_sink_d(data);}void main_sink_d(twoints * data){main_sink_e(data);}void main_sink_e(twoints * data){delete data;}
static void main_sink(wchar_t * data){{wchar_t dest[50]=L"";size_t i, data_len;data_len=wcslen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printWLine(data);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t * data_buf=(wchar_t *)ALLOCA(100*sizeof(wchar_t));data=data_buf;func_ptr(data);}
static void main_sink(){char * data=main_data;delete data;}static void main(){char * data;data=NULL;data=new char;printHexCharLine(*data);main_data=data;main_sink();}
static void main_sink(){wchar_t * data=_main_data;if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}_main_data=data;main_sink();}
static void main_sink(wchar_t * data){{wchar_t dest[100];memmove(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=main_sink;wchar_t data_buf[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;func_ptr(data);}
static void main_source(int * &data){{int * data_buf=new int[100];{size_t i;for (i=0;i < 100;i++){data_buf[i]=5;}}data=data_buf;}}static void main(){int * data;main_source(data);printIntLine(data[0]);delete [] data;}
static void main(){int data;data=-1;main_source(data);{char * char_string;if (data > 0){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than 0");}}}void main_source(int &data){data=20;}
static void main(){long long * data;union_type my_union;data=NULL;data=new long long;delete data;my_union.a=data;{long long * data=my_union.b;}}
static void main_source(char * &data){data=new char[100];}static void main(){char * data;data=NULL;main_source(data);{char src[100];strcat(data, src);printLine(data);delete [] data;}}
void main_sink_b(char * data);static void main(){char * data;data=NULL;{char * data_buf=new char[100];memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_d(char * data);void main_sink_c(char * data){main_sink_d(data);}void main_sink_e(char * data);void main_sink_d(char * data){main_sink_e(data);}void main_sink_e(char * data){{char src[100];memcpy(data, src, 100*sizeof(char));data[100-1]='\0';printLine(data);}}
static void main_sink(){char * data=_main_data;EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");_main_data=data;main_sink();}
static void main_sink(){char * data=_main_data;{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");_main_data=data;main_sink();}
static void main(){char * data;data=NULL;data=new char[100];main_data=data;main_sink();}void main_sink(){char * data=main_data;delete [] data;}
void main_sink(wchar_t * data_array[]);static void main(){wchar_t * data;wchar_t * data_array[5];data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}data_array[2]=data;main_sink(data_array);}void main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];{wchar_t dest[100];memcpy(dest, data, 100*sizeof(wchar_t));dest[100-1]=L'\0';printWLine(dest);}}
void b_main_sink();static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");_main_data=data;b_main_sink();}void b_main_sink(){char * data=_main_data;{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
static unsigned char main_source(unsigned char data){data=UCHAR_MAX;return data;}static void main(){unsigned char data;data=' ';data=main_source(data);{unsigned char result=-1;if (data < UCHAR_MAX){result=data+1;printHexUnsignedCharLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){twoints * data;data=NULL;if(global_returns_t_or_f()){{twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine(&data[0]);}}else{{twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine(&data[0]);}}if(global_returns_t_or_f()){}else{}}
static void main(){int * data;data=NULL;data=new int;{int * data_copy=data;int * data=data_copy;printIntLine(*data);}}
static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{int i, n, v;if (swscanf(data, L"%d", &n)==1){if (n < MAX_LOOP){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static int main_source(int count){count=RAND32();return count;}static void main(){int count;count=-1;count=main_source(count);{size_t i=0;FILE *file=NULL;const char *filename="output_good.txt";if (count > 0 && count <=20){file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}}
void b_main_sink(bad_struct data);static void main(){bad_struct data;void (*func_ptr) (bad_struct)=b_main_sink;linked_list head={&head, &head};data.list.next=head.next;data.list.prev=&head;head.next=&data.list;head.next->prev=&data.list;func_ptr(data);}void b_main_sink(bad_struct data){* */prev=data.list.prev;next=data.list.next;prev->next=next;next->prev=prev;}
static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vfwprintf(stdout, L"%s", args);va_end(args);}}static void main(){wchar_t * data;void (*func_ptr) (wchar_t *, ...)=main_vasink;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}func_ptr(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(data);}void b_main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * data;_struct_type my_struct;wchar_t data_buf[100];data=data_buf;my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;{wchar_t dest[50]=L"";size_t i, data_len;data_len=wcslen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printWLine(data);}}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);wchar_t * environment=GETENV(ENV_VARIABLE);if (environment!=NULL){wcsncat(data+data_len, environment, 100-data_len-1);}}{wchar_t dest[100]=L"";SNPRINTF(dest, 100-1, L"%s", data);printWLine(dest);}}
static void main(){struct _twoints * data;_struct_type my_struct;data=NULL;{struct _twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine((twoints *)&data[0]);}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){struct _twoints * data=my_struct.a;}
static void main(){int * data;data=NULL;if(global_returns_t_or_f()){data=new int;}else{data=new int;}if(global_returns_t_or_f()){delete data;}else{delete data;}}
static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}func_ptr(data);}void b_main_sink(char * data){if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main_sink(long long * data){delete data;}static void main(){long long * data;void (*func_ptr) (long long *)=main_sink;data=NULL;data=new long long;func_ptr(data);}
void b_main_sink(int data);static void main(){int data;void (*func_ptr) (int)=b_main_sink;data=-1;data=ASSERT_VALUE+1;func_ptr(data);}void b_main_sink(int data){assert(data > ASSERT_VALUE);}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");_main_data=data;b_main_sink();}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf(data, args);va_end(args);}}void b_main_sink(){char * data=_main_data;main_vasink(data, data);}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;main_sink(data);}void main_sink(twointsclass * data){delete data;}
wchar_t * main_source(wchar_t * data);static void main(){wchar_t * data;data=NULL;data=main_source(data);{wchar_t src[100];wcscat(data, src);printWLine(data);delete [] data;}}wchar_t * main_source(wchar_t * data){data=new wchar_t[100];return data;}
static void main(){twointsclass data;data.a=1;data.b=2;printIntLine(data.a);printIntLine(data.b);}
void b_main_sink(char * * data);static void main(){char * data;char data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;strcat(data, "file.txt");b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{FILE *file=NULL;file=FOPEN(data, "wb+");if (file!=NULL) fclose(file);}}
static void main(){char * data;_union_type my_union;char data_buf[100];data=data_buf;my_union.a=data;{char * data=my_union.b;{char dest[50]="";_snprintf(dest, strlen(data), "%s", data);printLine(data);}}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass;data->a=0;data->b=0;printIntLine(data->a);printIntLine(data->b);main_data=data;main_sink();}void main_sink(){twointsclass * data=main_data;delete data;}
static void main(){int data;data=-1;data=5;b_main_sink(&data);}void b_main_sink(int * data_ptr){int data=*data_ptr;{int result=data * data;printIntLine(result);}}
static void main(){char * data;data=NULL;data=new char[100];main_data=data;main_sink();}void main_sink(){char * data=main_data;delete [] data;}
static void main(){int data;_union_type my_union;data=-1;data=INT_MAX;my_union.a=data;{int data=my_union.b;{int result=-1;if (data < INT_MAX){result=data+1;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}}
static void main(){wchar_t * data;_struct_type my_struct;data=NULL;{wchar_t mystring[]=L"mystring";data=wcsdup(mystring);printWLine(data);}my_struct.a=data;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * data=my_struct.a;free(data);}
void main_sink_b(char * data);static void main(){char * data;{char * data_buf=new char[100];data=data_buf;}main_sink_b(data);}void main_sink_c(char * data);void main_sink_b(char * data){main_sink_c(data);}void main_sink_d(char * data);void main_sink_c(char * data){main_sink_d(data);}void main_sink_e(char * data);void main_sink_d(char * data){main_sink_e(data);}void main_sink_e(char * data){printLine(data);delete [] data;}
static void main(){long long * data;data=NULL;data=new long long[100];main_sink_b(data);}void main_sink_b(long long * data){main_sink_c(data);}void main_sink_c(long long * data){main_sink_d(data);}void main_sink_d(long long * data){main_sink_e(data);}void main_sink_e(long long * data){delete [] data;}
static int main_source(int data){fscanf (stdin, "%d", &data);return data;}static void main(){int data;data=-1;data=main_source(data);{int result=-1;if (data <=(INT_MAX/2)){result=data * 2;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static char * main_source(char * data){data=(char *)malloc((10+1)*sizeof(char));return data;}static void main(){char * data;data=NULL;data=main_source(data);{char data_src[10+1]=SRC_STRING;memmove(data, data_src, strlen(data_src)*sizeof(char));printLine(data);free(data);}}
static void main(){if(global_returns_t_or_f()){{if (REMOVE("removemebad.txt")!=0){printLine("remove failed!");}}}else{{if (REMOVE("removemebad.txt")!=0){printLine("remove failed!");}}}}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vfprintf(stdout, data, args);va_end(args);}}static void main(){char * data;_union_type my_union;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");my_union.a=data;{char * data=my_union.b;main_vasink(data, data);}}
static int main_source(int data){data=10000;return data;}static void main(){int data;data=-1;data=main_source(data);{char * char_string;if ((size_t)data > strlen(HELLO_STRING) && data < 100){char_string=new char[data];strcpy(char_string, HELLO_STRING);printLine(char_string);delete [] char_string;}else{printLine("Input is less than the length of the source string or too large");}}}
static void main(){unsigned int data;data=0;data=(unsigned int)RAND32();_main_data=data;b_main_sink();}void b_main_sink(){unsigned int data=_main_data;{unsigned int result=-1;if (data <=(UINT_MAX/2)){result=data * 2;printUnsignedLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100];data=data_buf;{char * data=*data_ptr1;}{char * data=*data_ptr2;{char dest[50]="";_snprintf(dest, strlen(data), "%s", data);printLine(data);}}}
static void main(){long long * data;void (*func_ptr) (long long *)=main_sink;data=NULL;data=new long long[100];delete [] data;func_ptr(data);}void main_sink(long long * data){}
static void main(){int data;data=-1;data=20;main_sink(data);}void main_sink(int data){{wchar_t * wchar_t_string;if (data > 0){wchar_t_string=new wchar_t[data];wcscpy(wchar_t_string, HELLO_STRING);printWLine(wchar_t_string);delete [] wchar_t_string;}else{printLine("Input is less than 0");}}}
static void helper_main(){printLine("helper_main()");}static void main(){printLine("_good()");helper_main();}
static void main(){char * data;data=NULL;data=new char[100];{char * data_copy=data;char * data=data_copy;{char src[100];strcat(data, src);printLine(data);delete [] data;}}}
static void main(){int count;count=-1;{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;count=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}{int count_copy=count;int count=count_copy;{size_t i=0;FILE *file=NULL;const char *filename="output_good.txt";if (count > 0 && count <=20){file=fopen(filename, "w+");if (file==NULL) exit(1);for (i=0;i < (size_t)count;i++){if (strlen(SENTENCE)!=fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), file)) exit(1);}if (file){fclose(file);}}}}}
static void main(){char * data;char data_buf[100]="";data=data_buf;data=b_main_source(data);if (strncmp(PASSWORD, data, strlen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}char * b_main_source(char * data){data=PASSWORD;return data;}
static void main(){twointsclass * data;data=NULL;twointsclass data_good;data=&data_good;data->a=0;data->b=0;printIntLine(data->a);printIntLine(data->b);main_sink_b(data);}void main_sink_b(twointsclass * data){main_sink_c(data);}void main_sink_c(twointsclass * data){main_sink_d(data);}void main_sink_d(twointsclass * data){main_sink_e(data);}void main_sink_e(twointsclass * data){}
void main_sink(char * data){{char dest[50]="";strcat(dest, data);printLine(data);delete [] data;}}static void main(){char * data;data=new char[100];main_sink(data);}
void b_main_sink(int data);static void main(){int data;data=-1;data=CHAR_MAX-5;b_main_sink(data);}void c_main_sink(int data);void b_main_sink(int data){c_main_sink(data);}void d_main_sink(int data);void c_main_sink(int data){d_main_sink(data);}void d_main_sink(int data){{short s=(short)data;printf("%hd\n", s);}}
static void main(){twointsclass * data;data=NULL;data=new twointsclass[100];main_sink(data);}void main_sink(twointsclass * data){delete [] data;}
void _main_sink(short data){{char c=(char)data;printHexCharLine(c);}}static void main(){short data;data=-1;data=CHAR_MAX-5;_main_sink(data);}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{wchar_t *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECVP(COMMAND_INT, args);}}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(&data);}static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf(data, args);va_end(args);}}void b_main_sink(char * * data_ptr){char * data=*data_ptr;main_vasink(data, data);}
static void main(){wchar_t data;data=L'W';printf("%02lx\n", data);data=L'Z';printf("%02lx\n", data);}
static void main(){FILE * data;data=fopen("GoodSource_fopen.txt", "w+");b_main_sink(data);}void b_main_sink(FILE * data){c_main_sink(data);}void c_main_sink(FILE * data){d_main_sink(data);}void d_main_sink(FILE * data){e_main_sink(data);}void e_main_sink(FILE * data){fclose(data);}
static void main_vasink(char * data, ...){{va_list args;va_start(args, data);vprintf("%s", args);va_end(args);}}static void main_sink(){char * data=_main_data;main_vasink(data, data);}static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);if(100-data_len > 1){fgets(data+data_len, (int)(100-data_len), stdin);data_len=strlen(data);if (data_len > 0){data[data_len-1]='\0';}}}_main_data=data;main_sink();}
static void main(){char * data;data=NULL;data=new char;main_sink(data);}void main_sink(char * data){delete data;}
static void main(){{wchar_t dst[DST_SZ];memcpy(dst, COPY_STR, (DST_SZ-1)*sizeof(wchar_t));dst[DST_SZ-1]=L'\0';printWLine(dst);}}
static void main(){int * data;int * data_badbuf=(int *)ALLOCA(50*sizeof(int));int * data_goodbuf=(int *)ALLOCA(100*sizeof(int));if(global_returns_t_or_f()){data=data_goodbuf;}else{data=data_goodbuf;}{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printIntLine(data[0]);}}}
static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");func_ptr(data);}void b_main_sink(char * data){fprintf(stdout, data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcpy(data, "fixedstringtest");b_main_sink(data);}void b_main_sink(char * data){printf(data);}
static void main(){wchar_t * data;wchar_t * data_array[5];wchar_t data_buf[100]=L"";data=data_buf;{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}data_array[2]=data;b_main_sink(data_array);}static void main_vasink(wchar_t * data, ...){{wchar_t dest[100]=L"";va_list args;va_start(args, data);_vsnwprintf(dest, 100-1, L"%s", args);va_end(args);printWLine(dest);}}void b_main_sink(wchar_t * data_array[]){wchar_t * data=data_array[2];main_vasink(data, data);}
static char * main_source(char * data){{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}return data;}static void main(){char * data;data=NULL;data=main_source(data);{char dest[100];strncpy(dest, data, strlen(dest));dest[100-1]='\0';printLine(dest);}}
static void main(){twoints * data;data=NULL;data=b_main_source(data);}twoints * b_main_source(twoints * data){{twoints data_goodbuf[100];data=data_goodbuf;data[0].a=0;data[0].b=0;printStructLine(&data[0]);}return data;}
static void main(){char * data;char data_buf[100]="";data=data_buf;strcat(data, "*.*");{char *args[]={COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL};EXECV(COMMAND_INT_PATH, args);}}
static void main_sink(){int data=_main_data;{int result=0;if (data > INT_MIN){result=data-1;printIntLine(result);}else{printLine("Input value is too small to perform arithmetic safely.");}}}static void main(){int data;data=-1;data=RAND32();_main_data=data;main_sink();}
static void main(){char * data;data=NULL;data=new char[100];memset(data, 'A', 100-1);data[100-1]='\0';delete [] data;main_sink_b(data);}void main_sink_b(char * data){main_sink_c(data);}void main_sink_c(char * data){main_sink_d(data);}void main_sink_d(char * data){main_sink_e(data);}void main_sink_e(char * data){}
void b_main_sink(char * * data);static void main(){char * data;data=NULL;{char * data_buf=(char *)malloc(100*sizeof(char));memset(data_buf, 'A', 100-1);data_buf[100-1]='\0';data=data_buf;}b_main_sink(&data);}void b_main_sink(char * * data_ptr){char * data=*data_ptr;{size_t i;char dest[100];for (i=0;i < 100;i++){dest[i]=data[i];}dest[100-1]='\0';printLine(dest);}}
static void main_sink(){int * data=_main_data;printIntLine(*data);}static void main(){int * data;data=NULL;{int tmp=5;data=&tmp;}_main_data=data;main_sink();}
static void main_sink(){char * data=_main_data;{size_t i;char src[100];for (i=0;i < 100;i++){data[i]=src[i];}printLine(data);free(data);}}static void main(){char * data;data=NULL;data=(char *)malloc(100*sizeof(char));_main_data=data;main_sink();}
static void main(){char * data;char * *data_ptr1=&data;char * *data_ptr2=&data;char data_buf[100]="";data=data_buf;{char * data=*data_ptr1;strcpy(data, "15");}{char * data=*data_ptr2;{int i, n, v;if (sscanf(data, "%d", &n)==1){v=0;for (i=0;i < n;i++){}printIntLine(v);}}}}
static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");{FILE *file=NULL;file=FOPEN(data, L"wb+");if (file!=NULL) fclose(file);}}
static void main_sink(wchar_t * data){delete [] data;}static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_sink(data);}
static void main(){char * data;void (*func_ptr) (char *, ...)=b_main_vasink;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}func_ptr(data);}void b_main_vasink(char * data, ...){{char dest[100]="";va_list args;va_start(args, data);vsnprintf(dest, 100-1, "%s", args);va_end(args);printLine(dest);}}
char * b_main_source(char * data);static void main(){char * data;char data_buf[100]=FULL_COMMAND;data=data_buf;data=b_main_source(data);system(data);}char * b_main_source(char * data){strcat(data, "*.*");return data;}
static int main_source(int data){{WSADATA wsa_data;int wsa_data_init=0;int recv_rv;struct sockaddr_in s_in;SOCKET connect_socket=INVALID_SOCKET;char input_buf[CHAR_ARRAY_SIZE];do{if (WSAStartup(MAKEWORD(2,2), &wsa_data)!=NO_ERROR) break;wsa_data_init=1;connect_socket=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);if (connect_socket==INVALID_SOCKET) break;memset(&s_in, 0, sizeof(s_in));s_in.sin_family=AF_INET;s_in.sin_addr.s_addr=inet_addr("127.0.0.1");s_in.sin_port=htons(TCP_PORT);if (connect(connect_socket, (struct sockaddr*)&s_in, sizeof(s_in))==SOCKET_ERROR) break;recv_rv=recv(connect_socket, input_buf, CHAR_ARRAY_SIZE, 0);if (recv_rv==SOCKET_ERROR || recv_rv==0) break;data=atoi(input_buf);}while (0);if (connect_socket!=INVALID_SOCKET) CLOSE_SOCKET(connect_socket);if (wsa_data_init) WSACleanup();}return data;}static void main(){int data;data=-1;data=main_source(data);{int result=-1;if (data <=(int)sqrt((int)INT_MAX)){result=data * data;printIntLine(result);}else{printLine("Input value is too large to perform arithmetic safely.");}}}
static void main_sink(char * password){{HANDLE pHandle;char * username="User";char * domain="Domain";if (LogonUserA( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}static void main(){char * password;void (*func_ptr) (char *)=main_sink;char password_buf[100]="";password=password_buf;strcpy(password, "Password1234!");func_ptr(password);}
static wchar_t * main_source(wchar_t * data){data=PASSWORD;return data;}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);if (wcsncmp(PASSWORD, data, wcslen(PASSWORD))==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){int data;data=7;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){int * data_ptr=(int *)void_data_ptr;int data=(*data_ptr);{wchar_t data_buf[10]=L"AAAAAAAAA";if (data >=0){printWcharLine(data_buf[data]);}else{printLine("ERROR: Array index is negative");}}}
static void main(){twoints * data;twoints * *data_ptr1=&data;twoints * *data_ptr2=&data;data=NULL;{twoints * data=*data_ptr1;data=(twoints *)malloc(100*sizeof(twoints));data[0].a=0;data[0].b=0;printStructLine(&data[0]);}{twoints * data=*data_ptr2;free(data);}}
void _main_sink(int data){{char c=(char)data;printHexCharLine(c);}}static void main(){int data;data=-1;data=CHAR_MAX-5;_main_sink(data);}
static void main(){wchar_t * data;_union_type my_union;wchar_t data_buf[100]=L"";data=data_buf;wcscat(data, L"*.*");my_union.a=data;{wchar_t * data=my_union.b;_wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG2, COMMAND_ARG3, NULL);}}
static wchar_t * main_source(wchar_t * data){{size_t data_len=wcslen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN(L"C:\\temp\\file.txt", L"r");if (pFile!=NULL){fgetws(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}return data;}static void main_vasink(wchar_t * data, ...){{va_list args;va_start(args, data);vwprintf(L"%s", args);va_end(args);}}static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;data=main_source(data);main_vasink(data, data);}
static void main(){int * data;struct_type my_struct;data=NULL;data=new int[100];my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){int * data=my_struct.a;delete [] data;}
void b_main_sink(wchar_t * data);static void main(){wchar_t * data;void (*func_ptr) (wchar_t *)=b_main_sink;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");func_ptr(data);}void b_main_sink(wchar_t * data){{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
static void main(){char * data;char data_buf[FILENAME_MAX]="";data=data_buf;if(global_returns_t_or_f()){strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");}else{strcpy(data, "c:\\temp\\file.txt");strcpy(data, "/tmp/file.txt");}{HANDLE hFile;hFile=CreateFileA(data, (GENERIC_WRITE|GENERIC_READ), 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile!=INVALID_HANDLE_VALUE){CloseHandle(hFile);}}}
void b_main_sink(char * data);static void main(){char * data;void (*func_ptr) (char *)=b_main_sink;char * data_badbuf=(char *)ALLOCA(50*sizeof(char));char * data_goodbuf=(char *)ALLOCA(100*sizeof(char));data=data_goodbuf;func_ptr(data);}void b_main_sink(char * data){{char src[100];memmove(data, src, 100*sizeof(char));printLine(data);}}
static void main(){wchar_t * data;wchar_t * *data_ptr1=&data;wchar_t * *data_ptr2=&data;wchar_t data_buf[100];data=data_buf;{wchar_t * data=*data_ptr1;}{wchar_t * data=*data_ptr2;{wchar_t dest[50]=L"";wcscpy(dest, data);printWLine(data);}}}
void b_main_sink(void * void_data_ptr);static void main(){char * data;char * data_buf=(char *)ALLOCA(100*sizeof(char));data=data_buf;b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);{char dest[50]="";_snprintf(dest, strlen(data), "%s", data);printLine(data);}}
void b_main_sink(void * void_data_ptr);static void main(){wchar_t * data;wchar_t data_buf[250]=L"PATH=";data=data_buf;wcscat(data, NEW_PATH);b_main_sink(&data);}void b_main_sink(void * void_data_ptr){wchar_t * * data_ptr=(wchar_t * *)void_data_ptr;wchar_t * data=(*data_ptr);PUTENV(data);}
static void main(){int data;int *data_ptr1=&data;int *data_ptr2=&data;data=-1;{int data=*data_ptr1;data=5;}{int data=*data_ptr2;{int result=data * data;printIntLine(result);}}}
void b_main_sink(_struct_type my_struct);static void main(){wchar_t * password;_struct_type my_struct;wchar_t password_buf[100]=L"";password=password_buf;wcscpy(password, L"Password1234!");my_struct.a=password;b_main_sink(my_struct);}void b_main_sink(_struct_type my_struct){wchar_t * password=my_struct.a;{HANDLE pHandle;wchar_t * username=L"User";wchar_t * domain=L"Domain";if (LogonUserW( username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &pHandle)!=0){printLine("User logged in successfully.");CloseHandle(pHandle);}else{printLine("Unable to login.");}}}
void b_main_sink();static void main(){long long * data;long long data_badbuf[50];long long data_goodbuf[100];data=data_goodbuf;_main_data=data;b_main_sink();}void b_main_sink(){long long * data=_main_data;{memmove(data, src, 100*sizeof(long long));printLongLongLine(data[0]);}}
void b_main_sink(long long * data);static void main(){long long * data;long long * data_badbuf=(long long *)ALLOCA(50*sizeof(long long));long long * data_goodbuf=(long long *)ALLOCA(100*sizeof(long long));data=data_goodbuf;b_main_sink(data);}void c_main_sink(long long * data);void b_main_sink(long long * data){c_main_sink(data);}void d_main_sink(long long * data);void c_main_sink(long long * data){d_main_sink(data);}void e_main_sink(long long * data);void d_main_sink(long long * data){e_main_sink(data);}void e_main_sink(long long * data){{{size_t i;for (i=0;i < 100;i++){data[i]=src[i];}printLongLongLine(data[0]);}}}
static void main(){twointsclass * data;data=NULL;data=NULL;data=(twointsclass *)realloc(data, 100*sizeof(twointsclass));main_data=data;main_sink();}void main_sink(){twointsclass * data=main_data;free(data);}
static void main(){wchar_t * data;wchar_t data_buf[100]=L"";data=data_buf;if(global_returns_t_or_f()){{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}}else{{size_t data_len=wcslen(data);if(100-data_len > 1){fgetws(data+data_len, (int)(100-data_len), stdin);data_len=wcslen(data);if (data_len > 0){data[data_len-1]=L'\0';}}}}if(global_returns_t_or_f()){if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}else{if (wcscmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}}
static void main(){twointsclass * data;struct_type my_struct;data=NULL;data=new twointsclass[100];{size_t i;for(i=0;i < 100;i++){data[i].a=1;data[i].b=2;}}my_struct.a=data;main_sink(my_struct);}void main_sink(struct_type my_struct){twointsclass * data=my_struct.a;printIntLine(data[0].a);}
static void main(){wchar_t * data;data=new wchar_t[100];{wchar_t dest[50]=L"";size_t i, data_len;data_len=wcslen(data);for (i=0;i < data_len;i++){dest[i]=data[i];}printWLine(data);delete [] data;}}
static void main(){{HCRYPTPROV hCryptProv;BYTE pbData[4];int data;if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0)) exit(1);if (!CryptGenRandom(hCryptProv, 4, pbData)){CryptReleaseContext(hCryptProv, 0);exit(1);}CryptReleaseContext(hCryptProv, 0);data=(int)*pbData;printIntLine(data);}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t;delete data;}
static void main(){wchar_t * data;data=NULL;{wchar_t * data_buf=new wchar_t[100];wmemset(data_buf, L'A', 100-1);data_buf[100-1]=L'\0';data=data_buf;}{wchar_t * data_copy=data;wchar_t * data=data_copy;{wchar_t dest[100];wcsncpy(dest, data, wcslen(dest));dest[100-1]=L'\0';printWLine(dest);}}}
static void main(){{std_thread thread_a=NULL;std_thread thread_b=NULL;int val;val=0;if (!std_thread_lock_create(&g_good_lock)){return;}if (!std_thread_create(helper_good, (void*)&val, &thread_a)){thread_a=NULL;}if (!std_thread_create(helper_good, (void*)&val, &thread_b)){thread_b=NULL;}if (thread_a && std_thread_join(thread_a)) std_thread_destroy(thread_a);if (thread_b && std_thread_join(thread_b)) std_thread_destroy(thread_b);std_thread_lock_destroy(g_good_lock);printIntLine(val);}}
void b_main_sink(wchar_t * * data);static void main(){wchar_t * data;wchar_t data_buf[FILENAME_MAX]=BASEPATH;data=data_buf;wcscat(data, L"file.txt");b_main_sink(&data);}void b_main_sink(wchar_t * * data_ptr){wchar_t * data=*data_ptr;{int fd;fd=OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);if (fd!=-1){CLOSE(fd);}}}
void main_sink_b(long long * data);static void main(){long long * data;{long long * data_buf=new long long[100];{size_t i;for (i=0;i < 100;i++){data_buf[i]=5L;}}data=data_buf;}main_sink_b(data);}void main_sink_c(long long * data);void main_sink_b(long long * data){main_sink_c(data);}void main_sink_d(long long * data);void main_sink_c(long long * data){main_sink_d(data);}void main_sink_e(long long * data);void main_sink_d(long long * data){main_sink_e(data);}void main_sink_e(long long * data){printLongLongLine(data[0]);delete [] data;}
void b_main_sink(int data_array[]);static void main(){int data;int data_array[5];data=-1;data=100-1;data_array[2]=data;b_main_sink(data_array);}void b_main_sink(int data_array[]){int data=data_array[2];{char src[100];char dest[100]="";memset(src, 'A', 100-1);src[100-1]='\0';if (data < 100){memmove(dest, src, data);}printLine(dest);}}
static void main(){{char src[]=SRC_STR;char dst[DST_SZ];memcpy(dst, src, sizeof(src));printLine(dst);}}
static void main(){wchar_t * data;data=NULL;data=new wchar_t[100];main_sink(data);}void main_sink(wchar_t * data){delete [] data;}
static void main(){int * data;data=NULL;data=new int;delete data;main_data=data;main_sink();}void main_sink(){int * data=main_data;}
static void main_sink(char * data){delete [] data;}static void main(){char * data;void (*func_ptr) (char *)=main_sink;data=NULL;data=new char[100];func_ptr(data);}
static void main(){char * data;char data_buf[100]="";data=data_buf;{size_t data_len=strlen(data);FILE * pFile;if(100-data_len > 1){pFile=FOPEN("C:\\temp\\file.txt", "r");if (pFile!=NULL){fgets(data+data_len, (int)(100-data_len), pFile);fclose(pFile);}}}b_main_sink(&data);}void b_main_sink(void * void_data_ptr){char * * data_ptr=(char * *)void_data_ptr;char * data=(*data_ptr);if (strcmp(PASSWORD, data)==0) printLine("Access granted");else printLine("Access denied!");}
static void main(){char * data;data=NULL;main_source(data);delete data;}void main_source(char * &data){data=new char;}
static void main(){char * data;char * &data_ref=data;data=NULL;data=new char[100];{char * data=data_ref;{char src[100];memcpy(data, src, 100*sizeof(char));printLine(data);delete [] data;}}}
